// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: supervisor/v1/supervisor.proto

package v1

import (
	v1 "code.storageos.net/storageos/service/common/v1"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SupervisorClient is the client API for Supervisor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SupervisorClient interface {
	// Query the status of the dataplane. At the moment there's nothing actually interesting in the
	// response type. Simply calling this RPC and receiving a response denotes that the dataplane is
	// up and running an ready to service RPCs. This API comes in useful in scripts which want to
	// poll until the dataplane is ready (for example in the DPLL systemd scripts) and in contexts
	// where we want to explicitly check the network connection to the DP (for example in Symmetra).
	// Note: there's some overlap in functionality with the dataplane Event server, which sends
	// EventDataplaneStartupFinished and EventDataplaneShutdownComplete messages on startup and
	// shutdown respectively. The CP should favour using the event server API to ascertain when the
	// dataplane is started and ready to receive RPC requests.
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// ----------------- CONFIGURATIONS RPCS -------------------------------
	// Creates deployment. Either a master or a replica. The CP should signals
	// which by setting the `deployment_type` field within the DeploymentConfig
	// message type. Like all "Configure*" RPCs this method has "create if not
	// present, else update" semantics, i.e.:
	//
	//  - if no configuration exists for "uuid" we create the deployment
	//  - if configuration exists for "uuid" then we overwrite the current config.
	//
	// Creates will be rejected if: the CP tries to configure a replica deployment
	// which has replicas; the consumer count is zero.
	//
	// Overwites will be rejected if: the consumer count is decremented or the
	// compression flag has changed. Once specified compression can not be modified.
	//
	// Under the hood this method creates the blob files into which we'll store
	// user data and sets up the network connection to any replicas (master
	// deployments only).
	//
	// Note: this RPC does not configure the replicas it merely tells the
	// master about the existance and location of its replicas. To configure
	// the replicas call ConfigureReplica on the appropriate replica nodes,
	// prior to this call.
	//
	// On success rpc_result.success will be set to true. On failure it will
	// be set to false and rpc_result.code will be set to STATUS_*.
	// rpc_result.reason may be set.
	ConfigureDeployment(ctx context.Context, in *ConfigureDeploymentRequest, opts ...grpc.CallOption) (*ConfigureDeploymentResponse, error)
	// Deconfigure the deployment. This lets the dataplane know that we are done
	// with the deployment and allows the dataplane to release runtime resources
	// associated with the deployment. The CP would typically call this API when
	// a the volume is no longer in use.
	//
	// This RPC does not delete the block (meta)data associated with the
	// deployment. Call DeleteDeployment for that.
	//
	// On success rpc_result.success will be set to true. On failure it will be
	// set to false and rpc_result.code will be set accordingly. The only specific
	// code returned is STATUS_NOT_FOUND - this is set when the deployment you
	// asked to deconfigure is not configured. For all other errors rpc_result.code
	// will be set to STATUS_*. In all failure case rpc_result.reason may be set.
	DeconfigureDeployment(ctx context.Context, in *DeconfigureDeploymentRequest, opts ...grpc.CallOption) (*DeconfigureDeploymentResponse, error)
	// Irrevocably delete the deployment (meta)data.
	//
	// The deployment must be deconfigured, via DeconfigureDeployment, prior
	// to calling this method, or we'll reject the request with an error.
	//
	// On success rpc_result.success will be set to true. On failure it will be
	// set to false and rpc_result.code will be set accordingly. The only specific
	// code returned is STATUS_NOT_FOUND - this is set when the deployment you
	// asked to delete does no exist. For all other errors rpc_result.code will be
	// set to STATUS_*. In all failure case rpc_result.reason may be set.
	DeleteDeployment(ctx context.Context, in *DeleteDeploymentRequest, opts ...grpc.CallOption) (*DeleteDeploymentResponse, error)
	// Configure a presentation. This creates a block device which can be used
	// to access the volume. This RPC works for both local and remote
	// presentations. Like all "Configure*" RPCs this method has "create if not
	// present, else update" semantics, i.e.:
	//
	//  - if no configuration exists for "presentation_uuid" then create the
	//  presentation
	//  - if a presentation exists for "presentation_uuid" then apply any diffs
	//    against the existing config. Valid diffs include: increasing the
	//    volume size, changing the target deployment (useful during a fail
	//    over); and increasing the consumer count. It's not permitted to change
	//    the crypto config for obvious reasons.
	//
	// On success rpc_result.success will be set to true. On failure it will
	// be set to false and rpc_result.code will be set to STATUS_*.
	// rpc_result.reason may be set.
	ConfigurePresentation(ctx context.Context, in *ConfigurePresentationRequest, opts ...grpc.CallOption) (*ConfigurePresentationResponse, error)
	// Delete a previous created presentation
	//
	// On success rpc_result.success will be set to true. On failure it will
	// be set to false and rpc_result.code will be set accordingly. The only
	// specific code returned is STATUS_NOT_FOUND - this is set when the
	// presentation you asked to delete doesn't even exist. For all other errors
	// rpc_result.code will be set to STATUS_*. In all failure case
	// rpc_result.reason may be set.
	DeconfigurePresentation(ctx context.Context, in *DeconfigurePresentationRequest, opts ...grpc.CallOption) (*DeconfigurePresentationResponse, error)
	// Set the consumer count for a deployment. This should only ever be called
	// on the master deployment (we don't ever need to set the consumer count
	// on a replica). The CP only needs to call this API when it wants to
	// explicitly change the consumer count. The only time I believe this is
	// currently necessary is during a failover. Normally the consumer count value
	// is implicitly transmitted to the dataplane by calling ConfigureDeployment. The
	// ConfigureDeployment request contains the consumer count.
	//
	// On success rpc_result.success will be set to true. On failure it will
	// be set to false and rpc_result.code will be set accordingly. The only
	// specific code returned is STATUS_NOT_FOUND - this is set when the
	// master you asked to set the CC on doesn't even exist. For all other
	// errors rpc_result.code will be set to STATUS_*. In all failure case
	// rpc_result.reason may be set. If the consumer count which was requested
	// to be set is LOWER than the currently set value then this method will
	// set rpc_result.success to true. The actual value of the consumer count
	// - i.e. the current, higher value - will be returned in the response.
	SetConsumerCount(ctx context.Context, in *SetConsumerCountRequest, opts ...grpc.CallOption) (*SetConsumerCountResponse, error)
	// Get the consumer count for a given deployment
	//
	// Returns STATUS_NOT_FOUND if the deployment does not exist.
	// Returns STATUS_* for any other errors
	GetConsumerCount(ctx context.Context, in *GetConsumerCountRequest, opts ...grpc.CallOption) (*GetConsumerCountResponse, error)
	// Dump the dataplane's current configuration
	DumpConfig(ctx context.Context, in *DumpConfigRequest, opts ...grpc.CallOption) (*DumpConfigResponse, error)
	// Config services, from common.v1.
	ConfigGetBool(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetBoolReply, error)
	ConfigUpdateBool(ctx context.Context, in *v1.ConfigBool, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListBool(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigBoolList, error)
	ConfigGetString(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetStringReply, error)
	ConfigUpdateString(ctx context.Context, in *v1.ConfigString, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListString(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigStringList, error)
	ConfigGetUint32(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint32Reply, error)
	ConfigUpdateUint32(ctx context.Context, in *v1.ConfigUint32, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListUint32(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint32List, error)
	ConfigGetUint64(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint64Reply, error)
	ConfigUpdateUint64(ctx context.Context, in *v1.ConfigUint64, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListUint64(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint64List, error)
	// ----------------- DP INTERNAL RPCS -------------------------------
	// List all of the network connections which this node has with other dataplanes.
	// Established and un-established connections are shown. Users can drill down into
	// the individual connection to see its status.
	ListConnections(ctx context.Context, in *ListConnectionsRequest, opts ...grpc.CallOption) (*ListConnectionsResponse, error)
	// Add new connections (for debugging purposes)
	AddConnection(ctx context.Context, in *AddConnectionRequest, opts ...grpc.CallOption) (*AddConnectionResponse, error)
	// Remove new connections (for debugging purposes)
	RemoveConnection(ctx context.Context, in *RemoveConnectionRequest, opts ...grpc.CallOption) (*RemoveConnectionResponse, error)
	// Sync the specified regions from the source deployment to the destination
	// deployment. Called by Symmetra.
	SyncRegions(ctx context.Context, in *SyncRegionsRequest, opts ...grpc.CallOption) (*SyncRegionsResponse, error)
	// Return a hash list for the specified deployment, over the specified range.
	// Note: this is a streaming RPC as the hash lists returned could
	// conceiveably be multiple megabytes in size.
	//
	// returns the hash list and deployment hash
	DeploymentHashList(ctx context.Context, in *DeploymentHashListRequest, opts ...grpc.CallOption) (Supervisor_DeploymentHashListClient, error)
	// Collect the dataplane node-level metrics and specific per-volume metrics.
	// NOTE: This is an experimental dataplane-only API. It's probably not quite
	// what the control-plane requires in terms of a metrics API, but it's fine
	// for dataplane tooling and tests.
	Metrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error)
}

type supervisorClient struct {
	cc grpc.ClientConnInterface
}

func NewSupervisorClient(cc grpc.ClientConnInterface) SupervisorClient {
	return &supervisorClient{cc}
}

func (c *supervisorClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigureDeployment(ctx context.Context, in *ConfigureDeploymentRequest, opts ...grpc.CallOption) (*ConfigureDeploymentResponse, error) {
	out := new(ConfigureDeploymentResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigureDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) DeconfigureDeployment(ctx context.Context, in *DeconfigureDeploymentRequest, opts ...grpc.CallOption) (*DeconfigureDeploymentResponse, error) {
	out := new(DeconfigureDeploymentResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/DeconfigureDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) DeleteDeployment(ctx context.Context, in *DeleteDeploymentRequest, opts ...grpc.CallOption) (*DeleteDeploymentResponse, error) {
	out := new(DeleteDeploymentResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/DeleteDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigurePresentation(ctx context.Context, in *ConfigurePresentationRequest, opts ...grpc.CallOption) (*ConfigurePresentationResponse, error) {
	out := new(ConfigurePresentationResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigurePresentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) DeconfigurePresentation(ctx context.Context, in *DeconfigurePresentationRequest, opts ...grpc.CallOption) (*DeconfigurePresentationResponse, error) {
	out := new(DeconfigurePresentationResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/DeconfigurePresentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) SetConsumerCount(ctx context.Context, in *SetConsumerCountRequest, opts ...grpc.CallOption) (*SetConsumerCountResponse, error) {
	out := new(SetConsumerCountResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/SetConsumerCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) GetConsumerCount(ctx context.Context, in *GetConsumerCountRequest, opts ...grpc.CallOption) (*GetConsumerCountResponse, error) {
	out := new(GetConsumerCountResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/GetConsumerCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) DumpConfig(ctx context.Context, in *DumpConfigRequest, opts ...grpc.CallOption) (*DumpConfigResponse, error) {
	out := new(DumpConfigResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/DumpConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigGetBool(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetBoolReply, error) {
	out := new(v1.ConfigGetBoolReply)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigGetBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigUpdateBool(ctx context.Context, in *v1.ConfigBool, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigUpdateBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigListBool(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigBoolList, error) {
	out := new(v1.ConfigBoolList)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigListBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigGetString(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetStringReply, error) {
	out := new(v1.ConfigGetStringReply)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigGetString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigUpdateString(ctx context.Context, in *v1.ConfigString, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigUpdateString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigListString(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigStringList, error) {
	out := new(v1.ConfigStringList)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigListString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigGetUint32(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint32Reply, error) {
	out := new(v1.ConfigGetUint32Reply)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigGetUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigUpdateUint32(ctx context.Context, in *v1.ConfigUint32, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigUpdateUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigListUint32(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint32List, error) {
	out := new(v1.ConfigUint32List)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigListUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigGetUint64(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint64Reply, error) {
	out := new(v1.ConfigGetUint64Reply)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigGetUint64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigUpdateUint64(ctx context.Context, in *v1.ConfigUint64, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigUpdateUint64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigListUint64(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint64List, error) {
	out := new(v1.ConfigUint64List)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ConfigListUint64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ListConnections(ctx context.Context, in *ListConnectionsRequest, opts ...grpc.CallOption) (*ListConnectionsResponse, error) {
	out := new(ListConnectionsResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/ListConnections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) AddConnection(ctx context.Context, in *AddConnectionRequest, opts ...grpc.CallOption) (*AddConnectionResponse, error) {
	out := new(AddConnectionResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/AddConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) RemoveConnection(ctx context.Context, in *RemoveConnectionRequest, opts ...grpc.CallOption) (*RemoveConnectionResponse, error) {
	out := new(RemoveConnectionResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/RemoveConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) SyncRegions(ctx context.Context, in *SyncRegionsRequest, opts ...grpc.CallOption) (*SyncRegionsResponse, error) {
	out := new(SyncRegionsResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/SyncRegions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) DeploymentHashList(ctx context.Context, in *DeploymentHashListRequest, opts ...grpc.CallOption) (Supervisor_DeploymentHashListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Supervisor_ServiceDesc.Streams[0], "/service.supervisor.v1.Supervisor/DeploymentHashList", opts...)
	if err != nil {
		return nil, err
	}
	x := &supervisorDeploymentHashListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Supervisor_DeploymentHashListClient interface {
	Recv() (*DeploymentHashListResponse, error)
	grpc.ClientStream
}

type supervisorDeploymentHashListClient struct {
	grpc.ClientStream
}

func (x *supervisorDeploymentHashListClient) Recv() (*DeploymentHashListResponse, error) {
	m := new(DeploymentHashListResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *supervisorClient) Metrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error) {
	out := new(MetricsResponse)
	err := c.cc.Invoke(ctx, "/service.supervisor.v1.Supervisor/Metrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SupervisorServer is the server API for Supervisor service.
// All implementations should embed UnimplementedSupervisorServer
// for forward compatibility
type SupervisorServer interface {
	// Query the status of the dataplane. At the moment there's nothing actually interesting in the
	// response type. Simply calling this RPC and receiving a response denotes that the dataplane is
	// up and running an ready to service RPCs. This API comes in useful in scripts which want to
	// poll until the dataplane is ready (for example in the DPLL systemd scripts) and in contexts
	// where we want to explicitly check the network connection to the DP (for example in Symmetra).
	// Note: there's some overlap in functionality with the dataplane Event server, which sends
	// EventDataplaneStartupFinished and EventDataplaneShutdownComplete messages on startup and
	// shutdown respectively. The CP should favour using the event server API to ascertain when the
	// dataplane is started and ready to receive RPC requests.
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	// ----------------- CONFIGURATIONS RPCS -------------------------------
	// Creates deployment. Either a master or a replica. The CP should signals
	// which by setting the `deployment_type` field within the DeploymentConfig
	// message type. Like all "Configure*" RPCs this method has "create if not
	// present, else update" semantics, i.e.:
	//
	//  - if no configuration exists for "uuid" we create the deployment
	//  - if configuration exists for "uuid" then we overwrite the current config.
	//
	// Creates will be rejected if: the CP tries to configure a replica deployment
	// which has replicas; the consumer count is zero.
	//
	// Overwites will be rejected if: the consumer count is decremented or the
	// compression flag has changed. Once specified compression can not be modified.
	//
	// Under the hood this method creates the blob files into which we'll store
	// user data and sets up the network connection to any replicas (master
	// deployments only).
	//
	// Note: this RPC does not configure the replicas it merely tells the
	// master about the existance and location of its replicas. To configure
	// the replicas call ConfigureReplica on the appropriate replica nodes,
	// prior to this call.
	//
	// On success rpc_result.success will be set to true. On failure it will
	// be set to false and rpc_result.code will be set to STATUS_*.
	// rpc_result.reason may be set.
	ConfigureDeployment(context.Context, *ConfigureDeploymentRequest) (*ConfigureDeploymentResponse, error)
	// Deconfigure the deployment. This lets the dataplane know that we are done
	// with the deployment and allows the dataplane to release runtime resources
	// associated with the deployment. The CP would typically call this API when
	// a the volume is no longer in use.
	//
	// This RPC does not delete the block (meta)data associated with the
	// deployment. Call DeleteDeployment for that.
	//
	// On success rpc_result.success will be set to true. On failure it will be
	// set to false and rpc_result.code will be set accordingly. The only specific
	// code returned is STATUS_NOT_FOUND - this is set when the deployment you
	// asked to deconfigure is not configured. For all other errors rpc_result.code
	// will be set to STATUS_*. In all failure case rpc_result.reason may be set.
	DeconfigureDeployment(context.Context, *DeconfigureDeploymentRequest) (*DeconfigureDeploymentResponse, error)
	// Irrevocably delete the deployment (meta)data.
	//
	// The deployment must be deconfigured, via DeconfigureDeployment, prior
	// to calling this method, or we'll reject the request with an error.
	//
	// On success rpc_result.success will be set to true. On failure it will be
	// set to false and rpc_result.code will be set accordingly. The only specific
	// code returned is STATUS_NOT_FOUND - this is set when the deployment you
	// asked to delete does no exist. For all other errors rpc_result.code will be
	// set to STATUS_*. In all failure case rpc_result.reason may be set.
	DeleteDeployment(context.Context, *DeleteDeploymentRequest) (*DeleteDeploymentResponse, error)
	// Configure a presentation. This creates a block device which can be used
	// to access the volume. This RPC works for both local and remote
	// presentations. Like all "Configure*" RPCs this method has "create if not
	// present, else update" semantics, i.e.:
	//
	//  - if no configuration exists for "presentation_uuid" then create the
	//  presentation
	//  - if a presentation exists for "presentation_uuid" then apply any diffs
	//    against the existing config. Valid diffs include: increasing the
	//    volume size, changing the target deployment (useful during a fail
	//    over); and increasing the consumer count. It's not permitted to change
	//    the crypto config for obvious reasons.
	//
	// On success rpc_result.success will be set to true. On failure it will
	// be set to false and rpc_result.code will be set to STATUS_*.
	// rpc_result.reason may be set.
	ConfigurePresentation(context.Context, *ConfigurePresentationRequest) (*ConfigurePresentationResponse, error)
	// Delete a previous created presentation
	//
	// On success rpc_result.success will be set to true. On failure it will
	// be set to false and rpc_result.code will be set accordingly. The only
	// specific code returned is STATUS_NOT_FOUND - this is set when the
	// presentation you asked to delete doesn't even exist. For all other errors
	// rpc_result.code will be set to STATUS_*. In all failure case
	// rpc_result.reason may be set.
	DeconfigurePresentation(context.Context, *DeconfigurePresentationRequest) (*DeconfigurePresentationResponse, error)
	// Set the consumer count for a deployment. This should only ever be called
	// on the master deployment (we don't ever need to set the consumer count
	// on a replica). The CP only needs to call this API when it wants to
	// explicitly change the consumer count. The only time I believe this is
	// currently necessary is during a failover. Normally the consumer count value
	// is implicitly transmitted to the dataplane by calling ConfigureDeployment. The
	// ConfigureDeployment request contains the consumer count.
	//
	// On success rpc_result.success will be set to true. On failure it will
	// be set to false and rpc_result.code will be set accordingly. The only
	// specific code returned is STATUS_NOT_FOUND - this is set when the
	// master you asked to set the CC on doesn't even exist. For all other
	// errors rpc_result.code will be set to STATUS_*. In all failure case
	// rpc_result.reason may be set. If the consumer count which was requested
	// to be set is LOWER than the currently set value then this method will
	// set rpc_result.success to true. The actual value of the consumer count
	// - i.e. the current, higher value - will be returned in the response.
	SetConsumerCount(context.Context, *SetConsumerCountRequest) (*SetConsumerCountResponse, error)
	// Get the consumer count for a given deployment
	//
	// Returns STATUS_NOT_FOUND if the deployment does not exist.
	// Returns STATUS_* for any other errors
	GetConsumerCount(context.Context, *GetConsumerCountRequest) (*GetConsumerCountResponse, error)
	// Dump the dataplane's current configuration
	DumpConfig(context.Context, *DumpConfigRequest) (*DumpConfigResponse, error)
	// Config services, from common.v1.
	ConfigGetBool(context.Context, *v1.ConfigKey) (*v1.ConfigGetBoolReply, error)
	ConfigUpdateBool(context.Context, *v1.ConfigBool) (*v1.ConfigUpdateReply, error)
	ConfigListBool(context.Context, *v1.ConfigListQuery) (*v1.ConfigBoolList, error)
	ConfigGetString(context.Context, *v1.ConfigKey) (*v1.ConfigGetStringReply, error)
	ConfigUpdateString(context.Context, *v1.ConfigString) (*v1.ConfigUpdateReply, error)
	ConfigListString(context.Context, *v1.ConfigListQuery) (*v1.ConfigStringList, error)
	ConfigGetUint32(context.Context, *v1.ConfigKey) (*v1.ConfigGetUint32Reply, error)
	ConfigUpdateUint32(context.Context, *v1.ConfigUint32) (*v1.ConfigUpdateReply, error)
	ConfigListUint32(context.Context, *v1.ConfigListQuery) (*v1.ConfigUint32List, error)
	ConfigGetUint64(context.Context, *v1.ConfigKey) (*v1.ConfigGetUint64Reply, error)
	ConfigUpdateUint64(context.Context, *v1.ConfigUint64) (*v1.ConfigUpdateReply, error)
	ConfigListUint64(context.Context, *v1.ConfigListQuery) (*v1.ConfigUint64List, error)
	// ----------------- DP INTERNAL RPCS -------------------------------
	// List all of the network connections which this node has with other dataplanes.
	// Established and un-established connections are shown. Users can drill down into
	// the individual connection to see its status.
	ListConnections(context.Context, *ListConnectionsRequest) (*ListConnectionsResponse, error)
	// Add new connections (for debugging purposes)
	AddConnection(context.Context, *AddConnectionRequest) (*AddConnectionResponse, error)
	// Remove new connections (for debugging purposes)
	RemoveConnection(context.Context, *RemoveConnectionRequest) (*RemoveConnectionResponse, error)
	// Sync the specified regions from the source deployment to the destination
	// deployment. Called by Symmetra.
	SyncRegions(context.Context, *SyncRegionsRequest) (*SyncRegionsResponse, error)
	// Return a hash list for the specified deployment, over the specified range.
	// Note: this is a streaming RPC as the hash lists returned could
	// conceiveably be multiple megabytes in size.
	//
	// returns the hash list and deployment hash
	DeploymentHashList(*DeploymentHashListRequest, Supervisor_DeploymentHashListServer) error
	// Collect the dataplane node-level metrics and specific per-volume metrics.
	// NOTE: This is an experimental dataplane-only API. It's probably not quite
	// what the control-plane requires in terms of a metrics API, but it's fine
	// for dataplane tooling and tests.
	Metrics(context.Context, *MetricsRequest) (*MetricsResponse, error)
}

// UnimplementedSupervisorServer should be embedded to have forward compatible implementations.
type UnimplementedSupervisorServer struct {
}

func (UnimplementedSupervisorServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedSupervisorServer) ConfigureDeployment(context.Context, *ConfigureDeploymentRequest) (*ConfigureDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureDeployment not implemented")
}
func (UnimplementedSupervisorServer) DeconfigureDeployment(context.Context, *DeconfigureDeploymentRequest) (*DeconfigureDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeconfigureDeployment not implemented")
}
func (UnimplementedSupervisorServer) DeleteDeployment(context.Context, *DeleteDeploymentRequest) (*DeleteDeploymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDeployment not implemented")
}
func (UnimplementedSupervisorServer) ConfigurePresentation(context.Context, *ConfigurePresentationRequest) (*ConfigurePresentationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigurePresentation not implemented")
}
func (UnimplementedSupervisorServer) DeconfigurePresentation(context.Context, *DeconfigurePresentationRequest) (*DeconfigurePresentationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeconfigurePresentation not implemented")
}
func (UnimplementedSupervisorServer) SetConsumerCount(context.Context, *SetConsumerCountRequest) (*SetConsumerCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConsumerCount not implemented")
}
func (UnimplementedSupervisorServer) GetConsumerCount(context.Context, *GetConsumerCountRequest) (*GetConsumerCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsumerCount not implemented")
}
func (UnimplementedSupervisorServer) DumpConfig(context.Context, *DumpConfigRequest) (*DumpConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DumpConfig not implemented")
}
func (UnimplementedSupervisorServer) ConfigGetBool(context.Context, *v1.ConfigKey) (*v1.ConfigGetBoolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetBool not implemented")
}
func (UnimplementedSupervisorServer) ConfigUpdateBool(context.Context, *v1.ConfigBool) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateBool not implemented")
}
func (UnimplementedSupervisorServer) ConfigListBool(context.Context, *v1.ConfigListQuery) (*v1.ConfigBoolList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListBool not implemented")
}
func (UnimplementedSupervisorServer) ConfigGetString(context.Context, *v1.ConfigKey) (*v1.ConfigGetStringReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetString not implemented")
}
func (UnimplementedSupervisorServer) ConfigUpdateString(context.Context, *v1.ConfigString) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateString not implemented")
}
func (UnimplementedSupervisorServer) ConfigListString(context.Context, *v1.ConfigListQuery) (*v1.ConfigStringList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListString not implemented")
}
func (UnimplementedSupervisorServer) ConfigGetUint32(context.Context, *v1.ConfigKey) (*v1.ConfigGetUint32Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetUint32 not implemented")
}
func (UnimplementedSupervisorServer) ConfigUpdateUint32(context.Context, *v1.ConfigUint32) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateUint32 not implemented")
}
func (UnimplementedSupervisorServer) ConfigListUint32(context.Context, *v1.ConfigListQuery) (*v1.ConfigUint32List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListUint32 not implemented")
}
func (UnimplementedSupervisorServer) ConfigGetUint64(context.Context, *v1.ConfigKey) (*v1.ConfigGetUint64Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetUint64 not implemented")
}
func (UnimplementedSupervisorServer) ConfigUpdateUint64(context.Context, *v1.ConfigUint64) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateUint64 not implemented")
}
func (UnimplementedSupervisorServer) ConfigListUint64(context.Context, *v1.ConfigListQuery) (*v1.ConfigUint64List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListUint64 not implemented")
}
func (UnimplementedSupervisorServer) ListConnections(context.Context, *ListConnectionsRequest) (*ListConnectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConnections not implemented")
}
func (UnimplementedSupervisorServer) AddConnection(context.Context, *AddConnectionRequest) (*AddConnectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddConnection not implemented")
}
func (UnimplementedSupervisorServer) RemoveConnection(context.Context, *RemoveConnectionRequest) (*RemoveConnectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveConnection not implemented")
}
func (UnimplementedSupervisorServer) SyncRegions(context.Context, *SyncRegionsRequest) (*SyncRegionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncRegions not implemented")
}
func (UnimplementedSupervisorServer) DeploymentHashList(*DeploymentHashListRequest, Supervisor_DeploymentHashListServer) error {
	return status.Errorf(codes.Unimplemented, "method DeploymentHashList not implemented")
}
func (UnimplementedSupervisorServer) Metrics(context.Context, *MetricsRequest) (*MetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metrics not implemented")
}

// UnsafeSupervisorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SupervisorServer will
// result in compilation errors.
type UnsafeSupervisorServer interface {
	mustEmbedUnimplementedSupervisorServer()
}

func RegisterSupervisorServer(s grpc.ServiceRegistrar, srv SupervisorServer) {
	s.RegisterService(&Supervisor_ServiceDesc, srv)
}

func _Supervisor_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigureDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigureDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigureDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigureDeployment(ctx, req.(*ConfigureDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_DeconfigureDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeconfigureDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).DeconfigureDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/DeconfigureDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).DeconfigureDeployment(ctx, req.(*DeconfigureDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_DeleteDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).DeleteDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/DeleteDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).DeleteDeployment(ctx, req.(*DeleteDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigurePresentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigurePresentationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigurePresentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigurePresentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigurePresentation(ctx, req.(*ConfigurePresentationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_DeconfigurePresentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeconfigurePresentationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).DeconfigurePresentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/DeconfigurePresentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).DeconfigurePresentation(ctx, req.(*DeconfigurePresentationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_SetConsumerCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConsumerCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).SetConsumerCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/SetConsumerCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).SetConsumerCount(ctx, req.(*SetConsumerCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_GetConsumerCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsumerCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).GetConsumerCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/GetConsumerCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).GetConsumerCount(ctx, req.(*GetConsumerCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_DumpConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DumpConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).DumpConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/DumpConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).DumpConfig(ctx, req.(*DumpConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigGetBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigGetBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigGetBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigGetBool(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigUpdateBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigBool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigUpdateBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigUpdateBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigUpdateBool(ctx, req.(*v1.ConfigBool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigListBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigListBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigListBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigListBool(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigGetString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigGetString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigGetString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigGetString(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigUpdateString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigUpdateString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigUpdateString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigUpdateString(ctx, req.(*v1.ConfigString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigListString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigListString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigListString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigListString(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigGetUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigGetUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigGetUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigGetUint32(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigUpdateUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigUint32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigUpdateUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigUpdateUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigUpdateUint32(ctx, req.(*v1.ConfigUint32))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigListUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigListUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigListUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigListUint32(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigGetUint64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigGetUint64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigGetUint64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigGetUint64(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigUpdateUint64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigUint64)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigUpdateUint64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigUpdateUint64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigUpdateUint64(ctx, req.(*v1.ConfigUint64))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigListUint64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigListUint64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ConfigListUint64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigListUint64(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ListConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConnectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ListConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/ListConnections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ListConnections(ctx, req.(*ListConnectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_AddConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).AddConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/AddConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).AddConnection(ctx, req.(*AddConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_RemoveConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).RemoveConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/RemoveConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).RemoveConnection(ctx, req.(*RemoveConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_SyncRegions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).SyncRegions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/SyncRegions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).SyncRegions(ctx, req.(*SyncRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_DeploymentHashList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeploymentHashListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SupervisorServer).DeploymentHashList(m, &supervisorDeploymentHashListServer{stream})
}

type Supervisor_DeploymentHashListServer interface {
	Send(*DeploymentHashListResponse) error
	grpc.ServerStream
}

type supervisorDeploymentHashListServer struct {
	grpc.ServerStream
}

func (x *supervisorDeploymentHashListServer) Send(m *DeploymentHashListResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Supervisor_Metrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).Metrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.supervisor.v1.Supervisor/Metrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).Metrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Supervisor_ServiceDesc is the grpc.ServiceDesc for Supervisor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Supervisor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.supervisor.v1.Supervisor",
	HandlerType: (*SupervisorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _Supervisor_Status_Handler,
		},
		{
			MethodName: "ConfigureDeployment",
			Handler:    _Supervisor_ConfigureDeployment_Handler,
		},
		{
			MethodName: "DeconfigureDeployment",
			Handler:    _Supervisor_DeconfigureDeployment_Handler,
		},
		{
			MethodName: "DeleteDeployment",
			Handler:    _Supervisor_DeleteDeployment_Handler,
		},
		{
			MethodName: "ConfigurePresentation",
			Handler:    _Supervisor_ConfigurePresentation_Handler,
		},
		{
			MethodName: "DeconfigurePresentation",
			Handler:    _Supervisor_DeconfigurePresentation_Handler,
		},
		{
			MethodName: "SetConsumerCount",
			Handler:    _Supervisor_SetConsumerCount_Handler,
		},
		{
			MethodName: "GetConsumerCount",
			Handler:    _Supervisor_GetConsumerCount_Handler,
		},
		{
			MethodName: "DumpConfig",
			Handler:    _Supervisor_DumpConfig_Handler,
		},
		{
			MethodName: "ConfigGetBool",
			Handler:    _Supervisor_ConfigGetBool_Handler,
		},
		{
			MethodName: "ConfigUpdateBool",
			Handler:    _Supervisor_ConfigUpdateBool_Handler,
		},
		{
			MethodName: "ConfigListBool",
			Handler:    _Supervisor_ConfigListBool_Handler,
		},
		{
			MethodName: "ConfigGetString",
			Handler:    _Supervisor_ConfigGetString_Handler,
		},
		{
			MethodName: "ConfigUpdateString",
			Handler:    _Supervisor_ConfigUpdateString_Handler,
		},
		{
			MethodName: "ConfigListString",
			Handler:    _Supervisor_ConfigListString_Handler,
		},
		{
			MethodName: "ConfigGetUint32",
			Handler:    _Supervisor_ConfigGetUint32_Handler,
		},
		{
			MethodName: "ConfigUpdateUint32",
			Handler:    _Supervisor_ConfigUpdateUint32_Handler,
		},
		{
			MethodName: "ConfigListUint32",
			Handler:    _Supervisor_ConfigListUint32_Handler,
		},
		{
			MethodName: "ConfigGetUint64",
			Handler:    _Supervisor_ConfigGetUint64_Handler,
		},
		{
			MethodName: "ConfigUpdateUint64",
			Handler:    _Supervisor_ConfigUpdateUint64_Handler,
		},
		{
			MethodName: "ConfigListUint64",
			Handler:    _Supervisor_ConfigListUint64_Handler,
		},
		{
			MethodName: "ListConnections",
			Handler:    _Supervisor_ListConnections_Handler,
		},
		{
			MethodName: "AddConnection",
			Handler:    _Supervisor_AddConnection_Handler,
		},
		{
			MethodName: "RemoveConnection",
			Handler:    _Supervisor_RemoveConnection_Handler,
		},
		{
			MethodName: "SyncRegions",
			Handler:    _Supervisor_SyncRegions_Handler,
		},
		{
			MethodName: "Metrics",
			Handler:    _Supervisor_Metrics_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DeploymentHashList",
			Handler:       _Supervisor_DeploymentHashList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "supervisor/v1/supervisor.proto",
}
