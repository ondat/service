// Code generated by protoc-gen-go. DO NOT EDIT.
// source: supervisor.proto

package v1

import (
	v1 "code.storageos.net/storageos/service/common/v1"
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type VolumeHashListRpcVersion int32

const (
	VolumeHashListRpcVersion_V1 VolumeHashListRpcVersion = 0
	VolumeHashListRpcVersion_V2 VolumeHashListRpcVersion = 1
)

var VolumeHashListRpcVersion_name = map[int32]string{
	0: "V1",
	1: "V2",
}

var VolumeHashListRpcVersion_value = map[string]int32{
	"V1": 0,
	"V2": 1,
}

func (x VolumeHashListRpcVersion) String() string {
	return proto.EnumName(VolumeHashListRpcVersion_name, int32(x))
}

func (VolumeHashListRpcVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{0}
}

//
// Metrics
type MetricType int32

const (
	// Counters may only increase (like an odometer)
	MetricType_COUNT MetricType = 0
	// Gauges may fluctuate (like a speedometer)
	MetricType_GAUGE MetricType = 1
)

var MetricType_name = map[int32]string{
	0: "COUNT",
	1: "GAUGE",
}

var MetricType_value = map[string]int32{
	"COUNT": 0,
	"GAUGE": 1,
}

func (x MetricType) String() string {
	return proto.EnumName(MetricType_name, int32(x))
}

func (MetricType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{1}
}

type IdMapperStatus_MapMode int32

const (
	IdMapperStatus_NOTSET IdMapperStatus_MapMode = 0
	IdMapperStatus_GSI    IdMapperStatus_MapMode = 1
	IdMapperStatus_NLI    IdMapperStatus_MapMode = 2
)

var IdMapperStatus_MapMode_name = map[int32]string{
	0: "NOTSET",
	1: "GSI",
	2: "NLI",
}

var IdMapperStatus_MapMode_value = map[string]int32{
	"NOTSET": 0,
	"GSI":    1,
	"NLI":    2,
}

func (x IdMapperStatus_MapMode) String() string {
	return proto.EnumName(IdMapperStatus_MapMode_name, int32(x))
}

func (IdMapperStatus_MapMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{7, 0}
}

type ReapVolumeRequest struct {
	Uuid                 string   `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Inode                uint32   `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReapVolumeRequest) Reset()         { *m = ReapVolumeRequest{} }
func (m *ReapVolumeRequest) String() string { return proto.CompactTextString(m) }
func (*ReapVolumeRequest) ProtoMessage()    {}
func (*ReapVolumeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{0}
}

func (m *ReapVolumeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReapVolumeRequest.Unmarshal(m, b)
}
func (m *ReapVolumeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReapVolumeRequest.Marshal(b, m, deterministic)
}
func (m *ReapVolumeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReapVolumeRequest.Merge(m, src)
}
func (m *ReapVolumeRequest) XXX_Size() int {
	return xxx_messageInfo_ReapVolumeRequest.Size(m)
}
func (m *ReapVolumeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReapVolumeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReapVolumeRequest proto.InternalMessageInfo

func (m *ReapVolumeRequest) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ReapVolumeRequest) GetInode() uint32 {
	if m != nil {
		return m.Inode
	}
	return 0
}

type ReapVolumeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReapVolumeResponse) Reset()         { *m = ReapVolumeResponse{} }
func (m *ReapVolumeResponse) String() string { return proto.CompactTextString(m) }
func (*ReapVolumeResponse) ProtoMessage()    {}
func (*ReapVolumeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{1}
}

func (m *ReapVolumeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReapVolumeResponse.Unmarshal(m, b)
}
func (m *ReapVolumeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReapVolumeResponse.Marshal(b, m, deterministic)
}
func (m *ReapVolumeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReapVolumeResponse.Merge(m, src)
}
func (m *ReapVolumeResponse) XXX_Size() int {
	return xxx_messageInfo_ReapVolumeResponse.Size(m)
}
func (m *ReapVolumeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReapVolumeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReapVolumeResponse proto.InternalMessageInfo

type DeleteMappingRequest struct {
	Uuid                 string   `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteMappingRequest) Reset()         { *m = DeleteMappingRequest{} }
func (m *DeleteMappingRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteMappingRequest) ProtoMessage()    {}
func (*DeleteMappingRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{2}
}

func (m *DeleteMappingRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteMappingRequest.Unmarshal(m, b)
}
func (m *DeleteMappingRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteMappingRequest.Marshal(b, m, deterministic)
}
func (m *DeleteMappingRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMappingRequest.Merge(m, src)
}
func (m *DeleteMappingRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteMappingRequest.Size(m)
}
func (m *DeleteMappingRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMappingRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMappingRequest proto.InternalMessageInfo

func (m *DeleteMappingRequest) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

type DeleteMappingResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteMappingResponse) Reset()         { *m = DeleteMappingResponse{} }
func (m *DeleteMappingResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteMappingResponse) ProtoMessage()    {}
func (*DeleteMappingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{3}
}

func (m *DeleteMappingResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteMappingResponse.Unmarshal(m, b)
}
func (m *DeleteMappingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteMappingResponse.Marshal(b, m, deterministic)
}
func (m *DeleteMappingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMappingResponse.Merge(m, src)
}
func (m *DeleteMappingResponse) XXX_Size() int {
	return xxx_messageInfo_DeleteMappingResponse.Size(m)
}
func (m *DeleteMappingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMappingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMappingResponse proto.InternalMessageInfo

type SupervisorStatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SupervisorStatusRequest) Reset()         { *m = SupervisorStatusRequest{} }
func (m *SupervisorStatusRequest) String() string { return proto.CompactTextString(m) }
func (*SupervisorStatusRequest) ProtoMessage()    {}
func (*SupervisorStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{4}
}

func (m *SupervisorStatusRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SupervisorStatusRequest.Unmarshal(m, b)
}
func (m *SupervisorStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SupervisorStatusRequest.Marshal(b, m, deterministic)
}
func (m *SupervisorStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupervisorStatusRequest.Merge(m, src)
}
func (m *SupervisorStatusRequest) XXX_Size() int {
	return xxx_messageInfo_SupervisorStatusRequest.Size(m)
}
func (m *SupervisorStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SupervisorStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SupervisorStatusRequest proto.InternalMessageInfo

type SupervisorStatus struct {
	// Generic daemon status.
	Status *v1.DaemonStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Composite Id Mapper status.
	IdmapStatus *IdMapperStatus `protobuf:"bytes,3,opt,name=idmap_status,json=idmapStatus,proto3" json:"idmap_status,omitempty"`
	// Composite consumer count status.
	CcStatus             *ConsumerCountStatus `protobuf:"bytes,4,opt,name=cc_status,json=ccStatus,proto3" json:"cc_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SupervisorStatus) Reset()         { *m = SupervisorStatus{} }
func (m *SupervisorStatus) String() string { return proto.CompactTextString(m) }
func (*SupervisorStatus) ProtoMessage()    {}
func (*SupervisorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{5}
}

func (m *SupervisorStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SupervisorStatus.Unmarshal(m, b)
}
func (m *SupervisorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SupervisorStatus.Marshal(b, m, deterministic)
}
func (m *SupervisorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupervisorStatus.Merge(m, src)
}
func (m *SupervisorStatus) XXX_Size() int {
	return xxx_messageInfo_SupervisorStatus.Size(m)
}
func (m *SupervisorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SupervisorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SupervisorStatus proto.InternalMessageInfo

func (m *SupervisorStatus) GetStatus() *v1.DaemonStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *SupervisorStatus) GetIdmapStatus() *IdMapperStatus {
	if m != nil {
		return m.IdmapStatus
	}
	return nil
}

func (m *SupervisorStatus) GetCcStatus() *ConsumerCountStatus {
	if m != nil {
		return m.CcStatus
	}
	return nil
}

type IdMapping struct {
	Uuid                 string   `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Inode                uint32   `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IdMapping) Reset()         { *m = IdMapping{} }
func (m *IdMapping) String() string { return proto.CompactTextString(m) }
func (*IdMapping) ProtoMessage()    {}
func (*IdMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{6}
}

func (m *IdMapping) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IdMapping.Unmarshal(m, b)
}
func (m *IdMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IdMapping.Marshal(b, m, deterministic)
}
func (m *IdMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdMapping.Merge(m, src)
}
func (m *IdMapping) XXX_Size() int {
	return xxx_messageInfo_IdMapping.Size(m)
}
func (m *IdMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_IdMapping.DiscardUnknown(m)
}

var xxx_messageInfo_IdMapping proto.InternalMessageInfo

func (m *IdMapping) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *IdMapping) GetInode() uint32 {
	if m != nil {
		return m.Inode
	}
	return 0
}

type IdMapperStatus struct {
	// The map mode, only valid if mode_set==true.
	Mode IdMapperStatus_MapMode `protobuf:"varint,2,opt,name=mode,proto3,enum=supervisor.v1.IdMapperStatus_MapMode" json:"mode,omitempty"`
	// A list of mappings.
	Mappings             []*IdMapping `protobuf:"bytes,3,rep,name=mappings,proto3" json:"mappings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *IdMapperStatus) Reset()         { *m = IdMapperStatus{} }
func (m *IdMapperStatus) String() string { return proto.CompactTextString(m) }
func (*IdMapperStatus) ProtoMessage()    {}
func (*IdMapperStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{7}
}

func (m *IdMapperStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IdMapperStatus.Unmarshal(m, b)
}
func (m *IdMapperStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IdMapperStatus.Marshal(b, m, deterministic)
}
func (m *IdMapperStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdMapperStatus.Merge(m, src)
}
func (m *IdMapperStatus) XXX_Size() int {
	return xxx_messageInfo_IdMapperStatus.Size(m)
}
func (m *IdMapperStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_IdMapperStatus.DiscardUnknown(m)
}

var xxx_messageInfo_IdMapperStatus proto.InternalMessageInfo

func (m *IdMapperStatus) GetMode() IdMapperStatus_MapMode {
	if m != nil {
		return m.Mode
	}
	return IdMapperStatus_NOTSET
}

func (m *IdMapperStatus) GetMappings() []*IdMapping {
	if m != nil {
		return m.Mappings
	}
	return nil
}

type ConsumerCountStatus struct {
	// Just a list of counts and mappings.
	Ccs                  []*ConsumerCountEntry `protobuf:"bytes,1,rep,name=ccs,proto3" json:"ccs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ConsumerCountStatus) Reset()         { *m = ConsumerCountStatus{} }
func (m *ConsumerCountStatus) String() string { return proto.CompactTextString(m) }
func (*ConsumerCountStatus) ProtoMessage()    {}
func (*ConsumerCountStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{8}
}

func (m *ConsumerCountStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConsumerCountStatus.Unmarshal(m, b)
}
func (m *ConsumerCountStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConsumerCountStatus.Marshal(b, m, deterministic)
}
func (m *ConsumerCountStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerCountStatus.Merge(m, src)
}
func (m *ConsumerCountStatus) XXX_Size() int {
	return xxx_messageInfo_ConsumerCountStatus.Size(m)
}
func (m *ConsumerCountStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerCountStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerCountStatus proto.InternalMessageInfo

func (m *ConsumerCountStatus) GetCcs() []*ConsumerCountEntry {
	if m != nil {
		return m.Ccs
	}
	return nil
}

type ConsumerCountEntry struct {
	// The mapping for which we're returning a CC.
	Mapping *IdMapping `protobuf:"bytes,1,opt,name=mapping,proto3" json:"mapping,omitempty"`
	// The cc for the provided mapping.
	Cc                   *v1.ConsumerCount `protobuf:"bytes,2,opt,name=cc,proto3" json:"cc,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ConsumerCountEntry) Reset()         { *m = ConsumerCountEntry{} }
func (m *ConsumerCountEntry) String() string { return proto.CompactTextString(m) }
func (*ConsumerCountEntry) ProtoMessage()    {}
func (*ConsumerCountEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{9}
}

func (m *ConsumerCountEntry) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConsumerCountEntry.Unmarshal(m, b)
}
func (m *ConsumerCountEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConsumerCountEntry.Marshal(b, m, deterministic)
}
func (m *ConsumerCountEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumerCountEntry.Merge(m, src)
}
func (m *ConsumerCountEntry) XXX_Size() int {
	return xxx_messageInfo_ConsumerCountEntry.Size(m)
}
func (m *ConsumerCountEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumerCountEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumerCountEntry proto.InternalMessageInfo

func (m *ConsumerCountEntry) GetMapping() *IdMapping {
	if m != nil {
		return m.Mapping
	}
	return nil
}

func (m *ConsumerCountEntry) GetCc() *v1.ConsumerCount {
	if m != nil {
		return m.Cc
	}
	return nil
}

// Syncing a volume is a multi stage process:
//
// * first the CP invokes symmetra (a standalone binary), which then
// * calls the VolumeHashList() RPC for the master and replica deployments
// * symmetra then calls the Sync() RPC multiple times on the master to copy the data
//
// We want to be able to track this transaction across it's entire duration.
// The SyncContext message type allows us to do this. When symmetra is first
// invoked it generates the SyncContext. This token is then passed in all subsequent
// VolumeHashListRequests and SyncRegionRequests. Any code taking part in
// the sync operation can then log this ID as part of any structued logging calls.
//
// UUIDs seem to be in fashion at the moment so we'll use that as the unique identifier.
type SyncContext struct {
	Uuid                 string   `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncContext) Reset()         { *m = SyncContext{} }
func (m *SyncContext) String() string { return proto.CompactTextString(m) }
func (*SyncContext) ProtoMessage()    {}
func (*SyncContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{10}
}

func (m *SyncContext) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SyncContext.Unmarshal(m, b)
}
func (m *SyncContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SyncContext.Marshal(b, m, deterministic)
}
func (m *SyncContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncContext.Merge(m, src)
}
func (m *SyncContext) XXX_Size() int {
	return xxx_messageInfo_SyncContext.Size(m)
}
func (m *SyncContext) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncContext.DiscardUnknown(m)
}

var xxx_messageInfo_SyncContext proto.InternalMessageInfo

func (m *SyncContext) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

type VolumeHash struct {
	// There's no way to define this in the proto but bytes.size() is always
	// sizeof(HashType_t). Currently 16 bytes.
	Bytes                []byte   `protobuf:"bytes,1,opt,name=bytes,proto3" json:"bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VolumeHash) Reset()         { *m = VolumeHash{} }
func (m *VolumeHash) String() string { return proto.CompactTextString(m) }
func (*VolumeHash) ProtoMessage()    {}
func (*VolumeHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{11}
}

func (m *VolumeHash) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeHash.Unmarshal(m, b)
}
func (m *VolumeHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeHash.Marshal(b, m, deterministic)
}
func (m *VolumeHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeHash.Merge(m, src)
}
func (m *VolumeHash) XXX_Size() int {
	return xxx_messageInfo_VolumeHash.Size(m)
}
func (m *VolumeHash) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeHash.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeHash proto.InternalMessageInfo

func (m *VolumeHash) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

// Note: the response to this message, VolumeHashListResponse, is chunked
// (streamed in gRPC parlance).
type VolumeHashListRequest struct {
	// See the VolumeHashListRpcVersion documentation
	Version VolumeHashListRpcVersion `protobuf:"varint,7,opt,name=version,proto3,enum=supervisor.v1.VolumeHashListRpcVersion" json:"version,omitempty"`
	// The volume we want to generate a hash over
	VolumeId uint32 `protobuf:"varint,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The volume UUID we want to generate a hash over.
	VolumeUuid string `protobuf:"bytes,5,opt,name=volume_uuid,json=volumeUuid,proto3" json:"volume_uuid,omitempty"`
	// Defines the byte offset into `volume_id` at which we'll start hash list
	// generation.
	StartOffset uint64 `protobuf:"varint,2,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	// Defines the byte offset into `volume_id` at which we'll end hash list
	// generation.
	EndOffset uint64 `protobuf:"varint,3,opt,name=end_offset,json=endOffset,proto3" json:"end_offset,omitempty"`
	// When generating the hash list we do so by rolling together individual block
	// hashes into a region hash. This field defines the size of that region in
	// bytes. It must be multiple of RIXIO_BSIZE. By giving the option for clients
	// to specify this size they can optimise based on volume size and required
	// sync granularity.
	RegionSize uint64 `protobuf:"varint,4,opt,name=region_size,json=regionSize,proto3" json:"region_size,omitempty"`
	// As it stands we need to know if the volume is compressed or not in order to
	// generate the volume hashes. This field will likely become redundant once
	// DP-40 is fixed.
	IsCompressed bool `protobuf:"varint,6,opt,name=is_compressed,json=isCompressed,proto3" json:"is_compressed,omitempty"`
	// The SyncContext, initially generated by symmetra, associated with the over-arching sync operation
	// This field is purely used for logging, so there's no harm in not setting it in test code
	SyncContext          *SyncContext `protobuf:"bytes,8,opt,name=sync_context,json=syncContext,proto3" json:"sync_context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *VolumeHashListRequest) Reset()         { *m = VolumeHashListRequest{} }
func (m *VolumeHashListRequest) String() string { return proto.CompactTextString(m) }
func (*VolumeHashListRequest) ProtoMessage()    {}
func (*VolumeHashListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{12}
}

func (m *VolumeHashListRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeHashListRequest.Unmarshal(m, b)
}
func (m *VolumeHashListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeHashListRequest.Marshal(b, m, deterministic)
}
func (m *VolumeHashListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeHashListRequest.Merge(m, src)
}
func (m *VolumeHashListRequest) XXX_Size() int {
	return xxx_messageInfo_VolumeHashListRequest.Size(m)
}
func (m *VolumeHashListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeHashListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeHashListRequest proto.InternalMessageInfo

func (m *VolumeHashListRequest) GetVersion() VolumeHashListRpcVersion {
	if m != nil {
		return m.Version
	}
	return VolumeHashListRpcVersion_V1
}

func (m *VolumeHashListRequest) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *VolumeHashListRequest) GetVolumeUuid() string {
	if m != nil {
		return m.VolumeUuid
	}
	return ""
}

func (m *VolumeHashListRequest) GetStartOffset() uint64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

func (m *VolumeHashListRequest) GetEndOffset() uint64 {
	if m != nil {
		return m.EndOffset
	}
	return 0
}

func (m *VolumeHashListRequest) GetRegionSize() uint64 {
	if m != nil {
		return m.RegionSize
	}
	return 0
}

func (m *VolumeHashListRequest) GetIsCompressed() bool {
	if m != nil {
		return m.IsCompressed
	}
	return false
}

func (m *VolumeHashListRequest) GetSyncContext() *SyncContext {
	if m != nil {
		return m.SyncContext
	}
	return nil
}

type VolumeHashList struct {
	// The pool this volume hash pertains to
	PoolId uint32 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// The hash over the region [start_offset, end_offset) as specified in the
	// initial VolumeHashListRequest
	VolumeHash *VolumeHash `protobuf:"bytes,2,opt,name=volume_hash,json=volumeHash,proto3" json:"volume_hash,omitempty"`
	// Defines the byte offset into `volume_id` at which hash_list[0] begins.
	StartOffset uint64 `protobuf:"varint,3,opt,name=start_offset,json=startOffset,proto3" json:"start_offset,omitempty"`
	// Defines the byte offset into `volume_id` at which hash_list[max] ends.
	EndOffset uint64 `protobuf:"varint,4,opt,name=end_offset,json=endOffset,proto3" json:"end_offset,omitempty"`
	// A list of region hashes pertaining to the regions defined by the byte range
	// [start_offset, end_offset). The number of regions depends on the
	// `region_size` defined in the inital VolumeHashListRequest.
	HashList             []*VolumeHash `protobuf:"bytes,5,rep,name=hash_list,json=hashList,proto3" json:"hash_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *VolumeHashList) Reset()         { *m = VolumeHashList{} }
func (m *VolumeHashList) String() string { return proto.CompactTextString(m) }
func (*VolumeHashList) ProtoMessage()    {}
func (*VolumeHashList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{13}
}

func (m *VolumeHashList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeHashList.Unmarshal(m, b)
}
func (m *VolumeHashList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeHashList.Marshal(b, m, deterministic)
}
func (m *VolumeHashList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeHashList.Merge(m, src)
}
func (m *VolumeHashList) XXX_Size() int {
	return xxx_messageInfo_VolumeHashList.Size(m)
}
func (m *VolumeHashList) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeHashList.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeHashList proto.InternalMessageInfo

func (m *VolumeHashList) GetPoolId() uint32 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *VolumeHashList) GetVolumeHash() *VolumeHash {
	if m != nil {
		return m.VolumeHash
	}
	return nil
}

func (m *VolumeHashList) GetStartOffset() uint64 {
	if m != nil {
		return m.StartOffset
	}
	return 0
}

func (m *VolumeHashList) GetEndOffset() uint64 {
	if m != nil {
		return m.EndOffset
	}
	return 0
}

func (m *VolumeHashList) GetHashList() []*VolumeHash {
	if m != nil {
		return m.HashList
	}
	return nil
}

// This message is streamed back to the client in response to a
// VolumeHashListRequest message. As such the client should expect to receive
// many of these messages. Each VolumeHashListResponse contains a hash list
// per pool for a sequential portion of the volume. For simplicity the volume_hash
// -- i.e the hash for the range [start_offset, end_offset) -- is stored in every
// VolumeHashList message.
type VolumeHashListResponse struct {
	Version              VolumeHashListRpcVersion `protobuf:"varint,1,opt,name=version,proto3,enum=supervisor.v1.VolumeHashListRpcVersion" json:"version,omitempty"`
	PoolHashLists        []*VolumeHashList        `protobuf:"bytes,2,rep,name=pool_hash_lists,json=poolHashLists,proto3" json:"pool_hash_lists,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *VolumeHashListResponse) Reset()         { *m = VolumeHashListResponse{} }
func (m *VolumeHashListResponse) String() string { return proto.CompactTextString(m) }
func (*VolumeHashListResponse) ProtoMessage()    {}
func (*VolumeHashListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{14}
}

func (m *VolumeHashListResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeHashListResponse.Unmarshal(m, b)
}
func (m *VolumeHashListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeHashListResponse.Marshal(b, m, deterministic)
}
func (m *VolumeHashListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeHashListResponse.Merge(m, src)
}
func (m *VolumeHashListResponse) XXX_Size() int {
	return xxx_messageInfo_VolumeHashListResponse.Size(m)
}
func (m *VolumeHashListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeHashListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeHashListResponse proto.InternalMessageInfo

func (m *VolumeHashListResponse) GetVersion() VolumeHashListRpcVersion {
	if m != nil {
		return m.Version
	}
	return VolumeHashListRpcVersion_V1
}

func (m *VolumeHashListResponse) GetPoolHashLists() []*VolumeHashList {
	if m != nil {
		return m.PoolHashLists
	}
	return nil
}

type GetVolumeConsumerCountRequest struct {
	// The UUID whose consumer count we are requesting.
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The inode whos consumer count we are requesting.
	Inode                uint32   `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetVolumeConsumerCountRequest) Reset()         { *m = GetVolumeConsumerCountRequest{} }
func (m *GetVolumeConsumerCountRequest) String() string { return proto.CompactTextString(m) }
func (*GetVolumeConsumerCountRequest) ProtoMessage()    {}
func (*GetVolumeConsumerCountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{15}
}

func (m *GetVolumeConsumerCountRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVolumeConsumerCountRequest.Unmarshal(m, b)
}
func (m *GetVolumeConsumerCountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVolumeConsumerCountRequest.Marshal(b, m, deterministic)
}
func (m *GetVolumeConsumerCountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVolumeConsumerCountRequest.Merge(m, src)
}
func (m *GetVolumeConsumerCountRequest) XXX_Size() int {
	return xxx_messageInfo_GetVolumeConsumerCountRequest.Size(m)
}
func (m *GetVolumeConsumerCountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVolumeConsumerCountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetVolumeConsumerCountRequest proto.InternalMessageInfo

func (m *GetVolumeConsumerCountRequest) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *GetVolumeConsumerCountRequest) GetInode() uint32 {
	if m != nil {
		return m.Inode
	}
	return 0
}

type GetVolumeConsumerCountReply struct {
	// The UUID we're returning the cc for.
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The inode whos consumer count we are requesting.
	Inode uint32 `protobuf:"varint,3,opt,name=inode,proto3" json:"inode,omitempty"`
	// The Consumer Count for this uuid.
	Cc                   *v1.ConsumerCount `protobuf:"bytes,2,opt,name=cc,proto3" json:"cc,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetVolumeConsumerCountReply) Reset()         { *m = GetVolumeConsumerCountReply{} }
func (m *GetVolumeConsumerCountReply) String() string { return proto.CompactTextString(m) }
func (*GetVolumeConsumerCountReply) ProtoMessage()    {}
func (*GetVolumeConsumerCountReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{16}
}

func (m *GetVolumeConsumerCountReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetVolumeConsumerCountReply.Unmarshal(m, b)
}
func (m *GetVolumeConsumerCountReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetVolumeConsumerCountReply.Marshal(b, m, deterministic)
}
func (m *GetVolumeConsumerCountReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetVolumeConsumerCountReply.Merge(m, src)
}
func (m *GetVolumeConsumerCountReply) XXX_Size() int {
	return xxx_messageInfo_GetVolumeConsumerCountReply.Size(m)
}
func (m *GetVolumeConsumerCountReply) XXX_DiscardUnknown() {
	xxx_messageInfo_GetVolumeConsumerCountReply.DiscardUnknown(m)
}

var xxx_messageInfo_GetVolumeConsumerCountReply proto.InternalMessageInfo

func (m *GetVolumeConsumerCountReply) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *GetVolumeConsumerCountReply) GetInode() uint32 {
	if m != nil {
		return m.Inode
	}
	return 0
}

func (m *GetVolumeConsumerCountReply) GetCc() *v1.ConsumerCount {
	if m != nil {
		return m.Cc
	}
	return nil
}

type SetVolumeConsumerCountRequest struct {
	// The UUID whose consumer count is being set.
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The inode whos consumer count is being set.
	Inode uint32 `protobuf:"varint,3,opt,name=inode,proto3" json:"inode,omitempty"`
	// The Consumer Count being set.
	Cc                   *v1.ConsumerCount `protobuf:"bytes,2,opt,name=cc,proto3" json:"cc,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SetVolumeConsumerCountRequest) Reset()         { *m = SetVolumeConsumerCountRequest{} }
func (m *SetVolumeConsumerCountRequest) String() string { return proto.CompactTextString(m) }
func (*SetVolumeConsumerCountRequest) ProtoMessage()    {}
func (*SetVolumeConsumerCountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{17}
}

func (m *SetVolumeConsumerCountRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetVolumeConsumerCountRequest.Unmarshal(m, b)
}
func (m *SetVolumeConsumerCountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetVolumeConsumerCountRequest.Marshal(b, m, deterministic)
}
func (m *SetVolumeConsumerCountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVolumeConsumerCountRequest.Merge(m, src)
}
func (m *SetVolumeConsumerCountRequest) XXX_Size() int {
	return xxx_messageInfo_SetVolumeConsumerCountRequest.Size(m)
}
func (m *SetVolumeConsumerCountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVolumeConsumerCountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetVolumeConsumerCountRequest proto.InternalMessageInfo

func (m *SetVolumeConsumerCountRequest) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *SetVolumeConsumerCountRequest) GetInode() uint32 {
	if m != nil {
		return m.Inode
	}
	return 0
}

func (m *SetVolumeConsumerCountRequest) GetCc() *v1.ConsumerCount {
	if m != nil {
		return m.Cc
	}
	return nil
}

type SetVolumeConsumerCountReply struct {
	// The UUID whose consumer count was set.
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// The inode whos consumer count was set.
	Inode uint32 `protobuf:"varint,3,opt,name=inode,proto3" json:"inode,omitempty"`
	// The Consumer Count returned by the data plane on attempting to set the
	// value contained in the SetVolumeConsumerCountRequest. May be >=
	// request.cc.
	Cc                   *v1.ConsumerCount `protobuf:"bytes,2,opt,name=cc,proto3" json:"cc,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SetVolumeConsumerCountReply) Reset()         { *m = SetVolumeConsumerCountReply{} }
func (m *SetVolumeConsumerCountReply) String() string { return proto.CompactTextString(m) }
func (*SetVolumeConsumerCountReply) ProtoMessage()    {}
func (*SetVolumeConsumerCountReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{18}
}

func (m *SetVolumeConsumerCountReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetVolumeConsumerCountReply.Unmarshal(m, b)
}
func (m *SetVolumeConsumerCountReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetVolumeConsumerCountReply.Marshal(b, m, deterministic)
}
func (m *SetVolumeConsumerCountReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVolumeConsumerCountReply.Merge(m, src)
}
func (m *SetVolumeConsumerCountReply) XXX_Size() int {
	return xxx_messageInfo_SetVolumeConsumerCountReply.Size(m)
}
func (m *SetVolumeConsumerCountReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVolumeConsumerCountReply.DiscardUnknown(m)
}

var xxx_messageInfo_SetVolumeConsumerCountReply proto.InternalMessageInfo

func (m *SetVolumeConsumerCountReply) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *SetVolumeConsumerCountReply) GetInode() uint32 {
	if m != nil {
		return m.Inode
	}
	return 0
}

func (m *SetVolumeConsumerCountReply) GetCc() *v1.ConsumerCount {
	if m != nil {
		return m.Cc
	}
	return nil
}

type SyncRegionRequest struct {
	// The source volume ID.
	SourceVolume uint64 `protobuf:"varint,1,opt,name=source_volume,json=sourceVolume,proto3" json:"source_volume,omitempty"`
	// The source UUID.
	// This field is used as the volume identifier over destination_volume if
	// destination_volume is set to INVALID_INODE;
	SourceUuid string `protobuf:"bytes,2,opt,name=source_uuid,json=sourceUuid,proto3" json:"source_uuid,omitempty"`
	// The destination volume ID.
	DestinationVolume uint64 `protobuf:"varint,3,opt,name=destination_volume,json=destinationVolume,proto3" json:"destination_volume,omitempty"`
	// The destination UUID.
	// This field is used as the volume identifier over destination_volume if
	// destination_volume is set to INVALID_INODE;
	DestinationUuid string `protobuf:"bytes,4,opt,name=destination_uuid,json=destinationUuid,proto3" json:"destination_uuid,omitempty"`
	// The start offset.
	Offset uint64 `protobuf:"varint,5,opt,name=offset,proto3" json:"offset,omitempty"`
	// The length of region to sync.
	Length uint64 `protobuf:"varint,6,opt,name=length,proto3" json:"length,omitempty"`
	// Whether the sync should be forced. If this flag is set we'll overwrite
	// every sync block transaction ID with TransactionId{node_cc, 0}, where
	// node_cc is the consumer count of the source volume. See sync2020.pdf for
	// the rationale behind this.
	Force bool `protobuf:"varint,7,opt,name=force,proto3" json:"force,omitempty"`
	// The SyncContext, initially generated by symmetra, associated with the over-arching sync operation
	// This field is purely used for logging, so there's no harm in not setting it in test code
	SyncContext *SyncContext `protobuf:"bytes,8,opt,name=sync_context,json=syncContext,proto3" json:"sync_context,omitempty"`
	// If set we'll retry the write portion of a sync operation if it fails because
	// the directfs initiator has not established a connection to the target node
	// (the replica). We will do this for the first IO only. Remember internally every
	// SyncRegionRequest is broken down into multiple 128k IOs. Any subsequent write
	// failures due to a severed connection will abort the sync process. The amount of time
	// we'll wait before retrying will always be greater than the cool-off period between
	// connection re-establish attempts. This is currently configured to 5 seconds.
	//
	// Note: symmetra should set this flag for the first SyncRegionRequest only. The
	// desired behaviour is that only the very first IO can elicit a retry. We don't
	// want per IO retries for sync operations.
	AllowFirstIoRetry bool `protobuf:"varint,9,opt,name=allow_first_io_retry,json=allowFirstIoRetry,proto3" json:"allow_first_io_retry,omitempty"`
	// The pool to sync
	PoolId               uint32   `protobuf:"varint,10,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncRegionRequest) Reset()         { *m = SyncRegionRequest{} }
func (m *SyncRegionRequest) String() string { return proto.CompactTextString(m) }
func (*SyncRegionRequest) ProtoMessage()    {}
func (*SyncRegionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{19}
}

func (m *SyncRegionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SyncRegionRequest.Unmarshal(m, b)
}
func (m *SyncRegionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SyncRegionRequest.Marshal(b, m, deterministic)
}
func (m *SyncRegionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRegionRequest.Merge(m, src)
}
func (m *SyncRegionRequest) XXX_Size() int {
	return xxx_messageInfo_SyncRegionRequest.Size(m)
}
func (m *SyncRegionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRegionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRegionRequest proto.InternalMessageInfo

func (m *SyncRegionRequest) GetSourceVolume() uint64 {
	if m != nil {
		return m.SourceVolume
	}
	return 0
}

func (m *SyncRegionRequest) GetSourceUuid() string {
	if m != nil {
		return m.SourceUuid
	}
	return ""
}

func (m *SyncRegionRequest) GetDestinationVolume() uint64 {
	if m != nil {
		return m.DestinationVolume
	}
	return 0
}

func (m *SyncRegionRequest) GetDestinationUuid() string {
	if m != nil {
		return m.DestinationUuid
	}
	return ""
}

func (m *SyncRegionRequest) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SyncRegionRequest) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SyncRegionRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *SyncRegionRequest) GetSyncContext() *SyncContext {
	if m != nil {
		return m.SyncContext
	}
	return nil
}

func (m *SyncRegionRequest) GetAllowFirstIoRetry() bool {
	if m != nil {
		return m.AllowFirstIoRetry
	}
	return false
}

func (m *SyncRegionRequest) GetPoolId() uint32 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type SnapshotAncestorList struct {
	Pools                []uint32 `protobuf:"varint,1,rep,packed,name=pools,proto3" json:"pools,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotAncestorList) Reset()         { *m = SnapshotAncestorList{} }
func (m *SnapshotAncestorList) String() string { return proto.CompactTextString(m) }
func (*SnapshotAncestorList) ProtoMessage()    {}
func (*SnapshotAncestorList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{20}
}

func (m *SnapshotAncestorList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotAncestorList.Unmarshal(m, b)
}
func (m *SnapshotAncestorList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotAncestorList.Marshal(b, m, deterministic)
}
func (m *SnapshotAncestorList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotAncestorList.Merge(m, src)
}
func (m *SnapshotAncestorList) XXX_Size() int {
	return xxx_messageInfo_SnapshotAncestorList.Size(m)
}
func (m *SnapshotAncestorList) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotAncestorList.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotAncestorList proto.InternalMessageInfo

func (m *SnapshotAncestorList) GetPools() []uint32 {
	if m != nil {
		return m.Pools
	}
	return nil
}

type SnapshotConfig struct {
	Snapshots            map[string]*SnapshotAncestorList `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *SnapshotConfig) Reset()         { *m = SnapshotConfig{} }
func (m *SnapshotConfig) String() string { return proto.CompactTextString(m) }
func (*SnapshotConfig) ProtoMessage()    {}
func (*SnapshotConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{21}
}

func (m *SnapshotConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SnapshotConfig.Unmarshal(m, b)
}
func (m *SnapshotConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SnapshotConfig.Marshal(b, m, deterministic)
}
func (m *SnapshotConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotConfig.Merge(m, src)
}
func (m *SnapshotConfig) XXX_Size() int {
	return xxx_messageInfo_SnapshotConfig.Size(m)
}
func (m *SnapshotConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotConfig proto.InternalMessageInfo

func (m *SnapshotConfig) GetSnapshots() map[string]*SnapshotAncestorList {
	if m != nil {
		return m.Snapshots
	}
	return nil
}

type ReconcileSnapshotConfigRequest struct {
	SnapshotConfig       *SnapshotConfig `protobuf:"bytes,1,opt,name=snapshot_config,json=snapshotConfig,proto3" json:"snapshot_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ReconcileSnapshotConfigRequest) Reset()         { *m = ReconcileSnapshotConfigRequest{} }
func (m *ReconcileSnapshotConfigRequest) String() string { return proto.CompactTextString(m) }
func (*ReconcileSnapshotConfigRequest) ProtoMessage()    {}
func (*ReconcileSnapshotConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{22}
}

func (m *ReconcileSnapshotConfigRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReconcileSnapshotConfigRequest.Unmarshal(m, b)
}
func (m *ReconcileSnapshotConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReconcileSnapshotConfigRequest.Marshal(b, m, deterministic)
}
func (m *ReconcileSnapshotConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReconcileSnapshotConfigRequest.Merge(m, src)
}
func (m *ReconcileSnapshotConfigRequest) XXX_Size() int {
	return xxx_messageInfo_ReconcileSnapshotConfigRequest.Size(m)
}
func (m *ReconcileSnapshotConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReconcileSnapshotConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReconcileSnapshotConfigRequest proto.InternalMessageInfo

func (m *ReconcileSnapshotConfigRequest) GetSnapshotConfig() *SnapshotConfig {
	if m != nil {
		return m.SnapshotConfig
	}
	return nil
}

type ReconcileSnapshotConfigResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReconcileSnapshotConfigResponse) Reset()         { *m = ReconcileSnapshotConfigResponse{} }
func (m *ReconcileSnapshotConfigResponse) String() string { return proto.CompactTextString(m) }
func (*ReconcileSnapshotConfigResponse) ProtoMessage()    {}
func (*ReconcileSnapshotConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{23}
}

func (m *ReconcileSnapshotConfigResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReconcileSnapshotConfigResponse.Unmarshal(m, b)
}
func (m *ReconcileSnapshotConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReconcileSnapshotConfigResponse.Marshal(b, m, deterministic)
}
func (m *ReconcileSnapshotConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReconcileSnapshotConfigResponse.Merge(m, src)
}
func (m *ReconcileSnapshotConfigResponse) XXX_Size() int {
	return xxx_messageInfo_ReconcileSnapshotConfigResponse.Size(m)
}
func (m *ReconcileSnapshotConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ReconcileSnapshotConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ReconcileSnapshotConfigResponse proto.InternalMessageInfo

type SyncRegionResponse struct {
	// Whether or not the operation was successful.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// If the operation was not successful, this is an explanatory message as to
	// why.
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncRegionResponse) Reset()         { *m = SyncRegionResponse{} }
func (m *SyncRegionResponse) String() string { return proto.CompactTextString(m) }
func (*SyncRegionResponse) ProtoMessage()    {}
func (*SyncRegionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{24}
}

func (m *SyncRegionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SyncRegionResponse.Unmarshal(m, b)
}
func (m *SyncRegionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SyncRegionResponse.Marshal(b, m, deterministic)
}
func (m *SyncRegionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRegionResponse.Merge(m, src)
}
func (m *SyncRegionResponse) XXX_Size() int {
	return xxx_messageInfo_SyncRegionResponse.Size(m)
}
func (m *SyncRegionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRegionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRegionResponse proto.InternalMessageInfo

func (m *SyncRegionResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *SyncRegionResponse) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type CreateSnapshotRequest struct {
	// The volume we are creating a snapshot from. Either specify the uuid
	// or the volid
	ParentUuid  string `protobuf:"bytes,1,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentVolid uint32 `protobuf:"varint,2,opt,name=parent_volid,json=parentVolid,proto3" json:"parent_volid,omitempty"`
	// A unique identifier for this snapshot
	SnapshotUuid         string   `protobuf:"bytes,3,opt,name=snapshot_uuid,json=snapshotUuid,proto3" json:"snapshot_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateSnapshotRequest) Reset()         { *m = CreateSnapshotRequest{} }
func (m *CreateSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSnapshotRequest) ProtoMessage()    {}
func (*CreateSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{25}
}

func (m *CreateSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateSnapshotRequest.Unmarshal(m, b)
}
func (m *CreateSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateSnapshotRequest.Marshal(b, m, deterministic)
}
func (m *CreateSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSnapshotRequest.Merge(m, src)
}
func (m *CreateSnapshotRequest) XXX_Size() int {
	return xxx_messageInfo_CreateSnapshotRequest.Size(m)
}
func (m *CreateSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSnapshotRequest proto.InternalMessageInfo

func (m *CreateSnapshotRequest) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *CreateSnapshotRequest) GetParentVolid() uint32 {
	if m != nil {
		return m.ParentVolid
	}
	return 0
}

func (m *CreateSnapshotRequest) GetSnapshotUuid() string {
	if m != nil {
		return m.SnapshotUuid
	}
	return ""
}

type CreateSnapshotResponse struct {
	SnapshotConfig       *SnapshotConfig `protobuf:"bytes,1,opt,name=snapshot_config,json=snapshotConfig,proto3" json:"snapshot_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CreateSnapshotResponse) Reset()         { *m = CreateSnapshotResponse{} }
func (m *CreateSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*CreateSnapshotResponse) ProtoMessage()    {}
func (*CreateSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{26}
}

func (m *CreateSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateSnapshotResponse.Unmarshal(m, b)
}
func (m *CreateSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateSnapshotResponse.Marshal(b, m, deterministic)
}
func (m *CreateSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSnapshotResponse.Merge(m, src)
}
func (m *CreateSnapshotResponse) XXX_Size() int {
	return xxx_messageInfo_CreateSnapshotResponse.Size(m)
}
func (m *CreateSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSnapshotResponse proto.InternalMessageInfo

func (m *CreateSnapshotResponse) GetSnapshotConfig() *SnapshotConfig {
	if m != nil {
		return m.SnapshotConfig
	}
	return nil
}

type DeleteSnapshotRequest struct {
	// The volume we are creating a snapshot from. Either specify the uuid
	// or the volid
	ParentUuid  string `protobuf:"bytes,1,opt,name=parent_uuid,json=parentUuid,proto3" json:"parent_uuid,omitempty"`
	ParentVolid uint32 `protobuf:"varint,2,opt,name=parent_volid,json=parentVolid,proto3" json:"parent_volid,omitempty"`
	// A unique identifier for this snapshot
	SnapshotUuid         string   `protobuf:"bytes,3,opt,name=snapshot_uuid,json=snapshotUuid,proto3" json:"snapshot_uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteSnapshotRequest) Reset()         { *m = DeleteSnapshotRequest{} }
func (m *DeleteSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteSnapshotRequest) ProtoMessage()    {}
func (*DeleteSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{27}
}

func (m *DeleteSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteSnapshotRequest.Unmarshal(m, b)
}
func (m *DeleteSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteSnapshotRequest.Marshal(b, m, deterministic)
}
func (m *DeleteSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSnapshotRequest.Merge(m, src)
}
func (m *DeleteSnapshotRequest) XXX_Size() int {
	return xxx_messageInfo_DeleteSnapshotRequest.Size(m)
}
func (m *DeleteSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSnapshotRequest proto.InternalMessageInfo

func (m *DeleteSnapshotRequest) GetParentUuid() string {
	if m != nil {
		return m.ParentUuid
	}
	return ""
}

func (m *DeleteSnapshotRequest) GetParentVolid() uint32 {
	if m != nil {
		return m.ParentVolid
	}
	return 0
}

func (m *DeleteSnapshotRequest) GetSnapshotUuid() string {
	if m != nil {
		return m.SnapshotUuid
	}
	return ""
}

type DeleteSnapshotResponse struct {
	SnapshotConfig       *SnapshotConfig `protobuf:"bytes,1,opt,name=snapshot_config,json=snapshotConfig,proto3" json:"snapshot_config,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DeleteSnapshotResponse) Reset()         { *m = DeleteSnapshotResponse{} }
func (m *DeleteSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteSnapshotResponse) ProtoMessage()    {}
func (*DeleteSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{28}
}

func (m *DeleteSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeleteSnapshotResponse.Unmarshal(m, b)
}
func (m *DeleteSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeleteSnapshotResponse.Marshal(b, m, deterministic)
}
func (m *DeleteSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSnapshotResponse.Merge(m, src)
}
func (m *DeleteSnapshotResponse) XXX_Size() int {
	return xxx_messageInfo_DeleteSnapshotResponse.Size(m)
}
func (m *DeleteSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSnapshotResponse proto.InternalMessageInfo

func (m *DeleteSnapshotResponse) GetSnapshotConfig() *SnapshotConfig {
	if m != nil {
		return m.SnapshotConfig
	}
	return nil
}

type Metric struct {
	// The metric name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Counter or gauge
	Type MetricType `protobuf:"varint,2,opt,name=type,proto3,enum=supervisor.v1.MetricType" json:"type,omitempty"`
	// Instantaneous value
	Value                uint64   `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metric) Reset()         { *m = Metric{} }
func (m *Metric) String() string { return proto.CompactTextString(m) }
func (*Metric) ProtoMessage()    {}
func (*Metric) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{29}
}

func (m *Metric) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metric.Unmarshal(m, b)
}
func (m *Metric) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metric.Marshal(b, m, deterministic)
}
func (m *Metric) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metric.Merge(m, src)
}
func (m *Metric) XXX_Size() int {
	return xxx_messageInfo_Metric.Size(m)
}
func (m *Metric) XXX_DiscardUnknown() {
	xxx_messageInfo_Metric.DiscardUnknown(m)
}

var xxx_messageInfo_Metric proto.InternalMessageInfo

func (m *Metric) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Metric) GetType() MetricType {
	if m != nil {
		return m.Type
	}
	return MetricType_COUNT
}

func (m *Metric) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type MetricsRequest struct {
	// A list of volumes to query (by inode). If this and uuids is left empty we'll return
	// metrics for all volumes which are configured.
	Inodes []uint32 `protobuf:"varint,1,rep,packed,name=inodes,proto3" json:"inodes,omitempty"`
	// A list of volume to query (by uuid). If this and uuids is left empty we'll return
	// metrircs for all volumes which are configured.
	Uuids                []string `protobuf:"bytes,2,rep,name=uuids,proto3" json:"uuids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MetricsRequest) Reset()         { *m = MetricsRequest{} }
func (m *MetricsRequest) String() string { return proto.CompactTextString(m) }
func (*MetricsRequest) ProtoMessage()    {}
func (*MetricsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{30}
}

func (m *MetricsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetricsRequest.Unmarshal(m, b)
}
func (m *MetricsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetricsRequest.Marshal(b, m, deterministic)
}
func (m *MetricsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsRequest.Merge(m, src)
}
func (m *MetricsRequest) XXX_Size() int {
	return xxx_messageInfo_MetricsRequest.Size(m)
}
func (m *MetricsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsRequest proto.InternalMessageInfo

func (m *MetricsRequest) GetInodes() []uint32 {
	if m != nil {
		return m.Inodes
	}
	return nil
}

func (m *MetricsRequest) GetUuids() []string {
	if m != nil {
		return m.Uuids
	}
	return nil
}

type VolumeMetrics struct {
	// The volume this collection of metrics belongs to
	Inode uint32 `protobuf:"varint,1,opt,name=inode,proto3" json:"inode,omitempty"`
	// The volume this collection of metrics belongs to
	Uuid                 string    `protobuf:"bytes,2,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Metrics              []*Metric `protobuf:"bytes,3,rep,name=metrics,proto3" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *VolumeMetrics) Reset()         { *m = VolumeMetrics{} }
func (m *VolumeMetrics) String() string { return proto.CompactTextString(m) }
func (*VolumeMetrics) ProtoMessage()    {}
func (*VolumeMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{31}
}

func (m *VolumeMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_VolumeMetrics.Unmarshal(m, b)
}
func (m *VolumeMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_VolumeMetrics.Marshal(b, m, deterministic)
}
func (m *VolumeMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VolumeMetrics.Merge(m, src)
}
func (m *VolumeMetrics) XXX_Size() int {
	return xxx_messageInfo_VolumeMetrics.Size(m)
}
func (m *VolumeMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_VolumeMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_VolumeMetrics proto.InternalMessageInfo

func (m *VolumeMetrics) GetInode() uint32 {
	if m != nil {
		return m.Inode
	}
	return 0
}

func (m *VolumeMetrics) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *VolumeMetrics) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// Node-level metrics are metrics which aren't specific to a volume.
type NodeMetrics struct {
	Metrics              []*Metric `protobuf:"bytes,1,rep,name=metrics,proto3" json:"metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NodeMetrics) Reset()         { *m = NodeMetrics{} }
func (m *NodeMetrics) String() string { return proto.CompactTextString(m) }
func (*NodeMetrics) ProtoMessage()    {}
func (*NodeMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{32}
}

func (m *NodeMetrics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeMetrics.Unmarshal(m, b)
}
func (m *NodeMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeMetrics.Marshal(b, m, deterministic)
}
func (m *NodeMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeMetrics.Merge(m, src)
}
func (m *NodeMetrics) XXX_Size() int {
	return xxx_messageInfo_NodeMetrics.Size(m)
}
func (m *NodeMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_NodeMetrics proto.InternalMessageInfo

func (m *NodeMetrics) GetMetrics() []*Metric {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type MetricsResponse struct {
	// Per volume stats. One collection of metrics per requested volume.
	VolumeMetrics []*VolumeMetrics `protobuf:"bytes,1,rep,name=volume_metrics,json=volumeMetrics,proto3" json:"volume_metrics,omitempty"`
	// Per node stats. One collection per node.
	NodeMetrics          *NodeMetrics `protobuf:"bytes,2,opt,name=node_metrics,json=nodeMetrics,proto3" json:"node_metrics,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *MetricsResponse) Reset()         { *m = MetricsResponse{} }
func (m *MetricsResponse) String() string { return proto.CompactTextString(m) }
func (*MetricsResponse) ProtoMessage()    {}
func (*MetricsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b8b9452d77b1c7d2, []int{33}
}

func (m *MetricsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MetricsResponse.Unmarshal(m, b)
}
func (m *MetricsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MetricsResponse.Marshal(b, m, deterministic)
}
func (m *MetricsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetricsResponse.Merge(m, src)
}
func (m *MetricsResponse) XXX_Size() int {
	return xxx_messageInfo_MetricsResponse.Size(m)
}
func (m *MetricsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MetricsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MetricsResponse proto.InternalMessageInfo

func (m *MetricsResponse) GetVolumeMetrics() []*VolumeMetrics {
	if m != nil {
		return m.VolumeMetrics
	}
	return nil
}

func (m *MetricsResponse) GetNodeMetrics() *NodeMetrics {
	if m != nil {
		return m.NodeMetrics
	}
	return nil
}

func init() {
	proto.RegisterEnum("supervisor.v1.VolumeHashListRpcVersion", VolumeHashListRpcVersion_name, VolumeHashListRpcVersion_value)
	proto.RegisterEnum("supervisor.v1.MetricType", MetricType_name, MetricType_value)
	proto.RegisterEnum("supervisor.v1.IdMapperStatus_MapMode", IdMapperStatus_MapMode_name, IdMapperStatus_MapMode_value)
	proto.RegisterType((*ReapVolumeRequest)(nil), "supervisor.v1.ReapVolumeRequest")
	proto.RegisterType((*ReapVolumeResponse)(nil), "supervisor.v1.ReapVolumeResponse")
	proto.RegisterType((*DeleteMappingRequest)(nil), "supervisor.v1.DeleteMappingRequest")
	proto.RegisterType((*DeleteMappingResponse)(nil), "supervisor.v1.DeleteMappingResponse")
	proto.RegisterType((*SupervisorStatusRequest)(nil), "supervisor.v1.SupervisorStatusRequest")
	proto.RegisterType((*SupervisorStatus)(nil), "supervisor.v1.SupervisorStatus")
	proto.RegisterType((*IdMapping)(nil), "supervisor.v1.IdMapping")
	proto.RegisterType((*IdMapperStatus)(nil), "supervisor.v1.IdMapperStatus")
	proto.RegisterType((*ConsumerCountStatus)(nil), "supervisor.v1.ConsumerCountStatus")
	proto.RegisterType((*ConsumerCountEntry)(nil), "supervisor.v1.ConsumerCountEntry")
	proto.RegisterType((*SyncContext)(nil), "supervisor.v1.SyncContext")
	proto.RegisterType((*VolumeHash)(nil), "supervisor.v1.VolumeHash")
	proto.RegisterType((*VolumeHashListRequest)(nil), "supervisor.v1.VolumeHashListRequest")
	proto.RegisterType((*VolumeHashList)(nil), "supervisor.v1.VolumeHashList")
	proto.RegisterType((*VolumeHashListResponse)(nil), "supervisor.v1.VolumeHashListResponse")
	proto.RegisterType((*GetVolumeConsumerCountRequest)(nil), "supervisor.v1.GetVolumeConsumerCountRequest")
	proto.RegisterType((*GetVolumeConsumerCountReply)(nil), "supervisor.v1.GetVolumeConsumerCountReply")
	proto.RegisterType((*SetVolumeConsumerCountRequest)(nil), "supervisor.v1.SetVolumeConsumerCountRequest")
	proto.RegisterType((*SetVolumeConsumerCountReply)(nil), "supervisor.v1.SetVolumeConsumerCountReply")
	proto.RegisterType((*SyncRegionRequest)(nil), "supervisor.v1.SyncRegionRequest")
	proto.RegisterType((*SnapshotAncestorList)(nil), "supervisor.v1.SnapshotAncestorList")
	proto.RegisterType((*SnapshotConfig)(nil), "supervisor.v1.SnapshotConfig")
	proto.RegisterMapType((map[string]*SnapshotAncestorList)(nil), "supervisor.v1.SnapshotConfig.SnapshotsEntry")
	proto.RegisterType((*ReconcileSnapshotConfigRequest)(nil), "supervisor.v1.ReconcileSnapshotConfigRequest")
	proto.RegisterType((*ReconcileSnapshotConfigResponse)(nil), "supervisor.v1.ReconcileSnapshotConfigResponse")
	proto.RegisterType((*SyncRegionResponse)(nil), "supervisor.v1.SyncRegionResponse")
	proto.RegisterType((*CreateSnapshotRequest)(nil), "supervisor.v1.CreateSnapshotRequest")
	proto.RegisterType((*CreateSnapshotResponse)(nil), "supervisor.v1.CreateSnapshotResponse")
	proto.RegisterType((*DeleteSnapshotRequest)(nil), "supervisor.v1.DeleteSnapshotRequest")
	proto.RegisterType((*DeleteSnapshotResponse)(nil), "supervisor.v1.DeleteSnapshotResponse")
	proto.RegisterType((*Metric)(nil), "supervisor.v1.Metric")
	proto.RegisterType((*MetricsRequest)(nil), "supervisor.v1.MetricsRequest")
	proto.RegisterType((*VolumeMetrics)(nil), "supervisor.v1.VolumeMetrics")
	proto.RegisterType((*NodeMetrics)(nil), "supervisor.v1.NodeMetrics")
	proto.RegisterType((*MetricsResponse)(nil), "supervisor.v1.MetricsResponse")
}

func init() { proto.RegisterFile("supervisor.proto", fileDescriptor_b8b9452d77b1c7d2) }

var fileDescriptor_b8b9452d77b1c7d2 = []byte{
	// 1778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xdd, 0x76, 0xdb, 0xc6,
	0x11, 0x26, 0xf8, 0xcf, 0xe1, 0x8f, 0xe8, 0xad, 0x7e, 0x68, 0x3a, 0x8a, 0x2c, 0x38, 0x69, 0x54,
	0x9d, 0x98, 0xaa, 0x69, 0x56, 0x6d, 0x72, 0x8e, 0xd3, 0x3a, 0x8c, 0xad, 0x52, 0x8d, 0xe4, 0x16,
	0xb4, 0x74, 0xd1, 0xd3, 0x73, 0x58, 0x04, 0x5c, 0x49, 0x68, 0x48, 0x2c, 0x8c, 0x5d, 0xb2, 0xa5,
	0xaf, 0x7a, 0xfa, 0x06, 0xbd, 0xe8, 0x0b, 0xf4, 0xb2, 0x2f, 0xd1, 0xbb, 0xbe, 0x46, 0x5e, 0xa5,
	0x67, 0x7f, 0x00, 0x82, 0x00, 0x48, 0x89, 0x6a, 0x4e, 0x73, 0x25, 0xee, 0xec, 0xcc, 0x37, 0xf3,
	0x0d, 0x76, 0x66, 0x67, 0x05, 0x75, 0x3a, 0x71, 0xb1, 0x37, 0xb5, 0x29, 0xf1, 0x5a, 0xae, 0x47,
	0x18, 0x41, 0xd5, 0x90, 0x64, 0xfa, 0xac, 0x59, 0xb1, 0xc8, 0x78, 0x4c, 0x1c, 0xb9, 0xa9, 0xbf,
	0x80, 0x07, 0x06, 0x36, 0xdd, 0x4b, 0x32, 0x9a, 0x8c, 0xb1, 0x81, 0xdf, 0x4d, 0x30, 0x65, 0x08,
	0x41, 0x76, 0x32, 0xb1, 0x87, 0x0d, 0xed, 0xb1, 0x76, 0x50, 0x32, 0xc4, 0x6f, 0xb4, 0x09, 0x39,
	0xdb, 0x21, 0x43, 0xdc, 0x48, 0x3f, 0xd6, 0x0e, 0xaa, 0x86, 0x5c, 0xe8, 0x9b, 0x80, 0xc2, 0xe6,
	0xd4, 0x25, 0x0e, 0xc5, 0xfa, 0x21, 0x6c, 0x7e, 0x85, 0x47, 0x98, 0xe1, 0x33, 0xd3, 0x75, 0x6d,
	0xe7, 0x7a, 0x05, 0xae, 0xbe, 0x03, 0x5b, 0x11, 0x5d, 0x05, 0xf2, 0x10, 0x76, 0xfa, 0x41, 0xe0,
	0x7d, 0x66, 0xb2, 0x09, 0x55, 0x38, 0xfa, 0x7f, 0x34, 0xa8, 0x47, 0xf7, 0xd0, 0x11, 0xe4, 0xa9,
	0xf8, 0x25, 0x22, 0x2c, 0xb7, 0x77, 0x5a, 0x8a, 0xe8, 0xf4, 0x59, 0xeb, 0x2b, 0x13, 0x8f, 0x89,
	0xa3, 0x40, 0x94, 0x1a, 0xfa, 0x15, 0x54, 0xec, 0xe1, 0xd8, 0x74, 0x07, 0xca, 0x2c, 0x23, 0xcc,
	0x76, 0x5b, 0x0b, 0xe9, 0x6a, 0xf5, 0x86, 0x3c, 0x30, 0xec, 0x47, 0x50, 0x16, 0x26, 0xca, 0xe5,
	0x2f, 0xa1, 0x64, 0x59, 0xbe, 0x79, 0x56, 0x98, 0xeb, 0x11, 0xf3, 0x2e, 0x71, 0xe8, 0x64, 0x8c,
	0xbd, 0x2e, 0x99, 0x38, 0x4c, 0x61, 0x14, 0x2d, 0x4b, 0xfe, 0xd2, 0x7f, 0x06, 0x25, 0x89, 0x6f,
	0x3b, 0xd7, 0x6b, 0x64, 0xfd, 0x5f, 0x1a, 0xd4, 0x16, 0xe3, 0x42, 0x9f, 0x41, 0x76, 0xec, 0xeb,
	0xd5, 0xda, 0x1f, 0xaf, 0x24, 0xd1, 0x3a, 0x33, 0xdd, 0x33, 0x32, 0xc4, 0x86, 0x30, 0x41, 0x1d,
	0x28, 0x8e, 0x65, 0x08, 0x3c, 0x07, 0x99, 0x83, 0x72, 0xbb, 0x91, 0x68, 0xce, 0x3f, 0x4e, 0xa0,
	0xa9, 0x7f, 0x02, 0x05, 0x05, 0x83, 0x00, 0xf2, 0xe7, 0x6f, 0xde, 0xf6, 0x5f, 0xbd, 0xad, 0xa7,
	0x50, 0x01, 0x32, 0x27, 0xfd, 0x5e, 0x5d, 0xe3, 0x3f, 0xce, 0xbf, 0xee, 0xd5, 0xd3, 0xfa, 0x29,
	0xfc, 0x28, 0x21, 0x09, 0xe8, 0x39, 0x64, 0x2c, 0x8b, 0x36, 0x34, 0xe1, 0x70, 0x7f, 0x55, 0xd6,
	0x5e, 0x39, 0xcc, 0x9b, 0x19, 0x5c, 0x5b, 0xf7, 0x00, 0xc5, 0xb7, 0x50, 0x1b, 0x0a, 0x2a, 0x2c,
	0x91, 0xbb, 0x55, 0xf1, 0xfb, 0x8a, 0xe8, 0x00, 0xd2, 0x96, 0xa5, 0x4e, 0x4a, 0x23, 0x74, 0x52,
	0x16, 0xe0, 0x8d, 0xb4, 0x65, 0xe9, 0xfb, 0x50, 0xee, 0xcf, 0x1c, 0xab, 0x4b, 0x1c, 0x86, 0xff,
	0x92, 0x7c, 0x86, 0x75, 0x00, 0x59, 0x01, 0xbf, 0x36, 0xe9, 0x0d, 0xff, 0x66, 0xdf, 0xcc, 0x18,
	0xa6, 0x42, 0xa5, 0x62, 0xc8, 0x85, 0xfe, 0x5d, 0x1a, 0xb6, 0xe6, 0x4a, 0x5f, 0xdb, 0x94, 0xf9,
	0x55, 0xf1, 0x12, 0x0a, 0x53, 0xec, 0x51, 0x9b, 0x38, 0x8d, 0x82, 0xf8, 0x7a, 0x9f, 0x44, 0xc2,
	0x8f, 0x98, 0xb9, 0xd6, 0xa5, 0x54, 0x37, 0x7c, 0x3b, 0xf4, 0x08, 0x4a, 0x53, 0xa1, 0x34, 0x50,
	0x91, 0x55, 0x8d, 0xa2, 0x14, 0xf4, 0x86, 0x68, 0x0f, 0xca, 0x6a, 0x53, 0x04, 0x9e, 0x13, 0x81,
	0x83, 0x14, 0x5d, 0xf0, 0x43, 0xb6, 0x0f, 0x15, 0xca, 0x4c, 0x8f, 0x0d, 0xc8, 0xd5, 0x15, 0xc5,
	0x4c, 0x64, 0x25, 0x6b, 0x94, 0x85, 0xec, 0x8d, 0x10, 0xa1, 0x5d, 0x00, 0xec, 0x0c, 0x7d, 0x85,
	0x8c, 0x50, 0x28, 0x61, 0x67, 0xa8, 0xb6, 0xf7, 0xa0, 0xec, 0xe1, 0x6b, 0x9b, 0x38, 0x03, 0x6a,
	0xbf, 0xc7, 0xa2, 0x14, 0xb2, 0x06, 0x48, 0x51, 0xdf, 0x7e, 0x8f, 0xd1, 0x13, 0xa8, 0xda, 0x74,
	0x60, 0x91, 0xb1, 0xeb, 0x61, 0x4a, 0xf1, 0xb0, 0x91, 0x7f, 0xac, 0x1d, 0x14, 0x8d, 0x8a, 0x4d,
	0xbb, 0x81, 0x0c, 0xbd, 0x80, 0x0a, 0x9d, 0x39, 0xd6, 0xc0, 0x92, 0xa9, 0x6e, 0x14, 0xc5, 0xd7,
	0x69, 0x46, 0xb2, 0x11, 0xfa, 0x18, 0x46, 0x99, 0xce, 0x17, 0xfa, 0x77, 0x1a, 0xd4, 0x16, 0x53,
	0x85, 0x76, 0xa0, 0xe0, 0x12, 0x32, 0x9a, 0x67, 0x25, 0xcf, 0x97, 0xbd, 0x21, 0xfa, 0x3c, 0xc8,
	0xc9, 0x8d, 0x49, 0x6f, 0xd4, 0x39, 0x78, 0xb8, 0x34, 0xef, 0x7e, 0xba, 0xc4, 0xf7, 0x8d, 0xa6,
	0x2b, 0x73, 0x5b, 0xba, 0xb2, 0xd1, 0x74, 0x1d, 0x43, 0x89, 0xbb, 0x1d, 0x8c, 0x6c, 0xca, 0x1a,
	0x39, 0x51, 0x01, 0x2b, 0x7c, 0x17, 0x6f, 0x14, 0x1d, 0xfd, 0x9f, 0x1a, 0x6c, 0x47, 0xcf, 0x90,
	0xec, 0x96, 0xe1, 0x43, 0xa4, 0xdd, 0xf3, 0x10, 0xbd, 0x82, 0x0d, 0x91, 0xac, 0x20, 0x34, 0xde,
	0x49, 0x33, 0x09, 0x2d, 0x31, 0x02, 0x55, 0xe5, 0x56, 0xfe, 0x8a, 0xea, 0x3d, 0xd8, 0x3d, 0xc1,
	0x4c, 0xea, 0x2c, 0x56, 0xd3, 0xda, 0xb7, 0xcb, 0x3b, 0x78, 0xb4, 0x0c, 0xca, 0x1d, 0xcd, 0x56,
	0x03, 0x65, 0x42, 0x40, 0x6b, 0x54, 0x3b, 0x85, 0xdd, 0xfe, 0xfd, 0xa3, 0xbf, 0xa7, 0xd3, 0x77,
	0xf0, 0xa8, 0xff, 0x7f, 0xe6, 0xf9, 0xb7, 0x0c, 0x3c, 0xe0, 0x95, 0x64, 0x88, 0x1a, 0xf5, 0xc9,
	0x3d, 0x81, 0x2a, 0x25, 0x13, 0xcf, 0xc2, 0x03, 0x79, 0xde, 0x85, 0xcb, 0xac, 0x51, 0x91, 0x42,
	0x19, 0x20, 0x2f, 0x76, 0xa5, 0x24, 0xa2, 0x4a, 0xcb, 0x7e, 0x22, 0x45, 0xa2, 0x9f, 0x3c, 0x05,
	0x34, 0xc4, 0x94, 0xd9, 0x8e, 0xc9, 0x78, 0x4b, 0x50, 0x50, 0xb2, 0x4c, 0x1e, 0x84, 0x76, 0x14,
	0xde, 0x4f, 0xa0, 0x1e, 0x56, 0x17, 0xa0, 0x59, 0x01, 0xba, 0x11, 0x92, 0x0b, 0xe4, 0x6d, 0xc8,
	0xab, 0x9a, 0xca, 0x09, 0x34, 0xb5, 0xe2, 0xf2, 0x11, 0x76, 0xae, 0xd9, 0x8d, 0xe8, 0x2b, 0x59,
	0x43, 0xad, 0x78, 0x96, 0xae, 0x88, 0x67, 0x61, 0xd1, 0x58, 0x8b, 0x86, 0x5c, 0xfc, 0x8f, 0x7d,
	0x06, 0x1d, 0xc1, 0xa6, 0x39, 0x1a, 0x91, 0x3f, 0x0f, 0xae, 0x6c, 0x8f, 0xb2, 0x81, 0x4d, 0x06,
	0x1e, 0x66, 0xde, 0xac, 0x51, 0x12, 0x3e, 0x1e, 0x88, 0xbd, 0xd7, 0x7c, 0xab, 0x47, 0x0c, 0xbe,
	0x11, 0xee, 0x42, 0x10, 0xee, 0x42, 0xfa, 0xa7, 0xb0, 0xd9, 0x77, 0x4c, 0x97, 0xde, 0x10, 0xf6,
	0xd2, 0xb1, 0x30, 0x65, 0xc4, 0x13, 0x6d, 0x6b, 0x13, 0x72, 0x5c, 0x43, 0xde, 0x8e, 0x55, 0x43,
	0x2e, 0xf4, 0x7f, 0x6b, 0x50, 0xf3, 0xd5, 0xbb, 0xc4, 0xb9, 0xb2, 0xaf, 0xd1, 0x29, 0x94, 0xa8,
	0x92, 0xf8, 0x57, 0xe9, 0xa7, 0x51, 0x1a, 0x0b, 0x16, 0xc1, 0x92, 0xca, 0x5b, 0x75, 0x6e, 0xde,
	0x34, 0xe7, 0xe8, 0x72, 0x13, 0xd5, 0x21, 0xf3, 0x2d, 0x9e, 0xa9, 0x63, 0xc7, 0x7f, 0xa2, 0xcf,
	0x20, 0x37, 0x35, 0x47, 0x13, 0xac, 0x8e, 0xd8, 0x93, 0x25, 0xbe, 0xc2, 0x64, 0x0c, 0x69, 0xf1,
	0x79, 0xfa, 0x17, 0x9a, 0x7e, 0x03, 0x1f, 0x1a, 0xd8, 0x22, 0x8e, 0x65, 0x8f, 0xf0, 0x62, 0x5c,
	0xfe, 0x01, 0x7c, 0x0d, 0x1b, 0x7e, 0x44, 0xfc, 0xf3, 0x5c, 0xd9, 0xfe, 0x95, 0xbe, 0xbb, 0x92,
	0x96, 0x51, 0xa3, 0x0b, 0x6b, 0x7d, 0x1f, 0xf6, 0x96, 0x7a, 0x52, 0xf3, 0xe5, 0x6b, 0x40, 0xe1,
	0x02, 0x50, 0x7d, 0xb4, 0x01, 0x05, 0x3a, 0xb1, 0x2c, 0x4c, 0xe5, 0xf5, 0x5d, 0x34, 0xfc, 0x25,
	0x3f, 0x63, 0x1e, 0x36, 0x29, 0x71, 0xd4, 0x89, 0x57, 0x2b, 0xfd, 0xaf, 0x1a, 0x6c, 0x75, 0x3d,
	0x6c, 0xb2, 0xc0, 0x91, 0x4f, 0x66, 0x0f, 0xca, 0xae, 0xe9, 0x61, 0x87, 0x0d, 0x42, 0xe5, 0x0b,
	0x52, 0xe4, 0x5f, 0xbc, 0x4a, 0x61, 0x4a, 0x46, 0xaa, 0x94, 0xaa, 0x86, 0x32, 0xba, 0xe4, 0x22,
	0x51, 0x91, 0x7e, 0x42, 0x04, 0x4a, 0x46, 0xa0, 0x54, 0x7c, 0x21, 0xc7, 0xd1, 0xff, 0x08, 0xdb,
	0xd1, 0x08, 0x14, 0x9d, 0xef, 0x2b, 0x9f, 0x9c, 0xa4, 0x1c, 0xd3, 0x7f, 0x48, 0x92, 0xd1, 0x08,
	0xbe, 0x67, 0x92, 0x26, 0xe4, 0xcf, 0x30, 0xf3, 0x6c, 0x8b, 0x77, 0x5c, 0xc7, 0x54, 0xed, 0xaf,
	0x64, 0x88, 0xdf, 0xe8, 0x29, 0x64, 0xd9, 0xcc, 0xf5, 0x27, 0xec, 0xe8, 0x7d, 0x2d, 0x0d, 0xdf,
	0xce, 0x5c, 0x6c, 0x08, 0x35, 0x5e, 0xc3, 0xb2, 0x54, 0x64, 0xdf, 0x93, 0x0b, 0xfd, 0x0b, 0xa8,
	0x49, 0x4d, 0xff, 0x2d, 0xc3, 0x8f, 0x95, 0xe8, 0xdd, 0x7e, 0xb1, 0xab, 0x15, 0xb7, 0xe7, 0xa9,
	0x90, 0x77, 0x70, 0xc9, 0x90, 0x0b, 0xfd, 0x4f, 0x50, 0x95, 0x5d, 0x53, 0xa1, 0xcc, 0xef, 0x01,
	0x2d, 0x7c, 0x0f, 0xf8, 0x37, 0x46, 0x3a, 0x74, 0x63, 0x1c, 0x41, 0x61, 0x2c, 0x8d, 0xd4, 0x94,
	0xbf, 0x95, 0x48, 0xc1, 0xf0, 0xb5, 0xf4, 0x2f, 0xa0, 0x7c, 0x4e, 0x86, 0x81, 0xa7, 0x90, 0xbd,
	0x76, 0x27, 0xfb, 0x7f, 0x68, 0xb0, 0x11, 0x90, 0x55, 0x9f, 0xaa, 0x0b, 0x35, 0x35, 0x77, 0x2d,
	0x62, 0x7d, 0x90, 0x38, 0x62, 0xf8, 0xd6, 0xd5, 0xe9, 0x02, 0xe7, 0x17, 0x50, 0xe1, 0x2c, 0x03,
	0x88, 0x74, 0x62, 0xff, 0x0e, 0xc5, 0x6e, 0x94, 0x9d, 0xf9, 0xe2, 0xf0, 0x10, 0x1a, 0xcb, 0x86,
	0x21, 0x94, 0x87, 0xf4, 0xe5, 0xb3, 0x7a, 0x4a, 0xfc, 0x6d, 0xd7, 0xb5, 0x43, 0x1d, 0x60, 0xfe,
	0x65, 0x51, 0x09, 0x72, 0xdd, 0x37, 0x17, 0xe7, 0xfc, 0x9d, 0x53, 0x82, 0xdc, 0xc9, 0xcb, 0x8b,
	0x93, 0x57, 0x75, 0xad, 0xfd, 0xf7, 0x3a, 0xc0, 0xfc, 0x35, 0x8a, 0xfa, 0x90, 0x57, 0x4f, 0x9c,
	0x1f, 0x47, 0x8f, 0x5f, 0xf2, 0x73, 0xb6, 0xb9, 0x77, 0x8b, 0x9e, 0x9e, 0x42, 0x7d, 0x80, 0xf9,
	0x3b, 0x1b, 0x3d, 0x8e, 0x18, 0xc4, 0x5e, 0xf0, 0xcd, 0xfd, 0x15, 0x1a, 0xaa, 0xff, 0xa5, 0xd0,
	0x1f, 0xa0, 0xba, 0xf0, 0xf4, 0x46, 0xd1, 0x7e, 0x9e, 0xf4, 0x88, 0x6f, 0x7e, 0xb4, 0x5a, 0x29,
	0x40, 0xff, 0x39, 0x64, 0x7f, 0x4b, 0xbe, 0xc5, 0x68, 0x33, 0x34, 0x87, 0x70, 0xc1, 0xef, 0x26,
	0xd8, 0x9b, 0x35, 0x77, 0x22, 0xd2, 0x90, 0xe1, 0x6b, 0xa8, 0xca, 0x82, 0x3c, 0xc1, 0xec, 0x4b,
	0x42, 0x46, 0x0b, 0x08, 0x72, 0xe7, 0x37, 0x78, 0xd6, 0xdc, 0x8d, 0x49, 0x95, 0xbe, 0x18, 0x9a,
	0xf4, 0x14, 0xea, 0x41, 0x5d, 0xca, 0x2f, 0xdc, 0xa1, 0xc9, 0xb0, 0x80, 0xda, 0x8a, 0x19, 0x71,
	0x71, 0xf3, 0x83, 0x98, 0x58, 0xda, 0xcc, 0xa1, 0x6a, 0x52, 0xcc, 0x8f, 0x8b, 0x00, 0x6a, 0xc6,
	0x2c, 0xf8, 0x96, 0xe4, 0xf6, 0x30, 0xd1, 0x89, 0x98, 0xe0, 0x53, 0xe8, 0x14, 0x36, 0x82, 0x68,
	0xfb, 0xcc, 0xe3, 0x69, 0x4f, 0xe6, 0xb7, 0x97, 0xc4, 0x4f, 0x5a, 0xf8, 0x61, 0x9d, 0x89, 0xe7,
	0x70, 0x10, 0xad, 0x82, 0xdb, 0x89, 0x19, 0xca, 0x8d, 0x5b, 0x59, 0x9e, 0xf9, 0x09, 0xe3, 0xa1,
	0x2a, 0xb0, 0x55, 0x3c, 0x1f, 0x2d, 0x71, 0x94, 0xc0, 0xf4, 0xc2, 0x76, 0xd8, 0xf3, 0xf6, 0x3a,
	0x4c, 0xa5, 0xc5, 0x12, 0xa6, 0x0a, 0x2e, 0xce, 0x54, 0x6e, 0xac, 0xc7, 0x54, 0x81, 0xad, 0xc7,
	0x54, 0x1a, 0x2d, 0x61, 0x7a, 0xdc, 0x59, 0x97, 0xe9, 0x71, 0x67, 0x05, 0xd3, 0xe3, 0xce, 0x12,
	0xa6, 0xc7, 0x9d, 0xf5, 0x99, 0x1e, 0x77, 0xee, 0xc1, 0xf4, 0xb8, 0xa3, 0x98, 0x9e, 0x41, 0x96,
	0x0f, 0x4d, 0xb1, 0x0e, 0x14, 0x7b, 0x4a, 0xc4, 0x3a, 0x50, 0x7c, 0xd6, 0xd2, 0x53, 0xc8, 0x8c,
	0xbd, 0xd8, 0x3f, 0x5a, 0xfd, 0xd6, 0x54, 0xe0, 0x1f, 0xdf, 0xa2, 0xe5, 0x3b, 0xf8, 0xa9, 0x86,
	0x18, 0x6c, 0x27, 0xbf, 0x21, 0x51, 0x74, 0x52, 0x5e, 0xf9, 0x6a, 0x6d, 0x1e, 0xde, 0x51, 0x5b,
	0xa6, 0x9d, 0xc1, 0x76, 0xff, 0x6e, 0x5e, 0xfb, 0x6b, 0x79, 0xed, 0xaf, 0xf4, 0x3a, 0x80, 0xda,
	0xe2, 0x1c, 0x18, 0x4b, 0x67, 0xe2, 0xa0, 0x1a, 0x4b, 0x67, 0xf2, 0x30, 0x29, 0x1d, 0x2c, 0xce,
	0x60, 0x28, 0xf9, 0x36, 0xb8, 0xcd, 0x41, 0xf2, 0x20, 0xa7, 0xa7, 0xd0, 0x7b, 0xd8, 0x59, 0x32,
	0xb7, 0xa3, 0xa7, 0xb1, 0x2b, 0x6d, 0xd5, 0x4b, 0xa2, 0xd9, 0xba, 0xab, 0x7a, 0xe0, 0xfb, 0x14,
	0x0a, 0xfe, 0x84, 0xb1, 0x9b, 0x38, 0xda, 0x04, 0x17, 0xf6, 0x87, 0xcb, 0xb6, 0x7d, 0xac, 0x2f,
	0x3b, 0xbf, 0x6f, 0x5b, 0x64, 0x88, 0x5b, 0xfc, 0x15, 0x64, 0x5e, 0x63, 0x42, 0x5b, 0x0e, 0x66,
	0x47, 0xc1, 0xea, 0x88, 0x72, 0x6b, 0x0b, 0x1f, 0xcd, 0x71, 0x8e, 0xa6, 0xcf, 0xbe, 0xc9, 0x8b,
	0xff, 0xc9, 0x3f, 0xff, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x34, 0x76, 0xb8, 0x8f, 0xc4, 0x17,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SupervisorClient is the client API for Supervisor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SupervisorClient interface {
	//*
	// Get program status.
	Status(ctx context.Context, in *SupervisorStatusRequest, opts ...grpc.CallOption) (*SupervisorStatus, error)
	//*
	// Reap a volume.
	ReapVolume(ctx context.Context, in *ReapVolumeRequest, opts ...grpc.CallOption) (*ReapVolumeResponse, error)
	//*
	// Delete a mapping, freeing associated resources.
	DeleteMapping(ctx context.Context, in *DeleteMappingRequest, opts ...grpc.CallOption) (*DeleteMappingResponse, error)
	//*
	// Perform actions that really only make sense for very low-level testing.
	Poke(ctx context.Context, in *v1.PokeQuery, opts ...grpc.CallOption) (*v1.PokeResponse, error)
	// Config services, from common.v1.
	ConfigGetBool(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetBoolReply, error)
	ConfigUpdateBool(ctx context.Context, in *v1.ConfigBool, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListBool(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigBoolList, error)
	ConfigGetString(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetStringReply, error)
	ConfigUpdateString(ctx context.Context, in *v1.ConfigString, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListString(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigStringList, error)
	ConfigGetUint32(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint32Reply, error)
	ConfigUpdateUint32(ctx context.Context, in *v1.ConfigUint32, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListUint32(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint32List, error)
	ConfigGetUint64(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint64Reply, error)
	ConfigUpdateUint64(ctx context.Context, in *v1.ConfigUint64, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListUint64(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint64List, error)
	//*
	// Sync the specified region. Called by symmetra.
	Sync(ctx context.Context, in *SyncRegionRequest, opts ...grpc.CallOption) (*SyncRegionResponse, error)
	//*
	// Return a hash list for the specified volume, over the specified range.
	// Note: this is a streaming RPC as the hash lists returned could conceiveably
	// be multiple megabytes in size.
	//
	// returns the hash list and volume hash
	VolumeHashList(ctx context.Context, in *VolumeHashListRequest, opts ...grpc.CallOption) (Supervisor_VolumeHashListClient, error)
	//*
	//* Sync 2020.1 consumer count interface.
	GetVolumeConsumerCount(ctx context.Context, in *GetVolumeConsumerCountRequest, opts ...grpc.CallOption) (*GetVolumeConsumerCountReply, error)
	SetVolumeConsumerCount(ctx context.Context, in *SetVolumeConsumerCountRequest, opts ...grpc.CallOption) (*SetVolumeConsumerCountReply, error)
	// Create a snapshot with the provided UUID, from the provided parent volume.
	// This must only be called on the master. Internally, the dataplane handles
	// this API call by creating the mapping {snapshot_uuid => pool_id} and updating
	// the mapping parent_volume -> new_pool_id.
	//
	// All subsequent IO that passes through the master must lookup the appropriate pool ID
	// for that IO and embed it in the IO WriteContext. This lazily generates the pool on
	// the recipient RdbPlugin.
	CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*CreateSnapshotResponse, error)
	// Delete a snapshot with the provided UUID. This API must be called on all nodes
	// which have a copy of the snapshot. The snapshot must have been de-configured
	// prior to calling this API.
	DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*DeleteSnapshotResponse, error)
	// This API is used to dictate the list of snapshots a volume has to the dataplane.
	// It's required for two reasons:
	// The CP needs to be able to say to a DP node/volume: "here are the snapshots I
	// believe exist". The dataplane should treat this list as de facto and ensure that
	// the configuration matches. This is required for two reasons:
	// 1. If we configure a bunch of snapshots on the master and then failover to a
	//    replica before any IO was issued against the snapshots (remembering that
	//    the create request is passed to the replica by a tag in the IO context)
	//    then the replica has no knowledge of the snapshot configuration. We need
	//    a way to apply this configuration.
	// 2. It's entirely possible that the CP requests a snapshot be created but the
	//    DP fails before the RPC reply is received by the CP. In this case the DP
	//    has an excess snap that can be deleted. Note: it's not imperative that we
	//    clean up an excess snap, it can't do any harm from a data integrity perspective.
	//
	// This reconciliation process will have to happen every time a master is configured.
	// This could be the first time we are configuring a volume, or it could be following
	// a failover when a replica is promoted to a master (like in 1. above).
	//
	// TODO(AJReid): It might be a better idea to embed the SnapshotsConfig data structure
	// in the DirectorVolume message type, and avoid another RPC call.
	ReconcileSnapshotConfig(ctx context.Context, in *ReconcileSnapshotConfigRequest, opts ...grpc.CallOption) (*ReconcileSnapshotConfigResponse, error)
	//*
	// Collect the dataplane node-level metrics and specific per-volume metrics.
	// NOTE: This is an experimental dataplane-only API. It's probably not quite
	// what the control-plane requires in terms of a metrics API, but it's fine
	// for dataplane tooling and tests.
	Metrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error)
}

type supervisorClient struct {
	cc *grpc.ClientConn
}

func NewSupervisorClient(cc *grpc.ClientConn) SupervisorClient {
	return &supervisorClient{cc}
}

func (c *supervisorClient) Status(ctx context.Context, in *SupervisorStatusRequest, opts ...grpc.CallOption) (*SupervisorStatus, error) {
	out := new(SupervisorStatus)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ReapVolume(ctx context.Context, in *ReapVolumeRequest, opts ...grpc.CallOption) (*ReapVolumeResponse, error) {
	out := new(ReapVolumeResponse)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ReapVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) DeleteMapping(ctx context.Context, in *DeleteMappingRequest, opts ...grpc.CallOption) (*DeleteMappingResponse, error) {
	out := new(DeleteMappingResponse)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/DeleteMapping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) Poke(ctx context.Context, in *v1.PokeQuery, opts ...grpc.CallOption) (*v1.PokeResponse, error) {
	out := new(v1.PokeResponse)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/Poke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigGetBool(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetBoolReply, error) {
	out := new(v1.ConfigGetBoolReply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigGetBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigUpdateBool(ctx context.Context, in *v1.ConfigBool, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigUpdateBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigListBool(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigBoolList, error) {
	out := new(v1.ConfigBoolList)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigListBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigGetString(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetStringReply, error) {
	out := new(v1.ConfigGetStringReply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigGetString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigUpdateString(ctx context.Context, in *v1.ConfigString, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigUpdateString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigListString(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigStringList, error) {
	out := new(v1.ConfigStringList)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigListString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigGetUint32(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint32Reply, error) {
	out := new(v1.ConfigGetUint32Reply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigGetUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigUpdateUint32(ctx context.Context, in *v1.ConfigUint32, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigUpdateUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigListUint32(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint32List, error) {
	out := new(v1.ConfigUint32List)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigListUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigGetUint64(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint64Reply, error) {
	out := new(v1.ConfigGetUint64Reply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigGetUint64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigUpdateUint64(ctx context.Context, in *v1.ConfigUint64, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigUpdateUint64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ConfigListUint64(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint64List, error) {
	out := new(v1.ConfigUint64List)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ConfigListUint64", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) Sync(ctx context.Context, in *SyncRegionRequest, opts ...grpc.CallOption) (*SyncRegionResponse, error) {
	out := new(SyncRegionResponse)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/Sync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) VolumeHashList(ctx context.Context, in *VolumeHashListRequest, opts ...grpc.CallOption) (Supervisor_VolumeHashListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Supervisor_serviceDesc.Streams[0], "/supervisor.v1.Supervisor/VolumeHashList", opts...)
	if err != nil {
		return nil, err
	}
	x := &supervisorVolumeHashListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Supervisor_VolumeHashListClient interface {
	Recv() (*VolumeHashListResponse, error)
	grpc.ClientStream
}

type supervisorVolumeHashListClient struct {
	grpc.ClientStream
}

func (x *supervisorVolumeHashListClient) Recv() (*VolumeHashListResponse, error) {
	m := new(VolumeHashListResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *supervisorClient) GetVolumeConsumerCount(ctx context.Context, in *GetVolumeConsumerCountRequest, opts ...grpc.CallOption) (*GetVolumeConsumerCountReply, error) {
	out := new(GetVolumeConsumerCountReply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/GetVolumeConsumerCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) SetVolumeConsumerCount(ctx context.Context, in *SetVolumeConsumerCountRequest, opts ...grpc.CallOption) (*SetVolumeConsumerCountReply, error) {
	out := new(SetVolumeConsumerCountReply)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/SetVolumeConsumerCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) CreateSnapshot(ctx context.Context, in *CreateSnapshotRequest, opts ...grpc.CallOption) (*CreateSnapshotResponse, error) {
	out := new(CreateSnapshotResponse)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/CreateSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) DeleteSnapshot(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*DeleteSnapshotResponse, error) {
	out := new(DeleteSnapshotResponse)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/DeleteSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) ReconcileSnapshotConfig(ctx context.Context, in *ReconcileSnapshotConfigRequest, opts ...grpc.CallOption) (*ReconcileSnapshotConfigResponse, error) {
	out := new(ReconcileSnapshotConfigResponse)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/ReconcileSnapshotConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *supervisorClient) Metrics(ctx context.Context, in *MetricsRequest, opts ...grpc.CallOption) (*MetricsResponse, error) {
	out := new(MetricsResponse)
	err := c.cc.Invoke(ctx, "/supervisor.v1.Supervisor/Metrics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SupervisorServer is the server API for Supervisor service.
type SupervisorServer interface {
	//*
	// Get program status.
	Status(context.Context, *SupervisorStatusRequest) (*SupervisorStatus, error)
	//*
	// Reap a volume.
	ReapVolume(context.Context, *ReapVolumeRequest) (*ReapVolumeResponse, error)
	//*
	// Delete a mapping, freeing associated resources.
	DeleteMapping(context.Context, *DeleteMappingRequest) (*DeleteMappingResponse, error)
	//*
	// Perform actions that really only make sense for very low-level testing.
	Poke(context.Context, *v1.PokeQuery) (*v1.PokeResponse, error)
	// Config services, from common.v1.
	ConfigGetBool(context.Context, *v1.ConfigKey) (*v1.ConfigGetBoolReply, error)
	ConfigUpdateBool(context.Context, *v1.ConfigBool) (*v1.ConfigUpdateReply, error)
	ConfigListBool(context.Context, *v1.ConfigListQuery) (*v1.ConfigBoolList, error)
	ConfigGetString(context.Context, *v1.ConfigKey) (*v1.ConfigGetStringReply, error)
	ConfigUpdateString(context.Context, *v1.ConfigString) (*v1.ConfigUpdateReply, error)
	ConfigListString(context.Context, *v1.ConfigListQuery) (*v1.ConfigStringList, error)
	ConfigGetUint32(context.Context, *v1.ConfigKey) (*v1.ConfigGetUint32Reply, error)
	ConfigUpdateUint32(context.Context, *v1.ConfigUint32) (*v1.ConfigUpdateReply, error)
	ConfigListUint32(context.Context, *v1.ConfigListQuery) (*v1.ConfigUint32List, error)
	ConfigGetUint64(context.Context, *v1.ConfigKey) (*v1.ConfigGetUint64Reply, error)
	ConfigUpdateUint64(context.Context, *v1.ConfigUint64) (*v1.ConfigUpdateReply, error)
	ConfigListUint64(context.Context, *v1.ConfigListQuery) (*v1.ConfigUint64List, error)
	//*
	// Sync the specified region. Called by symmetra.
	Sync(context.Context, *SyncRegionRequest) (*SyncRegionResponse, error)
	//*
	// Return a hash list for the specified volume, over the specified range.
	// Note: this is a streaming RPC as the hash lists returned could conceiveably
	// be multiple megabytes in size.
	//
	// returns the hash list and volume hash
	VolumeHashList(*VolumeHashListRequest, Supervisor_VolumeHashListServer) error
	//*
	//* Sync 2020.1 consumer count interface.
	GetVolumeConsumerCount(context.Context, *GetVolumeConsumerCountRequest) (*GetVolumeConsumerCountReply, error)
	SetVolumeConsumerCount(context.Context, *SetVolumeConsumerCountRequest) (*SetVolumeConsumerCountReply, error)
	// Create a snapshot with the provided UUID, from the provided parent volume.
	// This must only be called on the master. Internally, the dataplane handles
	// this API call by creating the mapping {snapshot_uuid => pool_id} and updating
	// the mapping parent_volume -> new_pool_id.
	//
	// All subsequent IO that passes through the master must lookup the appropriate pool ID
	// for that IO and embed it in the IO WriteContext. This lazily generates the pool on
	// the recipient RdbPlugin.
	CreateSnapshot(context.Context, *CreateSnapshotRequest) (*CreateSnapshotResponse, error)
	// Delete a snapshot with the provided UUID. This API must be called on all nodes
	// which have a copy of the snapshot. The snapshot must have been de-configured
	// prior to calling this API.
	DeleteSnapshot(context.Context, *DeleteSnapshotRequest) (*DeleteSnapshotResponse, error)
	// This API is used to dictate the list of snapshots a volume has to the dataplane.
	// It's required for two reasons:
	// The CP needs to be able to say to a DP node/volume: "here are the snapshots I
	// believe exist". The dataplane should treat this list as de facto and ensure that
	// the configuration matches. This is required for two reasons:
	// 1. If we configure a bunch of snapshots on the master and then failover to a
	//    replica before any IO was issued against the snapshots (remembering that
	//    the create request is passed to the replica by a tag in the IO context)
	//    then the replica has no knowledge of the snapshot configuration. We need
	//    a way to apply this configuration.
	// 2. It's entirely possible that the CP requests a snapshot be created but the
	//    DP fails before the RPC reply is received by the CP. In this case the DP
	//    has an excess snap that can be deleted. Note: it's not imperative that we
	//    clean up an excess snap, it can't do any harm from a data integrity perspective.
	//
	// This reconciliation process will have to happen every time a master is configured.
	// This could be the first time we are configuring a volume, or it could be following
	// a failover when a replica is promoted to a master (like in 1. above).
	//
	// TODO(AJReid): It might be a better idea to embed the SnapshotsConfig data structure
	// in the DirectorVolume message type, and avoid another RPC call.
	ReconcileSnapshotConfig(context.Context, *ReconcileSnapshotConfigRequest) (*ReconcileSnapshotConfigResponse, error)
	//*
	// Collect the dataplane node-level metrics and specific per-volume metrics.
	// NOTE: This is an experimental dataplane-only API. It's probably not quite
	// what the control-plane requires in terms of a metrics API, but it's fine
	// for dataplane tooling and tests.
	Metrics(context.Context, *MetricsRequest) (*MetricsResponse, error)
}

// UnimplementedSupervisorServer can be embedded to have forward compatible implementations.
type UnimplementedSupervisorServer struct {
}

func (*UnimplementedSupervisorServer) Status(ctx context.Context, req *SupervisorStatusRequest) (*SupervisorStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (*UnimplementedSupervisorServer) ReapVolume(ctx context.Context, req *ReapVolumeRequest) (*ReapVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReapVolume not implemented")
}
func (*UnimplementedSupervisorServer) DeleteMapping(ctx context.Context, req *DeleteMappingRequest) (*DeleteMappingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMapping not implemented")
}
func (*UnimplementedSupervisorServer) Poke(ctx context.Context, req *v1.PokeQuery) (*v1.PokeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Poke not implemented")
}
func (*UnimplementedSupervisorServer) ConfigGetBool(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetBoolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetBool not implemented")
}
func (*UnimplementedSupervisorServer) ConfigUpdateBool(ctx context.Context, req *v1.ConfigBool) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateBool not implemented")
}
func (*UnimplementedSupervisorServer) ConfigListBool(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigBoolList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListBool not implemented")
}
func (*UnimplementedSupervisorServer) ConfigGetString(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetStringReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetString not implemented")
}
func (*UnimplementedSupervisorServer) ConfigUpdateString(ctx context.Context, req *v1.ConfigString) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateString not implemented")
}
func (*UnimplementedSupervisorServer) ConfigListString(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigStringList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListString not implemented")
}
func (*UnimplementedSupervisorServer) ConfigGetUint32(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetUint32Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetUint32 not implemented")
}
func (*UnimplementedSupervisorServer) ConfigUpdateUint32(ctx context.Context, req *v1.ConfigUint32) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateUint32 not implemented")
}
func (*UnimplementedSupervisorServer) ConfigListUint32(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigUint32List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListUint32 not implemented")
}
func (*UnimplementedSupervisorServer) ConfigGetUint64(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetUint64Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetUint64 not implemented")
}
func (*UnimplementedSupervisorServer) ConfigUpdateUint64(ctx context.Context, req *v1.ConfigUint64) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateUint64 not implemented")
}
func (*UnimplementedSupervisorServer) ConfigListUint64(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigUint64List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListUint64 not implemented")
}
func (*UnimplementedSupervisorServer) Sync(ctx context.Context, req *SyncRegionRequest) (*SyncRegionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (*UnimplementedSupervisorServer) VolumeHashList(req *VolumeHashListRequest, srv Supervisor_VolumeHashListServer) error {
	return status.Errorf(codes.Unimplemented, "method VolumeHashList not implemented")
}
func (*UnimplementedSupervisorServer) GetVolumeConsumerCount(ctx context.Context, req *GetVolumeConsumerCountRequest) (*GetVolumeConsumerCountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVolumeConsumerCount not implemented")
}
func (*UnimplementedSupervisorServer) SetVolumeConsumerCount(ctx context.Context, req *SetVolumeConsumerCountRequest) (*SetVolumeConsumerCountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVolumeConsumerCount not implemented")
}
func (*UnimplementedSupervisorServer) CreateSnapshot(ctx context.Context, req *CreateSnapshotRequest) (*CreateSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSnapshot not implemented")
}
func (*UnimplementedSupervisorServer) DeleteSnapshot(ctx context.Context, req *DeleteSnapshotRequest) (*DeleteSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSnapshot not implemented")
}
func (*UnimplementedSupervisorServer) ReconcileSnapshotConfig(ctx context.Context, req *ReconcileSnapshotConfigRequest) (*ReconcileSnapshotConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReconcileSnapshotConfig not implemented")
}
func (*UnimplementedSupervisorServer) Metrics(ctx context.Context, req *MetricsRequest) (*MetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metrics not implemented")
}

func RegisterSupervisorServer(s *grpc.Server, srv SupervisorServer) {
	s.RegisterService(&_Supervisor_serviceDesc, srv)
}

func _Supervisor_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SupervisorStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).Status(ctx, req.(*SupervisorStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ReapVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReapVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ReapVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ReapVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ReapVolume(ctx, req.(*ReapVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_DeleteMapping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMappingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).DeleteMapping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/DeleteMapping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).DeleteMapping(ctx, req.(*DeleteMappingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_Poke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.PokeQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).Poke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/Poke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).Poke(ctx, req.(*v1.PokeQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigGetBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigGetBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigGetBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigGetBool(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigUpdateBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigBool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigUpdateBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigUpdateBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigUpdateBool(ctx, req.(*v1.ConfigBool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigListBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigListBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigListBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigListBool(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigGetString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigGetString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigGetString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigGetString(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigUpdateString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigUpdateString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigUpdateString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigUpdateString(ctx, req.(*v1.ConfigString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigListString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigListString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigListString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigListString(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigGetUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigGetUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigGetUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigGetUint32(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigUpdateUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigUint32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigUpdateUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigUpdateUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigUpdateUint32(ctx, req.(*v1.ConfigUint32))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigListUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigListUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigListUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigListUint32(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigGetUint64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigGetUint64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigGetUint64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigGetUint64(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigUpdateUint64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigUint64)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigUpdateUint64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigUpdateUint64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigUpdateUint64(ctx, req.(*v1.ConfigUint64))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ConfigListUint64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ConfigListUint64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ConfigListUint64",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ConfigListUint64(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_Sync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).Sync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/Sync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).Sync(ctx, req.(*SyncRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_VolumeHashList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VolumeHashListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SupervisorServer).VolumeHashList(m, &supervisorVolumeHashListServer{stream})
}

type Supervisor_VolumeHashListServer interface {
	Send(*VolumeHashListResponse) error
	grpc.ServerStream
}

type supervisorVolumeHashListServer struct {
	grpc.ServerStream
}

func (x *supervisorVolumeHashListServer) Send(m *VolumeHashListResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Supervisor_GetVolumeConsumerCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVolumeConsumerCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).GetVolumeConsumerCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/GetVolumeConsumerCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).GetVolumeConsumerCount(ctx, req.(*GetVolumeConsumerCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_SetVolumeConsumerCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetVolumeConsumerCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).SetVolumeConsumerCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/SetVolumeConsumerCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).SetVolumeConsumerCount(ctx, req.(*SetVolumeConsumerCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_CreateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).CreateSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/CreateSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).CreateSnapshot(ctx, req.(*CreateSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_DeleteSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).DeleteSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/DeleteSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).DeleteSnapshot(ctx, req.(*DeleteSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_ReconcileSnapshotConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReconcileSnapshotConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).ReconcileSnapshotConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/ReconcileSnapshotConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).ReconcileSnapshotConfig(ctx, req.(*ReconcileSnapshotConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Supervisor_Metrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SupervisorServer).Metrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/supervisor.v1.Supervisor/Metrics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SupervisorServer).Metrics(ctx, req.(*MetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Supervisor_serviceDesc = grpc.ServiceDesc{
	ServiceName: "supervisor.v1.Supervisor",
	HandlerType: (*SupervisorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _Supervisor_Status_Handler,
		},
		{
			MethodName: "ReapVolume",
			Handler:    _Supervisor_ReapVolume_Handler,
		},
		{
			MethodName: "DeleteMapping",
			Handler:    _Supervisor_DeleteMapping_Handler,
		},
		{
			MethodName: "Poke",
			Handler:    _Supervisor_Poke_Handler,
		},
		{
			MethodName: "ConfigGetBool",
			Handler:    _Supervisor_ConfigGetBool_Handler,
		},
		{
			MethodName: "ConfigUpdateBool",
			Handler:    _Supervisor_ConfigUpdateBool_Handler,
		},
		{
			MethodName: "ConfigListBool",
			Handler:    _Supervisor_ConfigListBool_Handler,
		},
		{
			MethodName: "ConfigGetString",
			Handler:    _Supervisor_ConfigGetString_Handler,
		},
		{
			MethodName: "ConfigUpdateString",
			Handler:    _Supervisor_ConfigUpdateString_Handler,
		},
		{
			MethodName: "ConfigListString",
			Handler:    _Supervisor_ConfigListString_Handler,
		},
		{
			MethodName: "ConfigGetUint32",
			Handler:    _Supervisor_ConfigGetUint32_Handler,
		},
		{
			MethodName: "ConfigUpdateUint32",
			Handler:    _Supervisor_ConfigUpdateUint32_Handler,
		},
		{
			MethodName: "ConfigListUint32",
			Handler:    _Supervisor_ConfigListUint32_Handler,
		},
		{
			MethodName: "ConfigGetUint64",
			Handler:    _Supervisor_ConfigGetUint64_Handler,
		},
		{
			MethodName: "ConfigUpdateUint64",
			Handler:    _Supervisor_ConfigUpdateUint64_Handler,
		},
		{
			MethodName: "ConfigListUint64",
			Handler:    _Supervisor_ConfigListUint64_Handler,
		},
		{
			MethodName: "Sync",
			Handler:    _Supervisor_Sync_Handler,
		},
		{
			MethodName: "GetVolumeConsumerCount",
			Handler:    _Supervisor_GetVolumeConsumerCount_Handler,
		},
		{
			MethodName: "SetVolumeConsumerCount",
			Handler:    _Supervisor_SetVolumeConsumerCount_Handler,
		},
		{
			MethodName: "CreateSnapshot",
			Handler:    _Supervisor_CreateSnapshot_Handler,
		},
		{
			MethodName: "DeleteSnapshot",
			Handler:    _Supervisor_DeleteSnapshot_Handler,
		},
		{
			MethodName: "ReconcileSnapshotConfig",
			Handler:    _Supervisor_ReconcileSnapshotConfig_Handler,
		},
		{
			MethodName: "Metrics",
			Handler:    _Supervisor_Metrics_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "VolumeHashList",
			Handler:       _Supervisor_VolumeHashList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "supervisor.proto",
}
