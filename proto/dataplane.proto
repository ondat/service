syntax = "proto3";
package dataplane;

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
message ObjectMeta {
    // Name must be unique within a namespace. Is required when creating resources, although
    // some resources may allow a client to request the generation of an appropriate name
    // automatically. Name is primarily intended for creation idempotence and configuration
    // definition.
    // Cannot be updated.  
    // +optional
    optional string name = 1;


    // UID is the unique in time and space value for this object. It is typically generated by
    // the server on successful creation of a resource and is not allowed to change on PUT
    // operations.
    // 
    // Populated by the system.
    // Read-only.  
    // +optional
    optional string uid = 2;

    // An opaque value that represents the internal version of this object that can
    // be used by clients to determine when objects have changed. May be used for optimistic
    // concurrency, change detection, and the watch operation on a resource or set of resources.
    // Clients must treat these values as opaque and passed unmodified back to the server.
    // They may only be valid for a particular resource or set of resources.
    // 
    // Populated by the system.
    // Read-only.
    // Value must be treated as opaque by clients and .  
    // +optional
    optional string resourceVersion = 3;

    // CreationTimestamp is a timestamp representing the server time when this object was
    // created. It is not guaranteed to be set in happens-before order across separate operations.
    // Clients may not set this value. It is represented in RFC3339 form and is in UTC.
    // 
    // Populated by the system.
    // Read-only.
    // Null for lists.  
    // +optional
    optional Time creationTimestamp = 4;

    // DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
    // field is set by the server when a graceful deletion is requested by the user, and is not
    // directly settable by a client. The resource is expected to be deleted (no longer visible
    // from resource lists, and not reachable by name) after the time in this field. Once set,
    // this value may not be unset or be set further into the future, although it may be shortened
    // or the resource may be deleted prior to this time. For example, a user may request that
    // a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination
    // signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard
    // termination signal (SIGKILL) to the container and after cleanup, remove the pod from the
    // API. In the presence of network partitions, this object may still exist after this
    // timestamp, until an administrator or automated process can determine the resource is
    // fully terminated.
    // If not set, graceful deletion of the object has not been requested.
    // 
    // Populated by the system when a graceful deletion is requested.
    // Read-only.  
    // +optional
    optional Time deletionTimestamp = 5;

    // Number of seconds allowed for this object to gracefully terminate before
    // it will be removed from the system. Only set when deletionTimestamp is also set.
    // May only be shortened.
    // Read-only.
    // +optional
    optional int64 deletionGracePeriodSeconds = 6;

    // Map of string keys and values that can be used to organize and categorize
    // (scope and select) objects. May match selectors of replication controllers
    // and services.  
    // +optional
    map<string, string> labels = 7;

    // Annotations is an unstructured key value map stored with a resource that may be
    // set by external tools to store and retrieve arbitrary metadata. They are not
    // queryable and should be preserved when modifying objects.  
    // +optional
    map<string, string> annotations = 8;

}

message Host {
    // Standard object metadata.
    ObjectMeta metadata = 1;

    // Computed host ID, unique for each Host. It's being used
    // by virtuals to access remote volumes.
    uint32 id = 2;    

    // Current host status
    bool active = 3;    

    // Host address where client should connect to
    string address = 4;

    // Host port where client should connect to
    int32 port = 5;
}

message Volume {
    // Standard object metadata.
    ObjectMeta metadata = 1;

    // Volume size in Gigabytes, applies for presentation, 
    // master and replica volume specs.
    uint64 size = 2;

    // Specification of the desired behaviour of the presentation volume 
    // (which is available for filesystem to mount)
    PresentationSpec presentation = 3;

    // Specification of the desired behavior of the master volume.    
    VolumeSpec master = 4;

    // Specification of the desired behavior of the replica volumes.
    repeated VolumeSpec replicas = 5;
}

enum VolumeStatus {
    UNKNOWN = 0;
    PENDING = 1;
    ACTIVE = 2;
    UNAVAILABLE = 3;
    FAILED = 4;
    DELETING = 5;
}

enum VolumeReadiness {
    UNKNOWN = 0;
    PENDING = 1;
    READY = 2;
}

// NOTE: maybe readiness and health could be merged into one?
// This is actually mostly used by controlplane to track when replica 
// volume has finished syncronised, maybe dataplane doesn't care about it?
enum VolumeHealth {
    UNKNOWN = 0;
    SYNCHRONISING = 1;
    HEALTHY = 2;
    SUSPECT = 3;
    DEGRADED = 4;
    FAILED = 5;
}

message PresentationSpec {    

    // Device number, used to distinguish NBD devices
    int32 deviceNumber = 1;    

    // Desired volume status, updated by the scheduler in controlplane.
    // Usually volumes are created with PENDING status until they get scheduled 
    // and active status is set. Volume should still wait for readiness status 
    // to be changed to "READY"
    VolumeStatus status = 2;

    // Volume readiness is used to inform dataplane when volume should start letting 
    // data through. If the volume is active but readiness is not READY - volume
    // should not accept writes. By design READY will only be set for the presentation 
    // once master and all replicas are consumed by the dataplane.
    VolumeReadiness readiness = 3;

    // Volume health shows the most recent observed/interpreted health status
    // of the volume. Desired health value is HEALTHY but can be in SYNCRONISING 
    // often as well.
    VolumeHealth health = 4;

    // Number of mounts this volume had. It increases with
    // every single mount through the StorageOS API and the main reason
    // behind it as resetting cache.
    int32 mounts = 5;
}

message VolumeSpec {

    // Volume ID also known as Inode.
    int32 id = 1;

    // Desired volume status, updated by the scheduler in controlplane.
    // Usually volumes are created with PENDING status until they get scheduled 
    // and active status is set. Volume should still wait for readiness status 
    // to be changed to "READY".
    VolumeStatus status = 2;        

    // Computed host ID, unique for each Host. Is used to
    // send data through virtual volumes.
    uint32 host = 4;

}