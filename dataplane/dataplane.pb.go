// Code generated by protoc-gen-go. DO NOT EDIT.
// source: dataplane.proto

/*
Package dataplane is a generated protocol buffer package.

It is generated from these files:
	dataplane.proto

It has these top-level messages:
	NodeConfiguration
	ObjectMeta
	Host
	Volume
	PresentationSpec
	VolumeSpec
*/
package dataplane

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type PresentationSpec_VolumeReadiness int32

const (
	PresentationSpec_READINESS_UNKNOWN PresentationSpec_VolumeReadiness = 0
	PresentationSpec_READINESS_PENDING PresentationSpec_VolumeReadiness = 1
	PresentationSpec_READINESS_READY   PresentationSpec_VolumeReadiness = 2
)

var PresentationSpec_VolumeReadiness_name = map[int32]string{
	0: "READINESS_UNKNOWN",
	1: "READINESS_PENDING",
	2: "READINESS_READY",
}
var PresentationSpec_VolumeReadiness_value = map[string]int32{
	"READINESS_UNKNOWN": 0,
	"READINESS_PENDING": 1,
	"READINESS_READY":   2,
}

func (x PresentationSpec_VolumeReadiness) String() string {
	return proto.EnumName(PresentationSpec_VolumeReadiness_name, int32(x))
}
func (PresentationSpec_VolumeReadiness) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

// Note that enum values use C++ scoping rules, meaning that enum values are
// siblings of their type, not children of it.  Therefore, "UNKNOWN" must be unique
// within "dataplane.VolumeSpec", not just within "VolumeHealth".
type VolumeSpec_VolumeStatus int32

const (
	VolumeSpec_STATUS_UNKNOWN     VolumeSpec_VolumeStatus = 0
	VolumeSpec_STATUS_PENDING     VolumeSpec_VolumeStatus = 1
	VolumeSpec_STATUS_ACTIVE      VolumeSpec_VolumeStatus = 2
	VolumeSpec_STATUS_UNAVAILABLE VolumeSpec_VolumeStatus = 3
	VolumeSpec_STATUS_FAILED      VolumeSpec_VolumeStatus = 4
	VolumeSpec_STATUS_DELETING    VolumeSpec_VolumeStatus = 5
)

var VolumeSpec_VolumeStatus_name = map[int32]string{
	0: "STATUS_UNKNOWN",
	1: "STATUS_PENDING",
	2: "STATUS_ACTIVE",
	3: "STATUS_UNAVAILABLE",
	4: "STATUS_FAILED",
	5: "STATUS_DELETING",
}
var VolumeSpec_VolumeStatus_value = map[string]int32{
	"STATUS_UNKNOWN":     0,
	"STATUS_PENDING":     1,
	"STATUS_ACTIVE":      2,
	"STATUS_UNAVAILABLE": 3,
	"STATUS_FAILED":      4,
	"STATUS_DELETING":    5,
}

func (x VolumeSpec_VolumeStatus) String() string {
	return proto.EnumName(VolumeSpec_VolumeStatus_name, int32(x))
}
func (VolumeSpec_VolumeStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type VolumeSpec_VolumeHealth int32

const (
	VolumeSpec_HEALTH_UNKNOWN       VolumeSpec_VolumeHealth = 0
	VolumeSpec_HEALTH_SYNCHRONISING VolumeSpec_VolumeHealth = 1
	VolumeSpec_HEALTH_HEALTHY       VolumeSpec_VolumeHealth = 2
	VolumeSpec_HEALTH_SUSPECT       VolumeSpec_VolumeHealth = 3
	VolumeSpec_HEALTH_DEGRADED      VolumeSpec_VolumeHealth = 4
	VolumeSpec_HEALTH_FAILED        VolumeSpec_VolumeHealth = 5
)

var VolumeSpec_VolumeHealth_name = map[int32]string{
	0: "HEALTH_UNKNOWN",
	1: "HEALTH_SYNCHRONISING",
	2: "HEALTH_HEALTHY",
	3: "HEALTH_SUSPECT",
	4: "HEALTH_DEGRADED",
	5: "HEALTH_FAILED",
}
var VolumeSpec_VolumeHealth_value = map[string]int32{
	"HEALTH_UNKNOWN":       0,
	"HEALTH_SYNCHRONISING": 1,
	"HEALTH_HEALTHY":       2,
	"HEALTH_SUSPECT":       3,
	"HEALTH_DEGRADED":      4,
	"HEALTH_FAILED":        5,
}

func (x VolumeSpec_VolumeHealth) String() string {
	return proto.EnumName(VolumeSpec_VolumeHealth_name, int32(x))
}
func (VolumeSpec_VolumeHealth) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 1} }

type NodeConfiguration struct {
	// Computed host ID, unique for each Host. Is used to
	// send data through virtual volumes.
	Host uint32 `protobuf:"varint,4,opt,name=host" json:"host,omitempty"`
}

func (m *NodeConfiguration) Reset()                    { *m = NodeConfiguration{} }
func (m *NodeConfiguration) String() string            { return proto.CompactTextString(m) }
func (*NodeConfiguration) ProtoMessage()               {}
func (*NodeConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *NodeConfiguration) GetHost() uint32 {
	if m != nil {
		return m.Host
	}
	return 0
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
type ObjectMeta struct {
	// Name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// UID is the unique in time and space value for this object. It is typically generated by
	// the server on successful creation of a resource and is not allowed to change on PUT
	// operations.
	//
	// Populated by the system.
	// Read-only.
	// +optional
	Uid string `protobuf:"bytes,2,opt,name=uid" json:"uid,omitempty"`
	// An opaque value that represents the internal version of this object that can
	// be used by clients to determine when objects have changed. May be used for optimistic
	// concurrency, change detection, and the watch operation on a resource or set of resources.
	// Clients must treat these values as opaque and passed unmodified back to the server.
	// They may only be valid for a particular resource or set of resources.
	//
	// Populated by the system.
	// Read-only.
	// Value must be treated as opaque by clients and .
	// +optional
	ResourceVersion string `protobuf:"bytes,3,opt,name=resourceVersion" json:"resourceVersion,omitempty"`
	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	//
	// Populated by the system.
	// Read-only.
	// Null for lists.
	// +optional
	CreationTimestamp *google_protobuf.Timestamp `protobuf:"bytes,4,opt,name=creationTimestamp" json:"creationTimestamp,omitempty"`
	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field. Once set,
	// this value may not be unset or be set further into the future, although it may be shortened
	// or the resource may be deleted prior to this time. For example, a user may request that
	// a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination
	// signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard
	// termination signal (SIGKILL) to the container and after cleanup, remove the pod from the
	// API. In the presence of network partitions, this object may still exist after this
	// timestamp, until an administrator or automated process can determine the resource is
	// fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	// +optional
	DeletionTimestamp *google_protobuf.Timestamp `protobuf:"bytes,5,opt,name=deletionTimestamp" json:"deletionTimestamp,omitempty"`
	// Number of seconds allowed for this object to gracefully terminate before
	// it will be removed from the system. Only set when deletionTimestamp is also set.
	// May only be shortened.
	// Read-only.
	// +optional
	DeletionGracePeriodSeconds int64 `protobuf:"varint,6,opt,name=deletionGracePeriodSeconds" json:"deletionGracePeriodSeconds,omitempty"`
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// +optional
	Labels map[string]string `protobuf:"bytes,7,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// +optional
	Annotations map[string]string `protobuf:"bytes,8,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ObjectMeta) Reset()                    { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string            { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()               {}
func (*ObjectMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ObjectMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectMeta) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectMeta) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *ObjectMeta) GetCreationTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

func (m *ObjectMeta) GetDeletionTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.DeletionTimestamp
	}
	return nil
}

func (m *ObjectMeta) GetDeletionGracePeriodSeconds() int64 {
	if m != nil {
		return m.DeletionGracePeriodSeconds
	}
	return 0
}

func (m *ObjectMeta) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ObjectMeta) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

type Host struct {
	// Standard object metadata.
	Metadata *ObjectMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Computed host ID, unique for each Host. It's being used
	// by virtuals to access remote volumes.
	Id uint32 `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	// Current host status
	Active bool `protobuf:"varint,3,opt,name=active" json:"active,omitempty"`
	// Host address where client should connect to
	Address string `protobuf:"bytes,4,opt,name=address" json:"address,omitempty"`
	// Host port where client should connect to
	Port int32 `protobuf:"varint,5,opt,name=port" json:"port,omitempty"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Host) GetMetadata() *ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Host) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Host) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Host) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Host) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Volume struct {
	// Standard object metadata.
	Metadata *ObjectMeta `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Volume size in Gigabytes, applies for presentation,
	// master and replica volume specs.
	Size uint64 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	// Specification of the desired behaviour of the presentation volume
	// (which is available for filesystem to mount)
	Presentation *PresentationSpec `protobuf:"bytes,3,opt,name=presentation" json:"presentation,omitempty"`
	// Specification of the desired behavior of the master volume.
	Master *VolumeSpec `protobuf:"bytes,4,opt,name=master" json:"master,omitempty"`
	// Specification of the desired behavior of the replica volumes.
	Replicas []*VolumeSpec `protobuf:"bytes,5,rep,name=replicas" json:"replicas,omitempty"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Volume) GetMetadata() *ObjectMeta {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Volume) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *Volume) GetPresentation() *PresentationSpec {
	if m != nil {
		return m.Presentation
	}
	return nil
}

func (m *Volume) GetMaster() *VolumeSpec {
	if m != nil {
		return m.Master
	}
	return nil
}

func (m *Volume) GetReplicas() []*VolumeSpec {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type PresentationSpec struct {
	// Volume ID also known as Inode.
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Device number, used to distinguish NBD devices
	DeviceNumber uint32 `protobuf:"varint,2,opt,name=deviceNumber" json:"deviceNumber,omitempty"`
	// Volume readiness is used to inform dataplane when volume should start letting
	// data through. If the volume is active but readiness is not READY - volume
	// should not accept writes. By design READY will only be set for the presentation
	// once master and all replicas are consumed by the dataplane.
	Readiness PresentationSpec_VolumeReadiness `protobuf:"varint,3,opt,name=readiness,enum=dataplane.PresentationSpec_VolumeReadiness" json:"readiness,omitempty"`
	// Number of mounts this volume had. It increases with
	// every single mount through the StorageOS API and the main reason
	// behind it as resetting cache.
	Mounts int32 `protobuf:"varint,4,opt,name=mounts" json:"mounts,omitempty"`
}

func (m *PresentationSpec) Reset()                    { *m = PresentationSpec{} }
func (m *PresentationSpec) String() string            { return proto.CompactTextString(m) }
func (*PresentationSpec) ProtoMessage()               {}
func (*PresentationSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PresentationSpec) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *PresentationSpec) GetDeviceNumber() uint32 {
	if m != nil {
		return m.DeviceNumber
	}
	return 0
}

func (m *PresentationSpec) GetReadiness() PresentationSpec_VolumeReadiness {
	if m != nil {
		return m.Readiness
	}
	return PresentationSpec_READINESS_UNKNOWN
}

func (m *PresentationSpec) GetMounts() int32 {
	if m != nil {
		return m.Mounts
	}
	return 0
}

type VolumeSpec struct {
	// Volume ID also known as Inode.
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Desired volume status, updated by the scheduler in controlplane.
	// Usually volumes are created with PENDING status until they get scheduled
	// and active status is set. Volume should still wait for readiness status
	// to be changed to "READY".
	Status VolumeSpec_VolumeStatus `protobuf:"varint,2,opt,name=status,enum=dataplane.VolumeSpec_VolumeStatus" json:"status,omitempty"`
	// Volume health shows the most recent observed/interpreted health status
	// of the volume. Desired health value is HEALTHY but can be in SYNCRONISING
	// often as well.
	Health VolumeSpec_VolumeHealth `protobuf:"varint,3,opt,name=health,enum=dataplane.VolumeSpec_VolumeHealth" json:"health,omitempty"`
	// Computed host ID, unique for each Host. Is used to
	// send data through virtual volumes.
	Host uint32 `protobuf:"varint,4,opt,name=host" json:"host,omitempty"`
}

func (m *VolumeSpec) Reset()                    { *m = VolumeSpec{} }
func (m *VolumeSpec) String() string            { return proto.CompactTextString(m) }
func (*VolumeSpec) ProtoMessage()               {}
func (*VolumeSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *VolumeSpec) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *VolumeSpec) GetStatus() VolumeSpec_VolumeStatus {
	if m != nil {
		return m.Status
	}
	return VolumeSpec_STATUS_UNKNOWN
}

func (m *VolumeSpec) GetHealth() VolumeSpec_VolumeHealth {
	if m != nil {
		return m.Health
	}
	return VolumeSpec_HEALTH_UNKNOWN
}

func (m *VolumeSpec) GetHost() uint32 {
	if m != nil {
		return m.Host
	}
	return 0
}

func init() {
	proto.RegisterType((*NodeConfiguration)(nil), "dataplane.NodeConfiguration")
	proto.RegisterType((*ObjectMeta)(nil), "dataplane.ObjectMeta")
	proto.RegisterType((*Host)(nil), "dataplane.Host")
	proto.RegisterType((*Volume)(nil), "dataplane.Volume")
	proto.RegisterType((*PresentationSpec)(nil), "dataplane.PresentationSpec")
	proto.RegisterType((*VolumeSpec)(nil), "dataplane.VolumeSpec")
	proto.RegisterEnum("dataplane.PresentationSpec_VolumeReadiness", PresentationSpec_VolumeReadiness_name, PresentationSpec_VolumeReadiness_value)
	proto.RegisterEnum("dataplane.VolumeSpec_VolumeStatus", VolumeSpec_VolumeStatus_name, VolumeSpec_VolumeStatus_value)
	proto.RegisterEnum("dataplane.VolumeSpec_VolumeHealth", VolumeSpec_VolumeHealth_name, VolumeSpec_VolumeHealth_value)
}

func init() { proto.RegisterFile("dataplane.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 788 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xc6, 0xf9, 0xdb, 0xf6, 0xa4, 0x4d, 0x9d, 0x61, 0x77, 0x65, 0x85, 0x0b, 0x8a, 0x2f, 0x20,
	0x12, 0x22, 0x2b, 0xc2, 0x0d, 0xbb, 0x17, 0x8b, 0x4c, 0x63, 0x9a, 0x88, 0xe0, 0x56, 0xe3, 0xb4,
	0xa8, 0x57, 0x68, 0x62, 0x9f, 0x6d, 0x0d, 0x8e, 0x27, 0xf2, 0x8c, 0x2b, 0x95, 0x37, 0x40, 0x42,
	0xe2, 0x55, 0x78, 0x07, 0xde, 0x88, 0x17, 0x00, 0xcd, 0x78, 0x12, 0xbb, 0x6d, 0x28, 0x82, 0x2b,
	0x9f, 0xf9, 0xe6, 0xfb, 0xce, 0x7c, 0xe7, 0x47, 0x86, 0xa3, 0x98, 0x49, 0xb6, 0x4e, 0x59, 0x86,
	0xa3, 0x75, 0xce, 0x25, 0x27, 0xfb, 0x5b, 0x60, 0xf0, 0xe1, 0x35, 0xe7, 0xd7, 0x29, 0xbe, 0xd2,
	0x17, 0xcb, 0xe2, 0xdd, 0x2b, 0x99, 0xac, 0x50, 0x48, 0xb6, 0x5a, 0x97, 0x5c, 0xf7, 0x13, 0xe8,
	0x07, 0x3c, 0xc6, 0x13, 0x9e, 0xbd, 0x4b, 0xae, 0x8b, 0x9c, 0xc9, 0x84, 0x67, 0x84, 0x40, 0xeb,
	0x86, 0x0b, 0xe9, 0xb4, 0x8e, 0xad, 0xe1, 0x21, 0xd5, 0xb1, 0xfb, 0x7b, 0x0b, 0xe0, 0x6c, 0xf9,
	0x23, 0x46, 0xf2, 0x3b, 0x94, 0x4c, 0x51, 0x32, 0xb6, 0x42, 0xc7, 0x3a, 0xb6, 0x86, 0xfb, 0x54,
	0xc7, 0xc4, 0x86, 0x66, 0x91, 0xc4, 0x4e, 0x43, 0x43, 0x2a, 0x24, 0x43, 0x38, 0xca, 0x51, 0xf0,
	0x22, 0x8f, 0xf0, 0x12, 0x73, 0x91, 0xf0, 0xcc, 0x69, 0xea, 0xdb, 0x87, 0x30, 0x99, 0x42, 0x3f,
	0xca, 0x51, 0x3f, 0xbf, 0xd8, 0x58, 0xd4, 0xef, 0x77, 0xc7, 0x83, 0x51, 0x59, 0xc4, 0x68, 0x53,
	0xc4, 0x68, 0xcb, 0xa0, 0x8f, 0x45, 0x2a, 0x53, 0x8c, 0x29, 0xde, 0xcf, 0xd4, 0xfe, 0xf7, 0x4c,
	0x8f, 0x44, 0xe4, 0x2d, 0x0c, 0x36, 0xe0, 0x69, 0xce, 0x22, 0x3c, 0xc7, 0x3c, 0xe1, 0x71, 0x88,
	0x11, 0xcf, 0x62, 0xe1, 0x74, 0x8e, 0xad, 0x61, 0x93, 0x3e, 0xc1, 0x20, 0xaf, 0xa1, 0x93, 0xb2,
	0x25, 0xa6, 0xc2, 0x79, 0x76, 0xdc, 0x1c, 0x76, 0xc7, 0x1f, 0x8d, 0xaa, 0x49, 0x55, 0xad, 0x1c,
	0xcd, 0x35, 0xc7, 0xcf, 0x64, 0x7e, 0x47, 0x8d, 0x80, 0x4c, 0xa1, 0xcb, 0xb2, 0x8c, 0x4b, 0x5d,
	0x9b, 0x70, 0xf6, 0xb4, 0xfe, 0xe3, 0xdd, 0x7a, 0xaf, 0x22, 0x96, 0x49, 0xea, 0xd2, 0xc1, 0x6b,
	0xe8, 0xd6, 0x1e, 0x50, 0x33, 0xfa, 0x09, 0xef, 0xcc, 0xd8, 0x54, 0x48, 0x9e, 0x43, 0xfb, 0x96,
	0xa5, 0x05, 0x9a, 0xb9, 0x95, 0x87, 0x37, 0x8d, 0x2f, 0xad, 0xc1, 0x5b, 0xb0, 0x1f, 0xe6, 0xfe,
	0x2f, 0x7a, 0xf7, 0x37, 0x0b, 0x5a, 0x53, 0x2e, 0x24, 0xf9, 0x1c, 0xf6, 0x56, 0x28, 0x99, 0x72,
	0xaf, 0x95, 0xdd, 0xf1, 0x8b, 0x9d, 0xa5, 0xd0, 0x2d, 0x8d, 0xf4, 0xa0, 0x61, 0x56, 0xe9, 0x90,
	0x36, 0x92, 0x98, 0xbc, 0x84, 0x0e, 0x8b, 0x64, 0x72, 0x8b, 0x7a, 0x81, 0xf6, 0xa8, 0x39, 0x11,
	0x07, 0x9e, 0xb1, 0x38, 0xce, 0x51, 0x08, 0xbd, 0x2d, 0xfb, 0x74, 0x73, 0x54, 0x1b, 0xba, 0xe6,
	0xb9, 0xd4, 0xa3, 0x6f, 0x53, 0x1d, 0xbb, 0x7f, 0x5a, 0xd0, 0xb9, 0xe4, 0x69, 0xb1, 0xc2, 0xff,
	0xe3, 0x89, 0x40, 0x4b, 0x24, 0x3f, 0x97, 0x85, 0xb6, 0xa8, 0x8e, 0xc9, 0x57, 0x70, 0xb0, 0xce,
	0x51, 0x60, 0x56, 0x76, 0x49, 0xbb, 0xeb, 0x8e, 0x3f, 0xa8, 0xa5, 0x3a, 0xaf, 0x5d, 0x87, 0x6b,
	0x8c, 0xe8, 0x3d, 0x01, 0xf9, 0x0c, 0x3a, 0x2b, 0x26, 0x24, 0xe6, 0x66, 0xdb, 0xeb, 0x2e, 0x4a,
	0xab, 0x5a, 0x64, 0x48, 0xca, 0x76, 0x8e, 0xeb, 0x34, 0x89, 0x98, 0x70, 0xda, 0x7a, 0x2b, 0xfe,
	0x41, 0xb0, 0xa5, 0xb9, 0x7f, 0x59, 0x60, 0x3f, 0x34, 0x61, 0xfa, 0x6b, 0x6d, 0xfb, 0xeb, 0xc2,
	0x41, 0x8c, 0xb7, 0x49, 0x84, 0x41, 0xb1, 0x5a, 0x62, 0x6e, 0x3a, 0x7f, 0x0f, 0x23, 0x33, 0xd8,
	0xcf, 0x91, 0xc5, 0x49, 0xa6, 0xba, 0xad, 0x0a, 0xed, 0x8d, 0x3f, 0x7d, 0xa2, 0x50, 0xe3, 0x86,
	0x6e, 0x24, 0xb4, 0x52, 0xab, 0x71, 0xae, 0x78, 0x91, 0xc9, 0x72, 0x6a, 0x6d, 0x6a, 0x4e, 0xee,
	0x02, 0x8e, 0x1e, 0xa8, 0xc8, 0x0b, 0xe8, 0x53, 0xdf, 0x9b, 0xcc, 0x02, 0x3f, 0x0c, 0x7f, 0xb8,
	0x08, 0xbe, 0x0d, 0xce, 0xbe, 0x0f, 0xec, 0xf7, 0xee, 0xc3, 0xe7, 0x7e, 0x30, 0x99, 0x05, 0xa7,
	0xb6, 0x45, 0xde, 0x87, 0xa3, 0x0a, 0x56, 0xd1, 0x95, 0xdd, 0x70, 0xff, 0x68, 0x02, 0x54, 0xad,
	0x79, 0x54, 0xfb, 0x1b, 0xe8, 0x08, 0xc9, 0x64, 0x21, 0x74, 0xd5, 0xbd, 0xb1, 0xbb, 0xb3, 0xa3,
	0x9b, 0x50, 0x33, 0xa9, 0x51, 0x28, 0xed, 0x0d, 0xb2, 0x54, 0xde, 0x98, 0x86, 0x3c, 0xa9, 0x9d,
	0x6a, 0x26, 0x35, 0x8a, 0x9d, 0xbf, 0xd9, 0x5f, 0x2c, 0x38, 0xa8, 0x3f, 0x44, 0x08, 0xf4, 0xc2,
	0x85, 0xb7, 0xb8, 0xa8, 0xd7, 0x5e, 0x61, 0x55, 0xe1, 0x7d, 0x38, 0x34, 0x98, 0x77, 0xb2, 0x98,
	0x5d, 0xfa, 0x76, 0x83, 0xbc, 0x04, 0xb2, 0x95, 0x7a, 0x97, 0xde, 0x6c, 0xee, 0x7d, 0x3d, 0xf7,
	0xed, 0x66, 0x8d, 0xfa, 0x8d, 0x37, 0x9b, 0xfb, 0x13, 0xbb, 0xa5, 0xda, 0x66, 0xa0, 0x89, 0x3f,
	0xf7, 0x17, 0x2a, 0x65, 0xdb, 0xfd, 0x75, 0xeb, 0x65, 0xba, 0x31, 0xdc, 0x9b, 0xfa, 0xde, 0x7c,
	0x31, 0xad, 0x79, 0x71, 0xe0, 0xb9, 0xc1, 0xc2, 0xab, 0xe0, 0x64, 0x4a, 0xcf, 0x82, 0x59, 0x58,
	0x3a, 0xaa, 0xd8, 0xe5, 0xe7, 0xca, 0x6e, 0xd4, 0xb0, 0xf0, 0x22, 0x3c, 0xf7, 0x4f, 0x16, 0x76,
	0x53, 0xbd, 0x6d, 0xb0, 0x89, 0x7f, 0x4a, 0xbd, 0x89, 0x36, 0xd4, 0x87, 0x43, 0x03, 0x1a, 0x8f,
	0xed, 0x65, 0x47, 0xff, 0xb5, 0xbf, 0xf8, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xf2, 0x16, 0x7b, 0xbd,
	0xf0, 0x06, 0x00, 0x00,
}
