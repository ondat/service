// Code generated by protoc-gen-go. DO NOT EDIT.
// source: directfs.proto

/*
Package storageos_rpc is a generated protocol buffer package.

It is generated from these files:
	directfs.proto

It has these top-level messages:
	DfsHostCredentials
	DfsHost
	DfsHostListQuery
	DfsVolumeCredentials
	DfsVolumeStats
	DfsVolume
	DfsVolumeListQuery
*/
package storageos_rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import storageos_rpc1 "."

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DfsHostCredentials struct {
}

func (m *DfsHostCredentials) Reset()                    { *m = DfsHostCredentials{} }
func (m *DfsHostCredentials) String() string            { return proto.CompactTextString(m) }
func (*DfsHostCredentials) ProtoMessage()               {}
func (*DfsHostCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// *
// A host used by DirectFS.
type DfsHost struct {
	Cc *storageos_rpc1.DataplaneCommonConfig `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The unique host identifier.
	HostId uint32 `protobuf:"varint,2,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	// The remote hostname.
	Hostname string `protobuf:"bytes,3,opt,name=hostname" json:"hostname,omitempty"`
	// The remote port.
	Port uint32 `protobuf:"varint,4,opt,name=port" json:"port,omitempty"`
	// Host credentials.
	Credentials *DfsHostCredentials `protobuf:"bytes,5,opt,name=credentials" json:"credentials,omitempty"`
}

func (m *DfsHost) Reset()                    { *m = DfsHost{} }
func (m *DfsHost) String() string            { return proto.CompactTextString(m) }
func (*DfsHost) ProtoMessage()               {}
func (*DfsHost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DfsHost) GetCc() *storageos_rpc1.DataplaneCommonConfig {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *DfsHost) GetHostId() uint32 {
	if m != nil {
		return m.HostId
	}
	return 0
}

func (m *DfsHost) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *DfsHost) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *DfsHost) GetCredentials() *DfsHostCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type DfsHostListQuery struct {
	// An optional list of hosts to query.
	HostIds []*DfsHost `protobuf:"bytes,1,rep,name=host_ids,json=hostIds" json:"host_ids,omitempty"`
}

func (m *DfsHostListQuery) Reset()                    { *m = DfsHostListQuery{} }
func (m *DfsHostListQuery) String() string            { return proto.CompactTextString(m) }
func (*DfsHostListQuery) ProtoMessage()               {}
func (*DfsHostListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DfsHostListQuery) GetHostIds() []*DfsHost {
	if m != nil {
		return m.HostIds
	}
	return nil
}

type DfsVolumeCredentials struct {
}

func (m *DfsVolumeCredentials) Reset()                    { *m = DfsVolumeCredentials{} }
func (m *DfsVolumeCredentials) String() string            { return proto.CompactTextString(m) }
func (*DfsVolumeCredentials) ProtoMessage()               {}
func (*DfsVolumeCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type DfsVolumeStats struct {
}

func (m *DfsVolumeStats) Reset()                    { *m = DfsVolumeStats{} }
func (m *DfsVolumeStats) String() string            { return proto.CompactTextString(m) }
func (*DfsVolumeStats) ProtoMessage()               {}
func (*DfsVolumeStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// *
// A volume used by DirectFS.
//
// The remote host (for the client) isn't directly included here. However, the
// client clearly can't connect without a properly configured host_id item.
//
// The split between host and volume objects was decided based on now-irrelevant
// implementation details of ConfigFS v1. However, there's still some logic to
// it if the authentication (especially TLS) is per-host rather than per-volume.
type DfsVolume struct {
	Cc *storageos_rpc1.DataplaneCommonConfig `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The volume ID.
	VolumeId uint32 `protobuf:"varint,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The host for this volume.
	HostId uint32 `protobuf:"varint,3,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	// Volume credentials.
	Credentials *DfsVolumeCredentials `protobuf:"bytes,4,opt,name=credentials" json:"credentials,omitempty"`
	// Volume statistics.
	Stats *DfsVolumeStats `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
}

func (m *DfsVolume) Reset()                    { *m = DfsVolume{} }
func (m *DfsVolume) String() string            { return proto.CompactTextString(m) }
func (*DfsVolume) ProtoMessage()               {}
func (*DfsVolume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DfsVolume) GetCc() *storageos_rpc1.DataplaneCommonConfig {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *DfsVolume) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *DfsVolume) GetHostId() uint32 {
	if m != nil {
		return m.HostId
	}
	return 0
}

func (m *DfsVolume) GetCredentials() *DfsVolumeCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *DfsVolume) GetStats() *DfsVolumeStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type DfsVolumeListQuery struct {
	// An optional list of volumes to query.
	VolumeIds []*DfsVolume `protobuf:"bytes,1,rep,name=volume_ids,json=volumeIds" json:"volume_ids,omitempty"`
}

func (m *DfsVolumeListQuery) Reset()                    { *m = DfsVolumeListQuery{} }
func (m *DfsVolumeListQuery) String() string            { return proto.CompactTextString(m) }
func (*DfsVolumeListQuery) ProtoMessage()               {}
func (*DfsVolumeListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DfsVolumeListQuery) GetVolumeIds() []*DfsVolume {
	if m != nil {
		return m.VolumeIds
	}
	return nil
}

func init() {
	proto.RegisterType((*DfsHostCredentials)(nil), "storageos_rpc.DfsHostCredentials")
	proto.RegisterType((*DfsHost)(nil), "storageos_rpc.DfsHost")
	proto.RegisterType((*DfsHostListQuery)(nil), "storageos_rpc.DfsHostListQuery")
	proto.RegisterType((*DfsVolumeCredentials)(nil), "storageos_rpc.DfsVolumeCredentials")
	proto.RegisterType((*DfsVolumeStats)(nil), "storageos_rpc.DfsVolumeStats")
	proto.RegisterType((*DfsVolume)(nil), "storageos_rpc.DfsVolume")
	proto.RegisterType((*DfsVolumeListQuery)(nil), "storageos_rpc.DfsVolumeListQuery")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DirectfsClientConfig service

type DirectfsClientConfigClient interface {
	// *
	// Add a remote host entry to be used by volumes.
	//
	// returns RpcResult
	ServerConfigure(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Remove a remote host entry.
	//
	// This will likely result in any volumes using this host to
	// become unconfigured. That has serious consequences.
	//
	// returns RpcResult
	ServerUnconfigure(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// List configured host entries, optionally filtered via a DfsHostListQuery
	// message.
	//
	// returns a stream of DfsHost messages, if any are available matching the filter.
	ServerList(ctx context.Context, in *DfsHostListQuery, opts ...grpc.CallOption) (DirectfsClientConfig_ServerListClient, error)
	// *
	// Configure a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeConfigure(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Unconfigure a volume previously configured by VolumeConfigure.
	//
	// returns RpcResult
	VolumeUnconfigure(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns a stream of DfsVolume messages, if any are available matching the filter.
	VolumeList(ctx context.Context, in *DfsVolumeListQuery, opts ...grpc.CallOption) (DirectfsClientConfig_VolumeListClient, error)
}

type directfsClientConfigClient struct {
	cc *grpc.ClientConn
}

func NewDirectfsClientConfigClient(cc *grpc.ClientConn) DirectfsClientConfigClient {
	return &directfsClientConfigClient{cc}
}

func (c *directfsClientConfigClient) ServerConfigure(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.DirectfsClientConfig/ServerConfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directfsClientConfigClient) ServerUnconfigure(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.DirectfsClientConfig/ServerUnconfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directfsClientConfigClient) ServerList(ctx context.Context, in *DfsHostListQuery, opts ...grpc.CallOption) (DirectfsClientConfig_ServerListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DirectfsClientConfig_serviceDesc.Streams[0], c.cc, "/storageos_rpc.DirectfsClientConfig/ServerList", opts...)
	if err != nil {
		return nil, err
	}
	x := &directfsClientConfigServerListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DirectfsClientConfig_ServerListClient interface {
	Recv() (*DfsHost, error)
	grpc.ClientStream
}

type directfsClientConfigServerListClient struct {
	grpc.ClientStream
}

func (x *directfsClientConfigServerListClient) Recv() (*DfsHost, error) {
	m := new(DfsHost)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *directfsClientConfigClient) VolumeConfigure(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.DirectfsClientConfig/VolumeConfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directfsClientConfigClient) VolumeUnconfigure(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.DirectfsClientConfig/VolumeUnconfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directfsClientConfigClient) VolumeList(ctx context.Context, in *DfsVolumeListQuery, opts ...grpc.CallOption) (DirectfsClientConfig_VolumeListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DirectfsClientConfig_serviceDesc.Streams[1], c.cc, "/storageos_rpc.DirectfsClientConfig/VolumeList", opts...)
	if err != nil {
		return nil, err
	}
	x := &directfsClientConfigVolumeListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DirectfsClientConfig_VolumeListClient interface {
	Recv() (*DfsVolume, error)
	grpc.ClientStream
}

type directfsClientConfigVolumeListClient struct {
	grpc.ClientStream
}

func (x *directfsClientConfigVolumeListClient) Recv() (*DfsVolume, error) {
	m := new(DfsVolume)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DirectfsClientConfig service

type DirectfsClientConfigServer interface {
	// *
	// Add a remote host entry to be used by volumes.
	//
	// returns RpcResult
	ServerConfigure(context.Context, *DfsHost) (*storageos_rpc1.RpcResult, error)
	// *
	// Remove a remote host entry.
	//
	// This will likely result in any volumes using this host to
	// become unconfigured. That has serious consequences.
	//
	// returns RpcResult
	ServerUnconfigure(context.Context, *DfsHost) (*storageos_rpc1.RpcResult, error)
	// *
	// List configured host entries, optionally filtered via a DfsHostListQuery
	// message.
	//
	// returns a stream of DfsHost messages, if any are available matching the filter.
	ServerList(*DfsHostListQuery, DirectfsClientConfig_ServerListServer) error
	// *
	// Configure a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeConfigure(context.Context, *DfsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// Unconfigure a volume previously configured by VolumeConfigure.
	//
	// returns RpcResult
	VolumeUnconfigure(context.Context, *DfsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns a stream of DfsVolume messages, if any are available matching the filter.
	VolumeList(*DfsVolumeListQuery, DirectfsClientConfig_VolumeListServer) error
}

func RegisterDirectfsClientConfigServer(s *grpc.Server, srv DirectfsClientConfigServer) {
	s.RegisterService(&_DirectfsClientConfig_serviceDesc, srv)
}

func _DirectfsClientConfig_ServerConfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectfsClientConfigServer).ServerConfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.DirectfsClientConfig/ServerConfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectfsClientConfigServer).ServerConfigure(ctx, req.(*DfsHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectfsClientConfig_ServerUnconfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectfsClientConfigServer).ServerUnconfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.DirectfsClientConfig/ServerUnconfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectfsClientConfigServer).ServerUnconfigure(ctx, req.(*DfsHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectfsClientConfig_ServerList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DfsHostListQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DirectfsClientConfigServer).ServerList(m, &directfsClientConfigServerListServer{stream})
}

type DirectfsClientConfig_ServerListServer interface {
	Send(*DfsHost) error
	grpc.ServerStream
}

type directfsClientConfigServerListServer struct {
	grpc.ServerStream
}

func (x *directfsClientConfigServerListServer) Send(m *DfsHost) error {
	return x.ServerStream.SendMsg(m)
}

func _DirectfsClientConfig_VolumeConfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectfsClientConfigServer).VolumeConfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.DirectfsClientConfig/VolumeConfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectfsClientConfigServer).VolumeConfigure(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectfsClientConfig_VolumeUnconfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectfsClientConfigServer).VolumeUnconfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.DirectfsClientConfig/VolumeUnconfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectfsClientConfigServer).VolumeUnconfigure(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectfsClientConfig_VolumeList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DfsVolumeListQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DirectfsClientConfigServer).VolumeList(m, &directfsClientConfigVolumeListServer{stream})
}

type DirectfsClientConfig_VolumeListServer interface {
	Send(*DfsVolume) error
	grpc.ServerStream
}

type directfsClientConfigVolumeListServer struct {
	grpc.ServerStream
}

func (x *directfsClientConfigVolumeListServer) Send(m *DfsVolume) error {
	return x.ServerStream.SendMsg(m)
}

var _DirectfsClientConfig_serviceDesc = grpc.ServiceDesc{
	ServiceName: "storageos_rpc.DirectfsClientConfig",
	HandlerType: (*DirectfsClientConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServerConfigure",
			Handler:    _DirectfsClientConfig_ServerConfigure_Handler,
		},
		{
			MethodName: "ServerUnconfigure",
			Handler:    _DirectfsClientConfig_ServerUnconfigure_Handler,
		},
		{
			MethodName: "VolumeConfigure",
			Handler:    _DirectfsClientConfig_VolumeConfigure_Handler,
		},
		{
			MethodName: "VolumeUnconfigure",
			Handler:    _DirectfsClientConfig_VolumeUnconfigure_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServerList",
			Handler:       _DirectfsClientConfig_ServerList_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VolumeList",
			Handler:       _DirectfsClientConfig_VolumeList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "directfs.proto",
}

// Client API for DirectfsServerConfig service

type DirectfsServerConfigClient interface {
	// *
	// Configure a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeConfigure(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Unconfigure a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeUnconfigure(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns a stream of DfsVolume messages, if any are available matching the filter.
	VolumeList(ctx context.Context, in *DfsVolumeListQuery, opts ...grpc.CallOption) (DirectfsServerConfig_VolumeListClient, error)
}

type directfsServerConfigClient struct {
	cc *grpc.ClientConn
}

func NewDirectfsServerConfigClient(cc *grpc.ClientConn) DirectfsServerConfigClient {
	return &directfsServerConfigClient{cc}
}

func (c *directfsServerConfigClient) VolumeConfigure(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.DirectfsServerConfig/VolumeConfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directfsServerConfigClient) VolumeUnconfigure(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.DirectfsServerConfig/VolumeUnconfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directfsServerConfigClient) VolumeList(ctx context.Context, in *DfsVolumeListQuery, opts ...grpc.CallOption) (DirectfsServerConfig_VolumeListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DirectfsServerConfig_serviceDesc.Streams[0], c.cc, "/storageos_rpc.DirectfsServerConfig/VolumeList", opts...)
	if err != nil {
		return nil, err
	}
	x := &directfsServerConfigVolumeListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DirectfsServerConfig_VolumeListClient interface {
	Recv() (*DfsVolume, error)
	grpc.ClientStream
}

type directfsServerConfigVolumeListClient struct {
	grpc.ClientStream
}

func (x *directfsServerConfigVolumeListClient) Recv() (*DfsVolume, error) {
	m := new(DfsVolume)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DirectfsServerConfig service

type DirectfsServerConfigServer interface {
	// *
	// Configure a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeConfigure(context.Context, *DfsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// Unconfigure a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeUnconfigure(context.Context, *DfsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns a stream of DfsVolume messages, if any are available matching the filter.
	VolumeList(*DfsVolumeListQuery, DirectfsServerConfig_VolumeListServer) error
}

func RegisterDirectfsServerConfigServer(s *grpc.Server, srv DirectfsServerConfigServer) {
	s.RegisterService(&_DirectfsServerConfig_serviceDesc, srv)
}

func _DirectfsServerConfig_VolumeConfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectfsServerConfigServer).VolumeConfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.DirectfsServerConfig/VolumeConfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectfsServerConfigServer).VolumeConfigure(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectfsServerConfig_VolumeUnconfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectfsServerConfigServer).VolumeUnconfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.DirectfsServerConfig/VolumeUnconfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectfsServerConfigServer).VolumeUnconfigure(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectfsServerConfig_VolumeList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DfsVolumeListQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DirectfsServerConfigServer).VolumeList(m, &directfsServerConfigVolumeListServer{stream})
}

type DirectfsServerConfig_VolumeListServer interface {
	Send(*DfsVolume) error
	grpc.ServerStream
}

type directfsServerConfigVolumeListServer struct {
	grpc.ServerStream
}

func (x *directfsServerConfigVolumeListServer) Send(m *DfsVolume) error {
	return x.ServerStream.SendMsg(m)
}

var _DirectfsServerConfig_serviceDesc = grpc.ServiceDesc{
	ServiceName: "storageos_rpc.DirectfsServerConfig",
	HandlerType: (*DirectfsServerConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VolumeConfigure",
			Handler:    _DirectfsServerConfig_VolumeConfigure_Handler,
		},
		{
			MethodName: "VolumeUnconfigure",
			Handler:    _DirectfsServerConfig_VolumeUnconfigure_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "VolumeList",
			Handler:       _DirectfsServerConfig_VolumeList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "directfs.proto",
}

func init() { proto.RegisterFile("directfs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 472 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x94, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0xe7, 0xb6, 0x5b, 0xd7, 0xb7, 0xec, 0xdf, 0xab, 0x6a, 0x44, 0x45, 0x88, 0xce, 0x70,
	0xe8, 0xa9, 0x82, 0x0e, 0x89, 0x0f, 0x90, 0x56, 0xa3, 0x12, 0x3b, 0xe0, 0x09, 0xae, 0x55, 0x70,
	0xdc, 0x11, 0x29, 0x8d, 0x23, 0xdb, 0x9d, 0xc4, 0x87, 0xe4, 0xc6, 0x37, 0xe1, 0xc4, 0x0d, 0xc5,
	0xce, 0xf2, 0x67, 0x5d, 0x84, 0x54, 0x8e, 0xbb, 0xc5, 0xaf, 0xed, 0xe7, 0x7d, 0x9e, 0xdf, 0x6b,
	0x05, 0x8e, 0xc3, 0x48, 0x09, 0x6e, 0x56, 0x7a, 0x92, 0x2a, 0x69, 0x24, 0x1e, 0x69, 0x23, 0x55,
	0x70, 0x2b, 0xa4, 0x5e, 0xaa, 0x94, 0x0f, 0x9f, 0x71, 0xb9, 0x5e, 0xcb, 0xc4, 0x6d, 0xd2, 0x01,
	0xe0, 0x6c, 0xa5, 0x3f, 0x4a, 0x6d, 0x7c, 0x25, 0x42, 0x91, 0x98, 0x28, 0x88, 0x35, 0xfd, 0x49,
	0xa0, 0x9b, 0x97, 0xf1, 0x3d, 0xb4, 0x38, 0xf7, 0xc8, 0x88, 0x8c, 0xfb, 0xd3, 0x37, 0x93, 0x9a,
	0xd6, 0x64, 0x16, 0x98, 0x20, 0x8d, 0x83, 0x44, 0xf8, 0x56, 0xd3, 0x97, 0xc9, 0x2a, 0xba, 0x65,
	0x2d, 0xce, 0xf1, 0x39, 0x74, 0xbf, 0x4b, 0x6d, 0x96, 0x51, 0xe8, 0xb5, 0x46, 0x64, 0x7c, 0xc4,
	0x0e, 0xb2, 0xe5, 0x22, 0xc4, 0x21, 0x1c, 0x66, 0x5f, 0x49, 0xb0, 0x16, 0x5e, 0x7b, 0x44, 0xc6,
	0x3d, 0x56, 0xac, 0x11, 0xa1, 0x93, 0x4a, 0x65, 0xbc, 0x8e, 0xbd, 0x61, 0xbf, 0xd1, 0x87, 0x3e,
	0x2f, 0x9d, 0x79, 0xfb, 0xd6, 0xc7, 0xc5, 0x43, 0x1f, 0x5b, 0x11, 0x58, 0xf5, 0x16, 0x9d, 0xc3,
	0x69, 0x7e, 0xe4, 0x53, 0xa4, 0xcd, 0xe7, 0x8d, 0x50, 0x3f, 0xf0, 0x9d, 0x33, 0xb2, 0x8c, 0x42,
	0xed, 0x91, 0x51, 0x7b, 0xdc, 0x9f, 0x9e, 0x3f, 0xae, 0xca, 0xba, 0xce, 0xba, 0xa6, 0xe7, 0x30,
	0x98, 0xad, 0xf4, 0x57, 0x19, 0x6f, 0xd6, 0xa2, 0x8a, 0xeb, 0x14, 0x8e, 0x8b, 0xfa, 0x8d, 0x09,
	0x8c, 0xa6, 0xbf, 0x09, 0xf4, 0x8a, 0xd2, 0x8e, 0x08, 0x5f, 0x40, 0xef, 0xce, 0xde, 0x2f, 0x21,
	0x1e, 0xba, 0xc2, 0x22, 0xac, 0xf2, 0x6d, 0xd7, 0xf8, 0xce, 0xeb, 0xbc, 0x3a, 0xb6, 0xe9, 0xeb,
	0xed, 0x64, 0x5b, 0x29, 0x6a, 0xc4, 0xf0, 0x12, 0xf6, 0x75, 0x96, 0x24, 0x07, 0xfe, 0xb2, 0x49,
	0xc0, 0xc6, 0x65, 0xee, 0x2c, 0xbd, 0xb6, 0x8f, 0xc9, 0x6d, 0x94, 0xa0, 0x3f, 0x00, 0x14, 0x39,
	0xee, 0x51, 0x7b, 0x4d, 0x7a, 0xac, 0x77, 0x1f, 0x51, 0x4f, 0x7f, 0xb5, 0x61, 0x30, 0xcb, 0xdf,
	0xb2, 0x1f, 0x47, 0x22, 0x31, 0x8e, 0x0e, 0xce, 0xe1, 0xe4, 0x46, 0xa8, 0x3b, 0xa1, 0xdc, 0x7a,
	0xa3, 0x04, 0x36, 0xcc, 0x6e, 0xf8, 0xb0, 0x11, 0x4b, 0x39, 0x13, 0x7a, 0x13, 0x1b, 0xba, 0x87,
	0x57, 0x70, 0xe6, 0x64, 0xbe, 0x24, 0xfc, 0xbf, 0x84, 0x16, 0x00, 0x4e, 0x28, 0x0b, 0x8d, 0xaf,
	0x1e, 0x57, 0x28, 0x80, 0x0c, 0x1b, 0x5a, 0xd0, 0xbd, 0xb7, 0x04, 0xaf, 0xe0, 0x24, 0x9f, 0x4c,
	0xe1, 0xa8, 0x91, 0xd5, 0x3f, 0x3c, 0x9d, 0xb9, 0x53, 0xd5, 0x70, 0xbb, 0x49, 0x5d, 0x03, 0x94,
	0x33, 0xc5, 0x8b, 0x26, 0x8d, 0x32, 0x60, 0x63, 0x9b, 0x2c, 0xe2, 0xf4, 0x0f, 0x29, 0xc7, 0x5a,
	0x1d, 0xe3, 0x13, 0xc8, 0xfe, 0xed, 0xc0, 0xfe, 0x75, 0x2f, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff,
	0x3e, 0x61, 0x61, 0x23, 0xa4, 0x05, 0x00, 0x00,
}
