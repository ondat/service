// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fs.proto

/*
Package storageos_rpc is a generated protocol buffer package.

It is generated from these files:
	fs.proto

It has these top-level messages:
	FsVolumeListQuery
	FsVolumeStats
	FsVolume
*/
package storageos_rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import storageos_rpc1 "."

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FsVolume_VolumeDeviceType int32

const (
	FsVolume_FILE      FsVolume_VolumeDeviceType = 0
	FsVolume_NBD_BLOCK FsVolume_VolumeDeviceType = 1
)

var FsVolume_VolumeDeviceType_name = map[int32]string{
	0: "FILE",
	1: "NBD_BLOCK",
}
var FsVolume_VolumeDeviceType_value = map[string]int32{
	"FILE":      0,
	"NBD_BLOCK": 1,
}

func (x FsVolume_VolumeDeviceType) String() string {
	return proto.EnumName(FsVolume_VolumeDeviceType_name, int32(x))
}
func (FsVolume_VolumeDeviceType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type FsVolumeListQuery struct {
	// A possibly-empty list of volume IDs to query.
	VolumeIds []uint32 `protobuf:"varint,1,rep,packed,name=volume_ids,json=volumeIds" json:"volume_ids,omitempty"`
}

func (m *FsVolumeListQuery) Reset()                    { *m = FsVolumeListQuery{} }
func (m *FsVolumeListQuery) String() string            { return proto.CompactTextString(m) }
func (*FsVolumeListQuery) ProtoMessage()               {}
func (*FsVolumeListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *FsVolumeListQuery) GetVolumeIds() []uint32 {
	if m != nil {
		return m.VolumeIds
	}
	return nil
}

type FsVolumeStats struct {
}

func (m *FsVolumeStats) Reset()                    { *m = FsVolumeStats{} }
func (m *FsVolumeStats) String() string            { return proto.CompactTextString(m) }
func (*FsVolumeStats) ProtoMessage()               {}
func (*FsVolumeStats) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// *
// A StorageOS volume to be presented via the FUSE filesystem.
type FsVolume struct {
	Cc *storageos_rpc1.DataplaneCommonConfig `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The volume ID to represent.
	VolumeId uint32 `protobuf:"varint,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The type for this volume.
	NodeType FsVolume_VolumeDeviceType `protobuf:"varint,3,opt,name=node_type,json=nodeType,enum=storageos_rpc.FsVolume_VolumeDeviceType" json:"node_type,omitempty"`
	// An opaque value interpreted based on node_type.
	DeviceNumber uint32 `protobuf:"varint,4,opt,name=device_number,json=deviceNumber" json:"device_number,omitempty"`
	// The name of the volume to present in the filesystem.
	Filename string `protobuf:"bytes,5,opt,name=filename" json:"filename,omitempty"`
	// True if this volume should be backed by another volume.
	LinkedVolume bool `protobuf:"varint,6,opt,name=linked_volume,json=linkedVolume" json:"linked_volume,omitempty"`
	// If linked_volume is true, this is the volume to which we link.
	TargetVolumeId uint32 `protobuf:"varint,7,opt,name=target_volume_id,json=targetVolumeId" json:"target_volume_id,omitempty"`
	// The volume size in bytes.
	VolumeSizeBytes uint64 `protobuf:"varint,8,opt,name=volume_size_bytes,json=volumeSizeBytes" json:"volume_size_bytes,omitempty"`
	// Volume statistics.
	Stats *FsVolumeStats `protobuf:"bytes,9,opt,name=stats" json:"stats,omitempty"`
}

func (m *FsVolume) Reset()                    { *m = FsVolume{} }
func (m *FsVolume) String() string            { return proto.CompactTextString(m) }
func (*FsVolume) ProtoMessage()               {}
func (*FsVolume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FsVolume) GetCc() *storageos_rpc1.DataplaneCommonConfig {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *FsVolume) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *FsVolume) GetNodeType() FsVolume_VolumeDeviceType {
	if m != nil {
		return m.NodeType
	}
	return FsVolume_FILE
}

func (m *FsVolume) GetDeviceNumber() uint32 {
	if m != nil {
		return m.DeviceNumber
	}
	return 0
}

func (m *FsVolume) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *FsVolume) GetLinkedVolume() bool {
	if m != nil {
		return m.LinkedVolume
	}
	return false
}

func (m *FsVolume) GetTargetVolumeId() uint32 {
	if m != nil {
		return m.TargetVolumeId
	}
	return 0
}

func (m *FsVolume) GetVolumeSizeBytes() uint64 {
	if m != nil {
		return m.VolumeSizeBytes
	}
	return 0
}

func (m *FsVolume) GetStats() *FsVolumeStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func init() {
	proto.RegisterType((*FsVolumeListQuery)(nil), "storageos_rpc.FsVolumeListQuery")
	proto.RegisterType((*FsVolumeStats)(nil), "storageos_rpc.FsVolumeStats")
	proto.RegisterType((*FsVolume)(nil), "storageos_rpc.FsVolume")
	proto.RegisterEnum("storageos_rpc.FsVolume_VolumeDeviceType", FsVolume_VolumeDeviceType_name, FsVolume_VolumeDeviceType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FsConfig service

type FsConfigClient interface {
	// *
	// Configure the specified FsVolume.
	//
	// returns RpcResult
	VolumeConfigure(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Unconfigure the specified FsVolume.
	//
	// returns RpcResult
	VolumeUnconfigure(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Return a list of FsVolume messages, optionally filtered using the supplied
	// FsVolumeListQuery message.
	//
	// returns a stream of FsVolume objects, if any are found that match the filter.
	VolumeList(ctx context.Context, in *FsVolumeListQuery, opts ...grpc.CallOption) (FsConfig_VolumeListClient, error)
}

type fsConfigClient struct {
	cc *grpc.ClientConn
}

func NewFsConfigClient(cc *grpc.ClientConn) FsConfigClient {
	return &fsConfigClient{cc}
}

func (c *fsConfigClient) VolumeConfigure(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.FsConfig/VolumeConfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsConfigClient) VolumeUnconfigure(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.FsConfig/VolumeUnconfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsConfigClient) VolumeList(ctx context.Context, in *FsVolumeListQuery, opts ...grpc.CallOption) (FsConfig_VolumeListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FsConfig_serviceDesc.Streams[0], c.cc, "/storageos_rpc.FsConfig/VolumeList", opts...)
	if err != nil {
		return nil, err
	}
	x := &fsConfigVolumeListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FsConfig_VolumeListClient interface {
	Recv() (*FsVolume, error)
	grpc.ClientStream
}

type fsConfigVolumeListClient struct {
	grpc.ClientStream
}

func (x *fsConfigVolumeListClient) Recv() (*FsVolume, error) {
	m := new(FsVolume)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FsConfig service

type FsConfigServer interface {
	// *
	// Configure the specified FsVolume.
	//
	// returns RpcResult
	VolumeConfigure(context.Context, *FsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// Unconfigure the specified FsVolume.
	//
	// returns RpcResult
	VolumeUnconfigure(context.Context, *FsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// Return a list of FsVolume messages, optionally filtered using the supplied
	// FsVolumeListQuery message.
	//
	// returns a stream of FsVolume objects, if any are found that match the filter.
	VolumeList(*FsVolumeListQuery, FsConfig_VolumeListServer) error
}

func RegisterFsConfigServer(s *grpc.Server, srv FsConfigServer) {
	s.RegisterService(&_FsConfig_serviceDesc, srv)
}

func _FsConfig_VolumeConfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsConfigServer).VolumeConfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.FsConfig/VolumeConfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsConfigServer).VolumeConfigure(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _FsConfig_VolumeUnconfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsConfigServer).VolumeUnconfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.FsConfig/VolumeUnconfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsConfigServer).VolumeUnconfigure(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _FsConfig_VolumeList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FsVolumeListQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FsConfigServer).VolumeList(m, &fsConfigVolumeListServer{stream})
}

type FsConfig_VolumeListServer interface {
	Send(*FsVolume) error
	grpc.ServerStream
}

type fsConfigVolumeListServer struct {
	grpc.ServerStream
}

func (x *fsConfigVolumeListServer) Send(m *FsVolume) error {
	return x.ServerStream.SendMsg(m)
}

var _FsConfig_serviceDesc = grpc.ServiceDesc{
	ServiceName: "storageos_rpc.FsConfig",
	HandlerType: (*FsConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VolumeConfigure",
			Handler:    _FsConfig_VolumeConfigure_Handler,
		},
		{
			MethodName: "VolumeUnconfigure",
			Handler:    _FsConfig_VolumeUnconfigure_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "VolumeList",
			Handler:       _FsConfig_VolumeList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "fs.proto",
}

func init() { proto.RegisterFile("fs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 436 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0xc7, 0xe7, 0xb6, 0x1b, 0xc9, 0xa1, 0x59, 0x5b, 0xdf, 0x60, 0x15, 0x90, 0xa2, 0xc0, 0x45,
	0x04, 0x52, 0x85, 0x02, 0x4f, 0xd0, 0x76, 0x15, 0xd3, 0xaa, 0x21, 0x3c, 0xd8, 0x6d, 0x94, 0x3a,
	0xa7, 0x55, 0x44, 0x12, 0x47, 0xb1, 0x33, 0xa9, 0x7b, 0x3b, 0x1e, 0x87, 0xb7, 0x40, 0xb1, 0x97,
	0x4e, 0x54, 0xea, 0x15, 0x57, 0x89, 0x7f, 0xe7, 0xe3, 0x7f, 0xbe, 0xc0, 0xd9, 0xaa, 0x59, 0x55,
	0x4b, 0x2d, 0xa9, 0xa7, 0xb4, 0xac, 0x93, 0x1d, 0x4a, 0x15, 0xd7, 0x95, 0x98, 0x0e, 0x85, 0x2c,
	0x0a, 0x59, 0x5a, 0x63, 0x10, 0xc1, 0x64, 0xa5, 0xee, 0x65, 0xde, 0x14, 0xb8, 0xce, 0x94, 0xfe,
	0xde, 0x60, 0xbd, 0xa7, 0x6f, 0x01, 0x1e, 0x0c, 0x8a, 0xb3, 0x54, 0x31, 0xe2, 0xf7, 0x43, 0x8f,
	0xbb, 0x96, 0x5c, 0xa7, 0x2a, 0x18, 0x81, 0xd7, 0xc5, 0xdc, 0xe9, 0x44, 0xab, 0xe0, 0x77, 0x1f,
	0x9c, 0x8e, 0xd0, 0x2f, 0xd0, 0x13, 0x82, 0x11, 0x9f, 0x84, 0x2f, 0xa3, 0xf7, 0xb3, 0x7f, 0xb4,
	0x67, 0xcb, 0x44, 0x27, 0x55, 0x9e, 0x94, 0xb8, 0x30, 0x35, 0x2c, 0x64, 0xb9, 0xcd, 0x76, 0xbc,
	0x27, 0x04, 0x7d, 0x0d, 0xee, 0x41, 0x92, 0xf5, 0x7c, 0x12, 0x7a, 0xdc, 0xe9, 0x14, 0xe9, 0x15,
	0xb8, 0xa5, 0x4c, 0x31, 0xd6, 0xfb, 0x0a, 0x59, 0xdf, 0x27, 0xe1, 0x65, 0x14, 0x1e, 0x65, 0xee,
	0xe4, 0x67, 0xf6, 0xb3, 0xc4, 0x87, 0x4c, 0xe0, 0x8f, 0x7d, 0x85, 0xdc, 0x69, 0x43, 0xdb, 0x3f,
	0xfa, 0x0e, 0xbc, 0xd4, 0xf0, 0xb8, 0x6c, 0x8a, 0x0d, 0xd6, 0x6c, 0x60, 0x74, 0x86, 0x16, 0xde,
	0x1a, 0x46, 0xa7, 0xe0, 0x6c, 0xb3, 0x1c, 0xcb, 0xa4, 0x40, 0x76, 0xee, 0x93, 0xd0, 0xe5, 0x87,
	0x77, 0x9b, 0x20, 0xcf, 0xca, 0x5f, 0x98, 0xc6, 0xb6, 0x34, 0x76, 0xe1, 0x93, 0xd0, 0xe1, 0x43,
	0x0b, 0x9f, 0xfa, 0x0f, 0x61, 0xac, 0x93, 0x7a, 0x87, 0x3a, 0x7e, 0x6e, 0xe8, 0x85, 0x11, 0xba,
	0xb4, 0xfc, 0xbe, 0x6b, 0xeb, 0x03, 0x4c, 0x9e, 0x5c, 0x54, 0xf6, 0x88, 0xf1, 0x66, 0xaf, 0x51,
	0x31, 0xc7, 0x27, 0xe1, 0x80, 0x8f, 0xac, 0xe1, 0x2e, 0x7b, 0xc4, 0x79, 0x8b, 0x69, 0x04, 0xe7,
	0xaa, 0x9d, 0x35, 0x73, 0xcd, 0x60, 0xdf, 0x9c, 0x68, 0xdf, 0xec, 0x83, 0x5b, 0xd7, 0xe0, 0x23,
	0x8c, 0x8f, 0xa7, 0x41, 0x1d, 0x18, 0xac, 0xae, 0xd7, 0x57, 0xe3, 0x33, 0xea, 0x81, 0x7b, 0x3b,
	0x5f, 0xc6, 0xf3, 0xf5, 0xb7, 0xc5, 0xcd, 0x98, 0x44, 0x7f, 0x48, 0xbb, 0x43, 0xbb, 0x11, 0xba,
	0x82, 0x91, 0x8d, 0xb4, 0xef, 0xa6, 0x46, 0xfa, 0xea, 0x84, 0xe2, 0x94, 0x1d, 0x19, 0x78, 0x25,
	0x38, 0xaa, 0x26, 0xd7, 0xc1, 0x19, 0xfd, 0x0a, 0x13, 0xeb, 0xf5, 0xb3, 0x14, 0xff, 0x97, 0xe9,
	0x06, 0xe0, 0xf9, 0x4a, 0xa9, 0x7f, 0x22, 0xc5, 0xe1, 0x84, 0xa7, 0xa7, 0x44, 0x82, 0xb3, 0x4f,
	0x64, 0x73, 0x61, 0x6e, 0xff, 0xf3, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x26, 0x16, 0xec, 0x2d,
	0x24, 0x03, 0x00, 0x00,
}
