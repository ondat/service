// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fs.proto

/*
Package storageos_rpc is a generated protocol buffer package.

It is generated from these files:
	fs.proto

It has these top-level messages:
	FsVolumeListQuery
	FsVolume
*/
package storageos_rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import storageos_rpc1 "."

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FsVolume_VolumeDeviceType int32

const (
	FsVolume_FILE      FsVolume_VolumeDeviceType = 0
	FsVolume_NBD_BLOCK FsVolume_VolumeDeviceType = 1
)

var FsVolume_VolumeDeviceType_name = map[int32]string{
	0: "FILE",
	1: "NBD_BLOCK",
}
var FsVolume_VolumeDeviceType_value = map[string]int32{
	"FILE":      0,
	"NBD_BLOCK": 1,
}

func (x FsVolume_VolumeDeviceType) String() string {
	return proto.EnumName(FsVolume_VolumeDeviceType_name, int32(x))
}
func (FsVolume_VolumeDeviceType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type FsVolumeListQuery struct {
}

func (m *FsVolumeListQuery) Reset()                    { *m = FsVolumeListQuery{} }
func (m *FsVolumeListQuery) String() string            { return proto.CompactTextString(m) }
func (*FsVolumeListQuery) ProtoMessage()               {}
func (*FsVolumeListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type FsVolume struct {
	// The volume ID to represent.
	VolumeId uint32 `protobuf:"varint,1,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The type for this volume.
	NodeType FsVolume_VolumeDeviceType `protobuf:"varint,2,opt,name=node_type,json=nodeType,enum=storageos_rpc.FsVolume_VolumeDeviceType" json:"node_type,omitempty"`
	// An opaque value interpreted based on node_type.
	DeviceNumber uint32 `protobuf:"varint,3,opt,name=device_number,json=deviceNumber" json:"device_number,omitempty"`
	// The name of the volume to present in the filesystem.
	Filename string `protobuf:"bytes,4,opt,name=filename" json:"filename,omitempty"`
	// True if this volume should be backed by another volume.
	LinkedVolume bool `protobuf:"varint,5,opt,name=linked_volume,json=linkedVolume" json:"linked_volume,omitempty"`
	// If linked_volume is true, this is the volume to which we link.
	TargetVolumeId uint32 `protobuf:"varint,6,opt,name=target_volume_id,json=targetVolumeId" json:"target_volume_id,omitempty"`
	// The volume size in bytes.
	VolumeSizeBytes uint64 `protobuf:"varint,7,opt,name=volume_size_bytes,json=volumeSizeBytes" json:"volume_size_bytes,omitempty"`
}

func (m *FsVolume) Reset()                    { *m = FsVolume{} }
func (m *FsVolume) String() string            { return proto.CompactTextString(m) }
func (*FsVolume) ProtoMessage()               {}
func (*FsVolume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *FsVolume) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *FsVolume) GetNodeType() FsVolume_VolumeDeviceType {
	if m != nil {
		return m.NodeType
	}
	return FsVolume_FILE
}

func (m *FsVolume) GetDeviceNumber() uint32 {
	if m != nil {
		return m.DeviceNumber
	}
	return 0
}

func (m *FsVolume) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *FsVolume) GetLinkedVolume() bool {
	if m != nil {
		return m.LinkedVolume
	}
	return false
}

func (m *FsVolume) GetTargetVolumeId() uint32 {
	if m != nil {
		return m.TargetVolumeId
	}
	return 0
}

func (m *FsVolume) GetVolumeSizeBytes() uint64 {
	if m != nil {
		return m.VolumeSizeBytes
	}
	return 0
}

func init() {
	proto.RegisterType((*FsVolumeListQuery)(nil), "storageos_rpc.FsVolumeListQuery")
	proto.RegisterType((*FsVolume)(nil), "storageos_rpc.FsVolume")
	proto.RegisterEnum("storageos_rpc.FsVolume_VolumeDeviceType", FsVolume_VolumeDeviceType_name, FsVolume_VolumeDeviceType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FsConfig service

type FsConfigClient interface {
	VolumeConfigure(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	VolumeUnconfigure(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	VolumeList(ctx context.Context, in *FsVolumeListQuery, opts ...grpc.CallOption) (FsConfig_VolumeListClient, error)
}

type fsConfigClient struct {
	cc *grpc.ClientConn
}

func NewFsConfigClient(cc *grpc.ClientConn) FsConfigClient {
	return &fsConfigClient{cc}
}

func (c *fsConfigClient) VolumeConfigure(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.FsConfig/VolumeConfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsConfigClient) VolumeUnconfigure(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.FsConfig/VolumeUnconfigure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsConfigClient) VolumeList(ctx context.Context, in *FsVolumeListQuery, opts ...grpc.CallOption) (FsConfig_VolumeListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FsConfig_serviceDesc.Streams[0], c.cc, "/storageos_rpc.FsConfig/VolumeList", opts...)
	if err != nil {
		return nil, err
	}
	x := &fsConfigVolumeListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FsConfig_VolumeListClient interface {
	Recv() (*FsVolume, error)
	grpc.ClientStream
}

type fsConfigVolumeListClient struct {
	grpc.ClientStream
}

func (x *fsConfigVolumeListClient) Recv() (*FsVolume, error) {
	m := new(FsVolume)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FsConfig service

type FsConfigServer interface {
	VolumeConfigure(context.Context, *FsVolume) (*storageos_rpc1.RpcResult, error)
	VolumeUnconfigure(context.Context, *FsVolume) (*storageos_rpc1.RpcResult, error)
	VolumeList(*FsVolumeListQuery, FsConfig_VolumeListServer) error
}

func RegisterFsConfigServer(s *grpc.Server, srv FsConfigServer) {
	s.RegisterService(&_FsConfig_serviceDesc, srv)
}

func _FsConfig_VolumeConfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsConfigServer).VolumeConfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.FsConfig/VolumeConfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsConfigServer).VolumeConfigure(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _FsConfig_VolumeUnconfigure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsConfigServer).VolumeUnconfigure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.FsConfig/VolumeUnconfigure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsConfigServer).VolumeUnconfigure(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _FsConfig_VolumeList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FsVolumeListQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FsConfigServer).VolumeList(m, &fsConfigVolumeListServer{stream})
}

type FsConfig_VolumeListServer interface {
	Send(*FsVolume) error
	grpc.ServerStream
}

type fsConfigVolumeListServer struct {
	grpc.ServerStream
}

func (x *fsConfigVolumeListServer) Send(m *FsVolume) error {
	return x.ServerStream.SendMsg(m)
}

var _FsConfig_serviceDesc = grpc.ServiceDesc{
	ServiceName: "storageos_rpc.FsConfig",
	HandlerType: (*FsConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VolumeConfigure",
			Handler:    _FsConfig_VolumeConfigure_Handler,
		},
		{
			MethodName: "VolumeUnconfigure",
			Handler:    _FsConfig_VolumeUnconfigure_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "VolumeList",
			Handler:       _FsConfig_VolumeList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "fs.proto",
}

func init() { proto.RegisterFile("fs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 368 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x92, 0xcf, 0xaa, 0x9b, 0x40,
	0x14, 0xc6, 0x33, 0xb7, 0xe9, 0xad, 0x1e, 0x62, 0x62, 0xa6, 0x8b, 0x8a, 0xdd, 0x88, 0xdd, 0x48,
	0x0b, 0x52, 0xd2, 0x37, 0xc8, 0x3f, 0x1a, 0x12, 0x52, 0x6a, 0xdb, 0x6c, 0x87, 0x44, 0x4f, 0xc2,
	0x50, 0x75, 0xc4, 0x19, 0x03, 0xe6, 0x45, 0xfb, 0x0c, 0x7d, 0x8b, 0xa2, 0x93, 0x3f, 0x34, 0x90,
	0xd5, 0x5d, 0x39, 0xf3, 0x3b, 0x73, 0xbe, 0xcf, 0xef, 0x70, 0xc0, 0xd8, 0xcb, 0xb0, 0x28, 0x85,
	0x12, 0xd4, 0x92, 0x4a, 0x94, 0xdb, 0x03, 0x0a, 0xc9, 0xca, 0x22, 0x76, 0x7b, 0xb1, 0xc8, 0x32,
	0x91, 0xeb, 0xa2, 0xff, 0x16, 0x86, 0x73, 0xb9, 0x11, 0x69, 0x95, 0xe1, 0x8a, 0x4b, 0xf5, 0xbd,
	0xc2, 0xb2, 0xf6, 0xff, 0x3c, 0x81, 0x71, 0xa1, 0xf4, 0x3d, 0x98, 0xc7, 0xf6, 0xc4, 0x78, 0xe2,
	0x10, 0x8f, 0x04, 0x56, 0x64, 0x68, 0xb0, 0x48, 0xe8, 0x0c, 0xcc, 0x5c, 0x24, 0xc8, 0x54, 0x5d,
	0xa0, 0xf3, 0xe4, 0x91, 0xa0, 0x3f, 0x0a, 0xc2, 0xff, 0xfc, 0xc2, 0x8b, 0x50, 0xa8, 0x3f, 0x53,
	0x3c, 0xf2, 0x18, 0x7f, 0xd6, 0x05, 0x46, 0x46, 0xd3, 0xda, 0x9c, 0xe8, 0x07, 0xb0, 0x92, 0x96,
	0xb3, 0xbc, 0xca, 0x76, 0x58, 0x3a, 0xaf, 0x5a, 0x9f, 0x9e, 0x86, 0xeb, 0x96, 0x51, 0x17, 0x8c,
	0x3d, 0x4f, 0x31, 0xdf, 0x66, 0xe8, 0x74, 0x3d, 0x12, 0x98, 0xd1, 0xf5, 0xde, 0x08, 0xa4, 0x3c,
	0xff, 0x8d, 0x09, 0xd3, 0xbf, 0xe6, 0xbc, 0xf6, 0x48, 0x60, 0x44, 0x3d, 0x0d, 0xcf, 0x49, 0x02,
	0xb0, 0xd5, 0xb6, 0x3c, 0xa0, 0x62, 0xb7, 0x40, 0xcf, 0xad, 0x51, 0x5f, 0xf3, 0xcd, 0x25, 0xd6,
	0x47, 0x18, 0x9e, 0x9f, 0x48, 0x7e, 0x42, 0xb6, 0xab, 0x15, 0x4a, 0xe7, 0x8d, 0x47, 0x82, 0x6e,
	0x34, 0xd0, 0x85, 0x1f, 0xfc, 0x84, 0xe3, 0x06, 0xfb, 0x9f, 0xc0, 0xbe, 0x4f, 0x46, 0x0d, 0xe8,
	0xce, 0x17, 0xab, 0x99, 0xdd, 0xa1, 0x16, 0x98, 0xeb, 0xf1, 0x94, 0x8d, 0x57, 0xdf, 0x26, 0x4b,
	0x9b, 0x8c, 0xfe, 0x92, 0x66, 0xb2, 0x13, 0x91, 0xef, 0xf9, 0x81, 0xce, 0x61, 0xa0, 0x3b, 0xf5,
	0xbd, 0x2a, 0x91, 0xbe, 0x7b, 0x30, 0x3c, 0xd7, 0xb9, 0x2b, 0x44, 0x45, 0x1c, 0xa1, 0xac, 0x52,
	0xe5, 0x77, 0xe8, 0x57, 0x18, 0xea, 0x57, 0xbf, 0xf2, 0xf8, 0x65, 0x4a, 0x4b, 0x80, 0xdb, 0x2e,
	0x50, 0xef, 0x81, 0xc4, 0x75, 0x51, 0xdc, 0x47, 0x26, 0x7e, 0xe7, 0x33, 0xd9, 0x3d, 0xb7, 0x1b,
	0xf6, 0xe5, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x55, 0x63, 0xec, 0xdd, 0x8a, 0x02, 0x00, 0x00,
}
