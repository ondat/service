// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fs.proto

/*
Package storageos_rpc is a generated protocol buffer package.

It is generated from these files:
	fs.proto

It has these top-level messages:
	FsVolumeListQuery
	FsVolumeStatistics
	FsVolumeStatus
	FsVolume
	FsVolumeList
	FsPresentationListQuery
	FsPresentation
	FsPresentationList
*/
package storageos_rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import storageos_rpc1 "."

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FsVolumeState int32

const (
	FsVolumeState_NONE  FsVolumeState = 0
	FsVolumeState_READY FsVolumeState = 1
)

var FsVolumeState_name = map[int32]string{
	0: "NONE",
	1: "READY",
}
var FsVolumeState_value = map[string]int32{
	"NONE":  0,
	"READY": 1,
}

func (x FsVolumeState) String() string {
	return proto.EnumName(FsVolumeState_name, int32(x))
}
func (FsVolumeState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type FsVolume_VolumeDeviceType int32

const (
	FsVolume_FILE      FsVolume_VolumeDeviceType = 0
	FsVolume_NBD_BLOCK FsVolume_VolumeDeviceType = 1
)

var FsVolume_VolumeDeviceType_name = map[int32]string{
	0: "FILE",
	1: "NBD_BLOCK",
}
var FsVolume_VolumeDeviceType_value = map[string]int32{
	"FILE":      0,
	"NBD_BLOCK": 1,
}

func (x FsVolume_VolumeDeviceType) String() string {
	return proto.EnumName(FsVolume_VolumeDeviceType_name, int32(x))
}
func (FsVolume_VolumeDeviceType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type FsVolumeListQuery struct {
	// A possibly-empty list of volume IDs to query.
	VolumeIds []uint32 `protobuf:"varint,1,rep,packed,name=volume_ids,json=volumeIds" json:"volume_ids,omitempty"`
}

func (m *FsVolumeListQuery) Reset()                    { *m = FsVolumeListQuery{} }
func (m *FsVolumeListQuery) String() string            { return proto.CompactTextString(m) }
func (*FsVolumeListQuery) ProtoMessage()               {}
func (*FsVolumeListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *FsVolumeListQuery) GetVolumeIds() []uint32 {
	if m != nil {
		return m.VolumeIds
	}
	return nil
}

type FsVolumeStatistics struct {
}

func (m *FsVolumeStatistics) Reset()                    { *m = FsVolumeStatistics{} }
func (m *FsVolumeStatistics) String() string            { return proto.CompactTextString(m) }
func (*FsVolumeStatistics) ProtoMessage()               {}
func (*FsVolumeStatistics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type FsVolumeStatus struct {
	// State of the volume device node (file/block device).
	NodeState FsVolumeState `protobuf:"varint,1,opt,name=node_state,json=nodeState,enum=storageos_rpc.FsVolumeState" json:"node_state,omitempty"`
}

func (m *FsVolumeStatus) Reset()                    { *m = FsVolumeStatus{} }
func (m *FsVolumeStatus) String() string            { return proto.CompactTextString(m) }
func (*FsVolumeStatus) ProtoMessage()               {}
func (*FsVolumeStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FsVolumeStatus) GetNodeState() FsVolumeState {
	if m != nil {
		return m.NodeState
	}
	return FsVolumeState_NONE
}

// *
// A StorageOS volume to be presented via the FUSE filesystem.
type FsVolume struct {
	Cc *storageos_rpc1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The volume ID to represent.
	VolumeId uint32 `protobuf:"varint,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The type for this volume.
	NodeType FsVolume_VolumeDeviceType `protobuf:"varint,3,opt,name=node_type,json=nodeType,enum=storageos_rpc.FsVolume_VolumeDeviceType" json:"node_type,omitempty"`
	// An opaque value interpreted based on node_type.
	DeviceNumber uint32 `protobuf:"varint,4,opt,name=device_number,json=deviceNumber" json:"device_number,omitempty"`
	// The name of the volume to present in the filesystem.
	Filename string `protobuf:"bytes,5,opt,name=filename" json:"filename,omitempty"`
	// True if this volume should be backed by another volume.
	LinkedVolume bool `protobuf:"varint,6,opt,name=linked_volume,json=linkedVolume" json:"linked_volume,omitempty"`
	// If linked_volume is true, this is the volume to which we link.
	TargetVolumeId uint32 `protobuf:"varint,7,opt,name=target_volume_id,json=targetVolumeId" json:"target_volume_id,omitempty"`
	// The volume size in bytes.
	VolumeSizeBytes uint64 `protobuf:"varint,8,opt,name=volume_size_bytes,json=volumeSizeBytes" json:"volume_size_bytes,omitempty"`
	// Volume statistics.
	Stats *FsVolumeStatistics `protobuf:"bytes,9,opt,name=stats" json:"stats,omitempty"`
	// Volume status, e.g. readiness.
	Status *FsVolumeStatus `protobuf:"bytes,10,opt,name=status" json:"status,omitempty"`
}

func (m *FsVolume) Reset()                    { *m = FsVolume{} }
func (m *FsVolume) String() string            { return proto.CompactTextString(m) }
func (*FsVolume) ProtoMessage()               {}
func (*FsVolume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FsVolume) GetCc() *storageos_rpc1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *FsVolume) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *FsVolume) GetNodeType() FsVolume_VolumeDeviceType {
	if m != nil {
		return m.NodeType
	}
	return FsVolume_FILE
}

func (m *FsVolume) GetDeviceNumber() uint32 {
	if m != nil {
		return m.DeviceNumber
	}
	return 0
}

func (m *FsVolume) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *FsVolume) GetLinkedVolume() bool {
	if m != nil {
		return m.LinkedVolume
	}
	return false
}

func (m *FsVolume) GetTargetVolumeId() uint32 {
	if m != nil {
		return m.TargetVolumeId
	}
	return 0
}

func (m *FsVolume) GetVolumeSizeBytes() uint64 {
	if m != nil {
		return m.VolumeSizeBytes
	}
	return 0
}

func (m *FsVolume) GetStats() *FsVolumeStatistics {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *FsVolume) GetStatus() *FsVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type FsVolumeList struct {
	Volumes []*FsVolume `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
}

func (m *FsVolumeList) Reset()                    { *m = FsVolumeList{} }
func (m *FsVolumeList) String() string            { return proto.CompactTextString(m) }
func (*FsVolumeList) ProtoMessage()               {}
func (*FsVolumeList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *FsVolumeList) GetVolumes() []*FsVolume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type FsPresentationListQuery struct {
	// A possibly-empty list of volume IDs to query.
	PresentationId []uint32 `protobuf:"varint,1,rep,packed,name=presentation_id,json=presentationId" json:"presentation_id,omitempty"`
}

func (m *FsPresentationListQuery) Reset()                    { *m = FsPresentationListQuery{} }
func (m *FsPresentationListQuery) String() string            { return proto.CompactTextString(m) }
func (*FsPresentationListQuery) ProtoMessage()               {}
func (*FsPresentationListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FsPresentationListQuery) GetPresentationId() []uint32 {
	if m != nil {
		return m.PresentationId
	}
	return nil
}

// *
// Presentation volume message for Fs RPCs.
//
// The minimum amount of information required to specify the 'presentation' or source volume,
// the volume that is presented to the user and (usually) mounted. All actual work
// is done on the target volume, which has actual storage associated with it.
type FsPresentation struct {
	Cc *storageos_rpc1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The inode the user mounts or opens.
	SourceId uint32 `protobuf:"varint,2,opt,name=source_id,json=sourceId" json:"source_id,omitempty"`
	// The underlying inode of the StorageOS volume.
	TargetId uint32 `protobuf:"varint,3,opt,name=target_id,json=targetId" json:"target_id,omitempty"`
	// Presentation inode status, e.g. readiness.
	Status *FsVolumeStatus `protobuf:"bytes,5,opt,name=status" json:"status,omitempty"`
}

func (m *FsPresentation) Reset()                    { *m = FsPresentation{} }
func (m *FsPresentation) String() string            { return proto.CompactTextString(m) }
func (*FsPresentation) ProtoMessage()               {}
func (*FsPresentation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FsPresentation) GetCc() *storageos_rpc1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *FsPresentation) GetSourceId() uint32 {
	if m != nil {
		return m.SourceId
	}
	return 0
}

func (m *FsPresentation) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *FsPresentation) GetStatus() *FsVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type FsPresentationList struct {
	Presentations []*FsPresentation `protobuf:"bytes,1,rep,name=presentations" json:"presentations,omitempty"`
}

func (m *FsPresentationList) Reset()                    { *m = FsPresentationList{} }
func (m *FsPresentationList) String() string            { return proto.CompactTextString(m) }
func (*FsPresentationList) ProtoMessage()               {}
func (*FsPresentationList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *FsPresentationList) GetPresentations() []*FsPresentation {
	if m != nil {
		return m.Presentations
	}
	return nil
}

func init() {
	proto.RegisterType((*FsVolumeListQuery)(nil), "storageos_rpc.FsVolumeListQuery")
	proto.RegisterType((*FsVolumeStatistics)(nil), "storageos_rpc.FsVolumeStatistics")
	proto.RegisterType((*FsVolumeStatus)(nil), "storageos_rpc.FsVolumeStatus")
	proto.RegisterType((*FsVolume)(nil), "storageos_rpc.FsVolume")
	proto.RegisterType((*FsVolumeList)(nil), "storageos_rpc.FsVolumeList")
	proto.RegisterType((*FsPresentationListQuery)(nil), "storageos_rpc.FsPresentationListQuery")
	proto.RegisterType((*FsPresentation)(nil), "storageos_rpc.FsPresentation")
	proto.RegisterType((*FsPresentationList)(nil), "storageos_rpc.FsPresentationList")
	proto.RegisterEnum("storageos_rpc.FsVolumeState", FsVolumeState_name, FsVolumeState_value)
	proto.RegisterEnum("storageos_rpc.FsVolume_VolumeDeviceType", FsVolume_VolumeDeviceType_name, FsVolume_VolumeDeviceType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Fs service

type FsClient interface {
	// *
	// Create the specified FsVolume.
	//
	// returns RpcResult
	VolumeCreate(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Update the specified FsVolume.
	//
	// returns RpcResult
	VolumeUpdate(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Delete the specified FsVolume.
	//
	// returns RpcResult
	VolumeDelete(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Return a list of FsVolume messages, optionally filtered using the supplied
	// FsVolumeListQuery message.
	//
	// returns A FsVolumeList message containing FsVolume objects,
	//         if any are found that match the filter.
	VolumeList(ctx context.Context, in *FsVolumeListQuery, opts ...grpc.CallOption) (*FsVolumeList, error)
	// *
	// Add configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationCreate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Update configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationUpdate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// Remove configuration for the Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationDelete(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error)
	// *
	// List configured Presentation volumes, optionally filtered using a FsPresentationListQuery
	// message.
	//
	// returns A FsPresentationList message containing FsPresentation mesages,
	//         if any are found matching the filter.
	PresentationList(ctx context.Context, in *FsPresentationListQuery, opts ...grpc.CallOption) (*FsPresentationList, error)
}

type fsClient struct {
	cc *grpc.ClientConn
}

func NewFsClient(cc *grpc.ClientConn) FsClient {
	return &fsClient{cc}
}

func (c *fsClient) VolumeCreate(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.Fs/VolumeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) VolumeUpdate(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.Fs/VolumeUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) VolumeDelete(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.Fs/VolumeDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) VolumeList(ctx context.Context, in *FsVolumeListQuery, opts ...grpc.CallOption) (*FsVolumeList, error) {
	out := new(FsVolumeList)
	err := grpc.Invoke(ctx, "/storageos_rpc.Fs/VolumeList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationCreate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.Fs/PresentationCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationUpdate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.Fs/PresentationUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationDelete(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*storageos_rpc1.RpcResult, error) {
	out := new(storageos_rpc1.RpcResult)
	err := grpc.Invoke(ctx, "/storageos_rpc.Fs/PresentationDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationList(ctx context.Context, in *FsPresentationListQuery, opts ...grpc.CallOption) (*FsPresentationList, error) {
	out := new(FsPresentationList)
	err := grpc.Invoke(ctx, "/storageos_rpc.Fs/PresentationList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Fs service

type FsServer interface {
	// *
	// Create the specified FsVolume.
	//
	// returns RpcResult
	VolumeCreate(context.Context, *FsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// Update the specified FsVolume.
	//
	// returns RpcResult
	VolumeUpdate(context.Context, *FsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// Delete the specified FsVolume.
	//
	// returns RpcResult
	VolumeDelete(context.Context, *FsVolume) (*storageos_rpc1.RpcResult, error)
	// *
	// Return a list of FsVolume messages, optionally filtered using the supplied
	// FsVolumeListQuery message.
	//
	// returns A FsVolumeList message containing FsVolume objects,
	//         if any are found that match the filter.
	VolumeList(context.Context, *FsVolumeListQuery) (*FsVolumeList, error)
	// *
	// Add configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationCreate(context.Context, *FsPresentation) (*storageos_rpc1.RpcResult, error)
	// *
	// Update configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationUpdate(context.Context, *FsPresentation) (*storageos_rpc1.RpcResult, error)
	// *
	// Remove configuration for the Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationDelete(context.Context, *FsPresentation) (*storageos_rpc1.RpcResult, error)
	// *
	// List configured Presentation volumes, optionally filtered using a FsPresentationListQuery
	// message.
	//
	// returns A FsPresentationList message containing FsPresentation mesages,
	//         if any are found matching the filter.
	PresentationList(context.Context, *FsPresentationListQuery) (*FsPresentationList, error)
}

func RegisterFsServer(s *grpc.Server, srv FsServer) {
	s.RegisterService(&_Fs_serviceDesc, srv)
}

func _Fs_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).VolumeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.Fs/VolumeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).VolumeCreate(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_VolumeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).VolumeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.Fs/VolumeUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).VolumeUpdate(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_VolumeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).VolumeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.Fs/VolumeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).VolumeDelete(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_VolumeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolumeListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).VolumeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.Fs/VolumeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).VolumeList(ctx, req.(*FsVolumeListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.Fs/PresentationCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationCreate(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.Fs/PresentationUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationUpdate(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.Fs/PresentationDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationDelete(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentationListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageos_rpc.Fs/PresentationList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationList(ctx, req.(*FsPresentationListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

var _Fs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "storageos_rpc.Fs",
	HandlerType: (*FsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VolumeCreate",
			Handler:    _Fs_VolumeCreate_Handler,
		},
		{
			MethodName: "VolumeUpdate",
			Handler:    _Fs_VolumeUpdate_Handler,
		},
		{
			MethodName: "VolumeDelete",
			Handler:    _Fs_VolumeDelete_Handler,
		},
		{
			MethodName: "VolumeList",
			Handler:    _Fs_VolumeList_Handler,
		},
		{
			MethodName: "PresentationCreate",
			Handler:    _Fs_PresentationCreate_Handler,
		},
		{
			MethodName: "PresentationUpdate",
			Handler:    _Fs_PresentationUpdate_Handler,
		},
		{
			MethodName: "PresentationDelete",
			Handler:    _Fs_PresentationDelete_Handler,
		},
		{
			MethodName: "PresentationList",
			Handler:    _Fs_PresentationList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "fs.proto",
}

func init() { proto.RegisterFile("fs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 649 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x51, 0x4b, 0xdb, 0x50,
	0x14, 0x6e, 0x6a, 0xab, 0xe9, 0xb1, 0xa9, 0xf5, 0x32, 0x30, 0xd4, 0x39, 0x62, 0x36, 0xb6, 0xe0,
	0xa0, 0xb0, 0x8e, 0xb1, 0x87, 0x3d, 0xd9, 0xd6, 0x42, 0x99, 0xd6, 0xed, 0xba, 0x09, 0x3e, 0x85,
	0x98, 0x1c, 0x25, 0xac, 0x4d, 0x42, 0xee, 0x8d, 0x50, 0xff, 0xd5, 0xfe, 0xdc, 0xf6, 0x3a, 0xee,
	0xbd, 0xa9, 0x8d, 0x95, 0x76, 0x4c, 0xf7, 0xd4, 0xf4, 0x3b, 0xe7, 0x7c, 0xe7, 0x9c, 0xef, 0x7c,
	0x21, 0xa0, 0x5f, 0xb1, 0x76, 0x92, 0xc6, 0x3c, 0x26, 0x06, 0xe3, 0x71, 0xea, 0x5d, 0x63, 0xcc,
	0xdc, 0x34, 0xf1, 0x5b, 0x75, 0x3f, 0x9e, 0x4c, 0xe2, 0x48, 0x05, 0xed, 0x0e, 0x6c, 0x0f, 0xd8,
	0x79, 0x3c, 0xce, 0x26, 0x78, 0x1c, 0x32, 0xfe, 0x35, 0xc3, 0x74, 0x4a, 0xf6, 0x00, 0x6e, 0x24,
	0xe4, 0x86, 0x01, 0x33, 0x35, 0x6b, 0xcd, 0x31, 0x68, 0x4d, 0x21, 0xc3, 0x80, 0xd9, 0xcf, 0x80,
	0xcc, 0x6a, 0xce, 0xb8, 0xc7, 0x43, 0xc6, 0x43, 0x9f, 0xd9, 0x27, 0xd0, 0x28, 0xa2, 0x19, 0x23,
	0x9f, 0x00, 0xa2, 0x38, 0x40, 0x97, 0x71, 0x8f, 0xa3, 0xa9, 0x59, 0x9a, 0xd3, 0xe8, 0x3c, 0x6f,
	0xdf, 0x9b, 0xa6, 0x5d, 0x2c, 0x41, 0x5a, 0x13, 0xf9, 0xf2, 0xd1, 0xfe, 0xbd, 0x06, 0xfa, 0x2c,
	0x48, 0xda, 0x50, 0xf6, 0x7d, 0xc9, 0xb0, 0xd9, 0x79, 0xb1, 0xc0, 0xd0, 0xf7, 0xb8, 0x97, 0x8c,
	0xbd, 0x08, 0x7b, 0x72, 0x2f, 0x5a, 0xf6, 0x7d, 0xb2, 0x0b, 0xb5, 0xbb, 0x05, 0xcc, 0xb2, 0xa5,
	0x39, 0x06, 0xd5, 0x67, 0xf3, 0x93, 0x23, 0x90, 0x6d, 0x5c, 0x3e, 0x4d, 0xd0, 0x5c, 0x93, 0x53,
	0x39, 0x4b, 0xa6, 0x6a, 0xab, 0x9f, 0x3e, 0xde, 0x84, 0x3e, 0x7e, 0x9b, 0x26, 0x48, 0x75, 0x51,
	0x2a, 0x9e, 0xc8, 0x4b, 0x30, 0x02, 0x89, 0xbb, 0x51, 0x36, 0xb9, 0xc4, 0xd4, 0xac, 0xc8, 0x3e,
	0x75, 0x05, 0x8e, 0x24, 0x46, 0x5a, 0xa0, 0x5f, 0x85, 0x63, 0x8c, 0xbc, 0x09, 0x9a, 0x55, 0x4b,
	0x73, 0x6a, 0xf4, 0xee, 0xbf, 0x20, 0x18, 0x87, 0xd1, 0x0f, 0x0c, 0x5c, 0x35, 0x9a, 0xb9, 0x6e,
	0x69, 0x8e, 0x4e, 0xeb, 0x0a, 0xcc, 0x37, 0x77, 0xa0, 0xc9, 0xbd, 0xf4, 0x1a, 0xb9, 0x3b, 0x5f,
	0x68, 0x43, 0x36, 0x6a, 0x28, 0xfc, 0x7c, 0xb6, 0xd6, 0x01, 0x6c, 0xe7, 0x29, 0x2c, 0xbc, 0x45,
	0xf7, 0x72, 0xca, 0x91, 0x99, 0xba, 0xa5, 0x39, 0x15, 0xba, 0xa5, 0x02, 0x67, 0xe1, 0x2d, 0x76,
	0x05, 0x4c, 0x3e, 0x42, 0x55, 0x1c, 0x85, 0x99, 0x35, 0x29, 0xe9, 0xfe, 0x8a, 0xa3, 0xa8, 0xeb,
	0x52, 0x95, 0x4f, 0x3e, 0xc0, 0x3a, 0x93, 0xc7, 0x35, 0x41, 0x56, 0xee, 0xad, 0xa8, 0xcc, 0x18,
	0xcd, 0x93, 0xed, 0xb7, 0xd0, 0x5c, 0x54, 0x92, 0xe8, 0x50, 0x19, 0x0c, 0x8f, 0x8f, 0x9a, 0x25,
	0x62, 0x40, 0x6d, 0xd4, 0xed, 0xbb, 0xdd, 0xe3, 0xd3, 0xde, 0xe7, 0xa6, 0x66, 0x1f, 0x42, 0xbd,
	0x68, 0x49, 0xf2, 0x0e, 0x36, 0xd4, 0xfc, 0xca, 0x8a, 0x9b, 0x9d, 0x9d, 0x25, 0x4d, 0xe9, 0x2c,
	0xcf, 0xee, 0xc2, 0xce, 0x80, 0x7d, 0x49, 0x91, 0x61, 0x24, 0x56, 0x88, 0xa3, 0xb9, 0xb7, 0xdf,
	0xc0, 0x56, 0x52, 0x08, 0x08, 0x3d, 0x95, 0xc1, 0x1b, 0x45, 0x78, 0x18, 0xd8, 0x3f, 0x35, 0x61,
	0xe8, 0x22, 0xc9, 0x63, 0x6c, 0xc8, 0xe2, 0x2c, 0xf5, 0x8b, 0x36, 0x54, 0xc0, 0x30, 0x10, 0xc1,
	0xfc, 0xb2, 0x61, 0x20, 0x6d, 0x68, 0x50, 0x5d, 0x01, 0xc3, 0xa0, 0xa0, 0x73, 0xf5, 0x5f, 0x74,
	0xbe, 0x10, 0x6f, 0xe6, 0xe2, 0xde, 0xa4, 0x07, 0x46, 0x71, 0xb7, 0x99, 0x8c, 0x0f, 0x39, 0x8b,
	0x95, 0xf4, 0x7e, 0xcd, 0xc1, 0x2b, 0x30, 0xee, 0xbd, 0xab, 0xe2, 0x7e, 0xa3, 0xd3, 0x91, 0xb8,
	0x5f, 0x0d, 0xaa, 0xf4, 0xe8, 0xb0, 0x7f, 0xd1, 0xd4, 0x3a, 0xbf, 0x2a, 0x50, 0x1e, 0x30, 0xd2,
	0x83, 0xba, 0x4a, 0xed, 0xa5, 0x28, 0x72, 0x97, 0x5d, 0xac, 0x65, 0x2e, 0x04, 0x68, 0xe2, 0x53,
	0x64, 0xd9, 0x98, 0xdb, 0xa5, 0x39, 0xc9, 0xf7, 0x24, 0x78, 0x3a, 0x49, 0x1f, 0xc7, 0xf8, 0x58,
	0x92, 0x13, 0x80, 0x82, 0x1f, 0xad, 0x25, 0x14, 0x77, 0x1e, 0x6b, 0xed, 0xae, 0xc8, 0xb0, 0x4b,
	0xe4, 0x14, 0x48, 0x51, 0xe9, 0x5c, 0xa3, 0xd5, 0xe7, 0x58, 0x39, 0xdf, 0x02, 0x61, 0xae, 0xd7,
	0xff, 0x23, 0xcc, 0xb5, 0x7b, 0x02, 0xa1, 0x0b, 0xcd, 0x07, 0xb6, 0x7c, 0xbd, 0x92, 0x6e, 0xae,
	0xe6, 0xfe, 0x5f, 0xf3, 0xec, 0xd2, 0xe5, 0xba, 0xfc, 0x9c, 0xbd, 0xff, 0x13, 0x00, 0x00, 0xff,
	0xff, 0xf8, 0x12, 0xc1, 0x50, 0xf7, 0x06, 0x00, 0x00,
}
