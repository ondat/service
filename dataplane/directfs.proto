syntax = "proto3";
package storageos_rpc;

import "common.proto";

/**
 * DirectFS client configuration and status service.
 */
service FsClient {
    /**
     * Add a remote host entry to be used by volumes.
     *
     * returns RpcResult
     */
    rpc ServerCreate(DfsHost) returns (RpcResult) {}

    /**
     * Update a remote host entry to be used by volumes.
     *
     * returns RpcResult
     */
    rpc ServerUpdate(DfsHost) returns (RpcResult) {}

    /**
     * Remove a remote host entry.
     *
     * This will likely result in any volumes using this host to
     * become unconfigured. That has serious consequences.
     *
     * returns RpcResult
     */
    rpc ServerDelete(DfsHost) returns (RpcResult) {}

    /**
     * List configured host entries, optionally filtered via a DfsHostListQuery
     * message.
     *
     * returns A DfsHostList message containing DfsHost messages,
     *         if any are available matching the filter.
     */
    rpc ServerList(DfsHostListQuery) returns (DfsHostList) {}

    /**
     * Create a volume on a remote host. The DfsHost matching the host id
     * in the DfsVolume message must be configured for the volume to actually
     * be configured on the DirectFS client.
     *
     * returns RpcResult
     */
    rpc VolumeCreate(DfsVolume) returns (RpcResult) {}

    /**
     * Update a volume on a remote host. The DfsHost matching the host id
     * in the DfsVolume message must be configured for the volume to actually
     * be configured on the DirectFS client.
     *
     * returns RpcResult
     */
    rpc VolumeUpdate(DfsVolume) returns (RpcResult) {}

    /**
     * Delete a volume previously configured by VolumeCreate.
     *
     * returns RpcResult
     */
    rpc VolumeDelete(DfsVolume) returns (RpcResult) {}

    /**
     * List configured volume entries, optionally filtered via a DfsVolumeListQuery
     * message.
     *
     * returns A DfsVolumeList message containing DfsVolume messages,
     *         if any are available matching the filter.
     */
    rpc VolumeList(DfsVolumeListQuery) returns (DfsVolumeList) {}
}

/**
 * DirectFS server configuration and status service.
 */
service FsServer {
    /**
     * Create a volume to be served via DFS. Currently does nothing, but should still
     * be performed as in the near future it will certainly be required.
     *
     * returns RpcResult
     */
    rpc VolumeCreate(DfsVolume) returns (RpcResult) {}

    /**
     * Update a volume to be served via DFS. Currently does nothing, but should still
     * be performed as in the near future it will certainly be required.
     *
     * returns RpcResult
     */
    rpc VolumeUpdate(DfsVolume) returns (RpcResult) {}

    /**
     * Delete a volume to be served via DFS. Currently does nothing, but should still
     * be performed as in the near future it will certainly be required.
     *
     * returns RpcResult
     */
    rpc VolumeDelete(DfsVolume) returns (RpcResult) {}

    /**
     * List configured volume entries, optionally filtered via a DfsVolumeListQuery
     * message.
     *
     * returns a stream of DfsVolume messages, if any are available matching the filter.
     */
    rpc VolumeList(DfsVolumeListQuery) returns (stream DfsVolume) {}
}


message DfsHostCredentials {
    // Empty for now.
    // Could be used for:
    // - (server) tls creds (if per-host)
    // - (client) tls creds (if per-host)
}

/**
 * A host used by DirectFS.
 */
message DfsHost {
    DataplaneCommon cc = 1;

    // The unique host identifier.
    uint32 host_id = 2;

    // The remote hostname.
    string hostname = 3;

    // The remote port.
    uint32 port = 4;

    // Host credentials.
    DfsHostCredentials credentials = 5;
}

message DfsHostList {
    repeated DfsHost hosts = 1;
}

message DfsHostListQuery {
    // An optional list of hosts to query.
    repeated DfsHost host_ids = 1;
}

message DfsVolumeCredentials {
    // Empty for now.
    // Could be used for:
    // - (server) tls creds (if per-volume), valid client IPs
    // - (client) tls creds (if per-volume)
}

message DfsVolumeStatistics {
    // Empty for now.
}

message DfsVolumeStatus {

    enum DfsConnectionState {
        NONE = 0;
        CONNECTING = 1;
        CONNECTED = 2;
        DISCONNECTING = 3;
        DISCONNECTED = 4;
    }

    DfsConnectionState conn_state = 1;

    // The remote peer, in string form for simplicity.
    string peer_name = 2;

    enum DfsAddressFamily {
        IPV4 = 0;
        IPV6 = 1;
    }

    // The address family we're using to connect to the peer.
    DfsAddressFamily peer_af = 3;
}

/**
 * A volume used by DirectFS.
 *
 * The remote host (for the client) isn't directly included here. However, the
 * client clearly can't connect without a properly configured host_id item.
 *
 * The split between host and volume objects was decided based on now-irrelevant
 * implementation details of ConfigFS v1. However, there's still some logic to
 * it if the authentication (especially TLS) is per-host rather than per-volume.
 */
message DfsVolume {
    DataplaneCommon cc = 1;

    // The volume ID.
    uint32 volume_id = 2;

    // The host for this volume.
    uint32 host_id = 3;

    // Volume credentials.
    DfsVolumeCredentials credentials = 4;

    // Volume statistics.
    DfsVolumeStatistics stats = 5;

    // Server status for the volume.
    DfsVolumeStatus status = 6;
}

message DfsVolumeList {
    repeated DfsVolumeList volumes = 1;
}

message DfsVolumeListQuery {
    // An optional list of volumes to query.
    repeated DfsVolume volume_ids = 1;
}
