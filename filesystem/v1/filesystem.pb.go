// Code generated by protoc-gen-go. DO NOT EDIT.
// source: filesystem.proto

package v1

import (
	v1 "code.storageos.net/storageos/service/common/v1"
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FsVolumeState int32

const (
	FsVolumeState_NONE  FsVolumeState = 0
	FsVolumeState_READY FsVolumeState = 1
)

var FsVolumeState_name = map[int32]string{
	0: "NONE",
	1: "READY",
}

var FsVolumeState_value = map[string]int32{
	"NONE":  0,
	"READY": 1,
}

func (x FsVolumeState) String() string {
	return proto.EnumName(FsVolumeState_name, int32(x))
}

func (FsVolumeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{0}
}

type FsVolume_VolumeDeviceType int32

const (
	FsVolume_FILE      FsVolume_VolumeDeviceType = 0
	FsVolume_NBD_BLOCK FsVolume_VolumeDeviceType = 1
)

var FsVolume_VolumeDeviceType_name = map[int32]string{
	0: "FILE",
	1: "NBD_BLOCK",
}

var FsVolume_VolumeDeviceType_value = map[string]int32{
	"FILE":      0,
	"NBD_BLOCK": 1,
}

func (x FsVolume_VolumeDeviceType) String() string {
	return proto.EnumName(FsVolume_VolumeDeviceType_name, int32(x))
}

func (FsVolume_VolumeDeviceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{5, 0}
}

type FsVolume_VolumeControlStatus int32

const (
	FsVolume_NONE        FsVolume_VolumeControlStatus = 0
	FsVolume_ACTIVE      FsVolume_VolumeControlStatus = 1
	FsVolume_UNAVAILABLE FsVolume_VolumeControlStatus = 2
	FsVolume_FAILED      FsVolume_VolumeControlStatus = 3
	FsVolume_DELETING    FsVolume_VolumeControlStatus = 4
)

var FsVolume_VolumeControlStatus_name = map[int32]string{
	0: "NONE",
	1: "ACTIVE",
	2: "UNAVAILABLE",
	3: "FAILED",
	4: "DELETING",
}

var FsVolume_VolumeControlStatus_value = map[string]int32{
	"NONE":        0,
	"ACTIVE":      1,
	"UNAVAILABLE": 2,
	"FAILED":      3,
	"DELETING":    4,
}

func (x FsVolume_VolumeControlStatus) String() string {
	return proto.EnumName(FsVolume_VolumeControlStatus_name, int32(x))
}

func (FsVolume_VolumeControlStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{5, 1}
}

type FsStatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsStatusRequest) Reset()         { *m = FsStatusRequest{} }
func (m *FsStatusRequest) String() string { return proto.CompactTextString(m) }
func (*FsStatusRequest) ProtoMessage()    {}
func (*FsStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{0}
}

func (m *FsStatusRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsStatusRequest.Unmarshal(m, b)
}
func (m *FsStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsStatusRequest.Marshal(b, m, deterministic)
}
func (m *FsStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsStatusRequest.Merge(m, src)
}
func (m *FsStatusRequest) XXX_Size() int {
	return xxx_messageInfo_FsStatusRequest.Size(m)
}
func (m *FsStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FsStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FsStatusRequest proto.InternalMessageInfo

type FsStatus struct {
	// The version control info string.
	VersionInfo string `protobuf:"bytes,1,opt,name=version_info,json=versionInfo,proto3" json:"version_info,omitempty"`
	// Generic daemon status.
	Status               *v1.DaemonStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *FsStatus) Reset()         { *m = FsStatus{} }
func (m *FsStatus) String() string { return proto.CompactTextString(m) }
func (*FsStatus) ProtoMessage()    {}
func (*FsStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{1}
}

func (m *FsStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsStatus.Unmarshal(m, b)
}
func (m *FsStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsStatus.Marshal(b, m, deterministic)
}
func (m *FsStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsStatus.Merge(m, src)
}
func (m *FsStatus) XXX_Size() int {
	return xxx_messageInfo_FsStatus.Size(m)
}
func (m *FsStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FsStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FsStatus proto.InternalMessageInfo

func (m *FsStatus) GetVersionInfo() string {
	if m != nil {
		return m.VersionInfo
	}
	return ""
}

func (m *FsStatus) GetStatus() *v1.DaemonStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type FsVolumeListQuery struct {
	// A possibly-empty list of volume IDs to query.
	VolumeIds            []uint32 `protobuf:"varint,1,rep,packed,name=volume_ids,json=volumeIds,proto3" json:"volume_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsVolumeListQuery) Reset()         { *m = FsVolumeListQuery{} }
func (m *FsVolumeListQuery) String() string { return proto.CompactTextString(m) }
func (*FsVolumeListQuery) ProtoMessage()    {}
func (*FsVolumeListQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{2}
}

func (m *FsVolumeListQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsVolumeListQuery.Unmarshal(m, b)
}
func (m *FsVolumeListQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsVolumeListQuery.Marshal(b, m, deterministic)
}
func (m *FsVolumeListQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsVolumeListQuery.Merge(m, src)
}
func (m *FsVolumeListQuery) XXX_Size() int {
	return xxx_messageInfo_FsVolumeListQuery.Size(m)
}
func (m *FsVolumeListQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_FsVolumeListQuery.DiscardUnknown(m)
}

var xxx_messageInfo_FsVolumeListQuery proto.InternalMessageInfo

func (m *FsVolumeListQuery) GetVolumeIds() []uint32 {
	if m != nil {
		return m.VolumeIds
	}
	return nil
}

type FsVolumeStatistics struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsVolumeStatistics) Reset()         { *m = FsVolumeStatistics{} }
func (m *FsVolumeStatistics) String() string { return proto.CompactTextString(m) }
func (*FsVolumeStatistics) ProtoMessage()    {}
func (*FsVolumeStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{3}
}

func (m *FsVolumeStatistics) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsVolumeStatistics.Unmarshal(m, b)
}
func (m *FsVolumeStatistics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsVolumeStatistics.Marshal(b, m, deterministic)
}
func (m *FsVolumeStatistics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsVolumeStatistics.Merge(m, src)
}
func (m *FsVolumeStatistics) XXX_Size() int {
	return xxx_messageInfo_FsVolumeStatistics.Size(m)
}
func (m *FsVolumeStatistics) XXX_DiscardUnknown() {
	xxx_messageInfo_FsVolumeStatistics.DiscardUnknown(m)
}

var xxx_messageInfo_FsVolumeStatistics proto.InternalMessageInfo

type FsVolumeStatus struct {
	// State of the volume device node (file/block device).
	NodeState            FsVolumeState `protobuf:"varint,1,opt,name=node_state,json=nodeState,proto3,enum=filesystem.v1.FsVolumeState" json:"node_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *FsVolumeStatus) Reset()         { *m = FsVolumeStatus{} }
func (m *FsVolumeStatus) String() string { return proto.CompactTextString(m) }
func (*FsVolumeStatus) ProtoMessage()    {}
func (*FsVolumeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{4}
}

func (m *FsVolumeStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsVolumeStatus.Unmarshal(m, b)
}
func (m *FsVolumeStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsVolumeStatus.Marshal(b, m, deterministic)
}
func (m *FsVolumeStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsVolumeStatus.Merge(m, src)
}
func (m *FsVolumeStatus) XXX_Size() int {
	return xxx_messageInfo_FsVolumeStatus.Size(m)
}
func (m *FsVolumeStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FsVolumeStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FsVolumeStatus proto.InternalMessageInfo

func (m *FsVolumeStatus) GetNodeState() FsVolumeState {
	if m != nil {
		return m.NodeState
	}
	return FsVolumeState_NONE
}

//*
// A StorageOS volume to be presented via the FUSE filesystem.
type FsVolume struct {
	Cc *v1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc,proto3" json:"cc,omitempty"`
	// The volume ID to represent.
	VolumeId uint32 `protobuf:"varint,2,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	// The type for this volume.
	NodeType FsVolume_VolumeDeviceType `protobuf:"varint,3,opt,name=node_type,json=nodeType,proto3,enum=filesystem.v1.FsVolume_VolumeDeviceType" json:"node_type,omitempty"`
	// The control plane's desired state for this volume.
	ControlStatus FsVolume_VolumeControlStatus `protobuf:"varint,10,opt,name=control_status,json=controlStatus,proto3,enum=filesystem.v1.FsVolume_VolumeControlStatus" json:"control_status,omitempty"`
	// An opaque value interpreted based on node_type.
	DeviceNumber uint32 `protobuf:"varint,4,opt,name=device_number,json=deviceNumber,proto3" json:"device_number,omitempty"`
	// The filename of the underlying volume to present in the filesystem.
	Filename string `protobuf:"bytes,5,opt,name=filename,proto3" json:"filename,omitempty"`
	// The filename of the presentation node, to which users actually connect.
	PresentationFilename string `protobuf:"bytes,9,opt,name=presentation_filename,json=presentationFilename,proto3" json:"presentation_filename,omitempty"`
	// The volume size in bytes.
	VolumeSizeBytes uint64 `protobuf:"varint,6,opt,name=volume_size_bytes,json=volumeSizeBytes,proto3" json:"volume_size_bytes,omitempty"`
	// Volume statistics.
	Stats *FsVolumeStatistics `protobuf:"bytes,7,opt,name=stats,proto3" json:"stats,omitempty"`
	// Volume status, e.g. readiness.
	Status               *FsVolumeStatus `protobuf:"bytes,8,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FsVolume) Reset()         { *m = FsVolume{} }
func (m *FsVolume) String() string { return proto.CompactTextString(m) }
func (*FsVolume) ProtoMessage()    {}
func (*FsVolume) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{5}
}

func (m *FsVolume) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsVolume.Unmarshal(m, b)
}
func (m *FsVolume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsVolume.Marshal(b, m, deterministic)
}
func (m *FsVolume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsVolume.Merge(m, src)
}
func (m *FsVolume) XXX_Size() int {
	return xxx_messageInfo_FsVolume.Size(m)
}
func (m *FsVolume) XXX_DiscardUnknown() {
	xxx_messageInfo_FsVolume.DiscardUnknown(m)
}

var xxx_messageInfo_FsVolume proto.InternalMessageInfo

func (m *FsVolume) GetCc() *v1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *FsVolume) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *FsVolume) GetNodeType() FsVolume_VolumeDeviceType {
	if m != nil {
		return m.NodeType
	}
	return FsVolume_FILE
}

func (m *FsVolume) GetControlStatus() FsVolume_VolumeControlStatus {
	if m != nil {
		return m.ControlStatus
	}
	return FsVolume_NONE
}

func (m *FsVolume) GetDeviceNumber() uint32 {
	if m != nil {
		return m.DeviceNumber
	}
	return 0
}

func (m *FsVolume) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *FsVolume) GetPresentationFilename() string {
	if m != nil {
		return m.PresentationFilename
	}
	return ""
}

func (m *FsVolume) GetVolumeSizeBytes() uint64 {
	if m != nil {
		return m.VolumeSizeBytes
	}
	return 0
}

func (m *FsVolume) GetStats() *FsVolumeStatistics {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *FsVolume) GetStatus() *FsVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type FsVolumeList struct {
	Volumes              []*FsVolume `protobuf:"bytes,1,rep,name=volumes,proto3" json:"volumes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *FsVolumeList) Reset()         { *m = FsVolumeList{} }
func (m *FsVolumeList) String() string { return proto.CompactTextString(m) }
func (*FsVolumeList) ProtoMessage()    {}
func (*FsVolumeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{6}
}

func (m *FsVolumeList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsVolumeList.Unmarshal(m, b)
}
func (m *FsVolumeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsVolumeList.Marshal(b, m, deterministic)
}
func (m *FsVolumeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsVolumeList.Merge(m, src)
}
func (m *FsVolumeList) XXX_Size() int {
	return xxx_messageInfo_FsVolumeList.Size(m)
}
func (m *FsVolumeList) XXX_DiscardUnknown() {
	xxx_messageInfo_FsVolumeList.DiscardUnknown(m)
}

var xxx_messageInfo_FsVolumeList proto.InternalMessageInfo

func (m *FsVolumeList) GetVolumes() []*FsVolume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type FsPresentationListQuery struct {
	// A possibly-empty list of volume IDs to query.
	PresentationIds      []uint32 `protobuf:"varint,1,rep,packed,name=presentation_ids,json=presentationIds,proto3" json:"presentation_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsPresentationListQuery) Reset()         { *m = FsPresentationListQuery{} }
func (m *FsPresentationListQuery) String() string { return proto.CompactTextString(m) }
func (*FsPresentationListQuery) ProtoMessage()    {}
func (*FsPresentationListQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{7}
}

func (m *FsPresentationListQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsPresentationListQuery.Unmarshal(m, b)
}
func (m *FsPresentationListQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsPresentationListQuery.Marshal(b, m, deterministic)
}
func (m *FsPresentationListQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsPresentationListQuery.Merge(m, src)
}
func (m *FsPresentationListQuery) XXX_Size() int {
	return xxx_messageInfo_FsPresentationListQuery.Size(m)
}
func (m *FsPresentationListQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_FsPresentationListQuery.DiscardUnknown(m)
}

var xxx_messageInfo_FsPresentationListQuery proto.InternalMessageInfo

func (m *FsPresentationListQuery) GetPresentationIds() []uint32 {
	if m != nil {
		return m.PresentationIds
	}
	return nil
}

//*
// Presentation volume message for Fs RPCs.
//
// The minimum amount of information required to specify the 'presentation' or source volume,
// the volume that is presented to the user and (usually) mounted. All actual work
// is done on the target volume, which has actual storage associated with it.
//
// In order to discover information about the type of volume to present, the target
// volume has to be fetched regardless. As a result, there's no need to duplicate fields
// here, we just need enough information to get from the presentation node to the target,
// and to know when the presentation is actually available to the user.
type FsPresentation struct {
	Cc *v1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc,proto3" json:"cc,omitempty"`
	// The inode the user mounts or opens.
	PresentationId uint32 `protobuf:"varint,2,opt,name=presentation_id,json=presentationId,proto3" json:"presentation_id,omitempty"`
	// The underlying inode of the StorageOS volume.
	TargetId uint32 `protobuf:"varint,3,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	// Presentation inode status, e.g. readiness.
	Status               *FsVolumeStatus `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *FsPresentation) Reset()         { *m = FsPresentation{} }
func (m *FsPresentation) String() string { return proto.CompactTextString(m) }
func (*FsPresentation) ProtoMessage()    {}
func (*FsPresentation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{8}
}

func (m *FsPresentation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsPresentation.Unmarshal(m, b)
}
func (m *FsPresentation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsPresentation.Marshal(b, m, deterministic)
}
func (m *FsPresentation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsPresentation.Merge(m, src)
}
func (m *FsPresentation) XXX_Size() int {
	return xxx_messageInfo_FsPresentation.Size(m)
}
func (m *FsPresentation) XXX_DiscardUnknown() {
	xxx_messageInfo_FsPresentation.DiscardUnknown(m)
}

var xxx_messageInfo_FsPresentation proto.InternalMessageInfo

func (m *FsPresentation) GetCc() *v1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *FsPresentation) GetPresentationId() uint32 {
	if m != nil {
		return m.PresentationId
	}
	return 0
}

func (m *FsPresentation) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *FsPresentation) GetStatus() *FsVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type FsPresentationList struct {
	Presentations        []*FsPresentation `protobuf:"bytes,1,rep,name=presentations,proto3" json:"presentations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FsPresentationList) Reset()         { *m = FsPresentationList{} }
func (m *FsPresentationList) String() string { return proto.CompactTextString(m) }
func (*FsPresentationList) ProtoMessage()    {}
func (*FsPresentationList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{9}
}

func (m *FsPresentationList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsPresentationList.Unmarshal(m, b)
}
func (m *FsPresentationList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsPresentationList.Marshal(b, m, deterministic)
}
func (m *FsPresentationList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsPresentationList.Merge(m, src)
}
func (m *FsPresentationList) XXX_Size() int {
	return xxx_messageInfo_FsPresentationList.Size(m)
}
func (m *FsPresentationList) XXX_DiscardUnknown() {
	xxx_messageInfo_FsPresentationList.DiscardUnknown(m)
}

var xxx_messageInfo_FsPresentationList proto.InternalMessageInfo

func (m *FsPresentationList) GetPresentations() []*FsPresentation {
	if m != nil {
		return m.Presentations
	}
	return nil
}

func init() {
	proto.RegisterEnum("filesystem.v1.FsVolumeState", FsVolumeState_name, FsVolumeState_value)
	proto.RegisterEnum("filesystem.v1.FsVolume_VolumeDeviceType", FsVolume_VolumeDeviceType_name, FsVolume_VolumeDeviceType_value)
	proto.RegisterEnum("filesystem.v1.FsVolume_VolumeControlStatus", FsVolume_VolumeControlStatus_name, FsVolume_VolumeControlStatus_value)
	proto.RegisterType((*FsStatusRequest)(nil), "filesystem.v1.FsStatusRequest")
	proto.RegisterType((*FsStatus)(nil), "filesystem.v1.FsStatus")
	proto.RegisterType((*FsVolumeListQuery)(nil), "filesystem.v1.FsVolumeListQuery")
	proto.RegisterType((*FsVolumeStatistics)(nil), "filesystem.v1.FsVolumeStatistics")
	proto.RegisterType((*FsVolumeStatus)(nil), "filesystem.v1.FsVolumeStatus")
	proto.RegisterType((*FsVolume)(nil), "filesystem.v1.FsVolume")
	proto.RegisterType((*FsVolumeList)(nil), "filesystem.v1.FsVolumeList")
	proto.RegisterType((*FsPresentationListQuery)(nil), "filesystem.v1.FsPresentationListQuery")
	proto.RegisterType((*FsPresentation)(nil), "filesystem.v1.FsPresentation")
	proto.RegisterType((*FsPresentationList)(nil), "filesystem.v1.FsPresentationList")
}

func init() { proto.RegisterFile("filesystem.proto", fileDescriptor_0a9f8093c6c7067e) }

var fileDescriptor_0a9f8093c6c7067e = []byte{
	// 956 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x5b, 0x6f, 0xe2, 0x46,
	0x14, 0x06, 0x12, 0x58, 0x38, 0xe1, 0xe2, 0x4c, 0xb3, 0x0a, 0x75, 0x36, 0x2d, 0x71, 0xab, 0x96,
	0x66, 0x25, 0x50, 0x48, 0xab, 0x3e, 0xf4, 0xa1, 0xe2, 0xba, 0x72, 0x43, 0xd8, 0xd6, 0xb9, 0x48,
	0xdb, 0x87, 0x5a, 0xc4, 0x4c, 0x22, 0x4b, 0xe0, 0xa1, 0x9e, 0x01, 0x89, 0x7d, 0xef, 0x8f, 0xea,
	0x0f, 0xe9, 0xff, 0xa9, 0xe6, 0x02, 0x0c, 0x31, 0xb0, 0x22, 0xed, 0x53, 0xec, 0x73, 0xce, 0xf7,
	0x9d, 0xf3, 0x9d, 0x8b, 0x03, 0x18, 0x8f, 0xfe, 0x10, 0xd3, 0x19, 0x65, 0x78, 0x54, 0x19, 0x87,
	0x84, 0x11, 0x94, 0xd3, 0x2c, 0xd3, 0x0b, 0x33, 0xeb, 0x91, 0xd1, 0x88, 0x04, 0xd2, 0x69, 0x1d,
	0x42, 0xa1, 0x43, 0x6f, 0x58, 0x9f, 0x4d, 0xa8, 0x83, 0xff, 0x9c, 0x60, 0xca, 0xac, 0x3f, 0x20,
	0x3d, 0x37, 0xa1, 0x33, 0xc8, 0x4e, 0x71, 0x48, 0x7d, 0x12, 0xb8, 0x7e, 0xf0, 0x48, 0x8a, 0xf1,
	0x52, 0xbc, 0x9c, 0x71, 0x0e, 0x94, 0xcd, 0x0e, 0x1e, 0x09, 0xaa, 0x42, 0x8a, 0x8a, 0xe0, 0x62,
	0xa2, 0x14, 0x2f, 0x1f, 0xd4, 0x8e, 0x2b, 0x2a, 0xc1, 0xf4, 0xa2, 0xd2, 0xea, 0xe3, 0x11, 0x09,
	0x14, 0xbd, 0x0a, 0xb3, 0x6a, 0x70, 0xd8, 0xa1, 0xf7, 0x64, 0x38, 0x19, 0xe1, 0xae, 0x4f, 0xd9,
	0x6f, 0x13, 0x1c, 0xce, 0xd0, 0x29, 0xc0, 0x54, 0x98, 0x5c, 0x7f, 0x40, 0x8b, 0xf1, 0xd2, 0x5e,
	0x39, 0xe7, 0x64, 0xa4, 0xc5, 0x1e, 0x50, 0xeb, 0x08, 0xd0, 0x1c, 0xc3, 0xd9, 0x7c, 0xca, 0x7c,
	0x8f, 0x5a, 0xd7, 0x90, 0xd7, 0xad, 0x13, 0x8a, 0x7e, 0x02, 0x08, 0xc8, 0x00, 0xbb, 0x3c, 0x15,
	0x16, 0xd5, 0xe6, 0x6b, 0x6f, 0x2a, 0x2b, 0x0d, 0xa8, 0xe8, 0x10, 0xec, 0x64, 0x78, 0xbc, 0x78,
	0xb4, 0xfe, 0x4a, 0x72, 0xe5, 0xd2, 0x89, 0xce, 0x21, 0xe1, 0x79, 0x82, 0xe1, 0xa0, 0x66, 0xae,
	0x48, 0x62, 0xfd, 0xf1, 0xb0, 0x1f, 0xe0, 0xa6, 0x30, 0x39, 0x09, 0xcf, 0x43, 0x27, 0x90, 0x59,
	0x14, 0x2f, 0xba, 0x90, 0x73, 0xd2, 0xf3, 0xda, 0x51, 0x1b, 0x44, 0x0a, 0x97, 0xcd, 0xc6, 0xb8,
	0xb8, 0x27, 0x2a, 0x2a, 0x6f, 0xa8, 0xa8, 0x22, 0xff, 0xb4, 0xf0, 0xd4, 0xf7, 0xf0, 0xed, 0x6c,
	0x8c, 0x9d, 0x34, 0x87, 0xf2, 0x27, 0xe4, 0x40, 0xde, 0x23, 0x01, 0x0b, 0xc9, 0xd0, 0x55, 0xed,
	0x06, 0xc1, 0xf5, 0x76, 0x3b, 0x57, 0x53, 0x62, 0xd4, 0x08, 0x72, 0x9e, 0xfe, 0x8a, 0xbe, 0x82,
	0xdc, 0x40, 0xe4, 0x72, 0x83, 0xc9, 0xe8, 0x01, 0x87, 0xc5, 0x7d, 0x51, 0x7b, 0x56, 0x1a, 0x7b,
	0xc2, 0x86, 0x4c, 0x48, 0xf3, 0x0c, 0x41, 0x7f, 0x84, 0x8b, 0x49, 0x31, 0xfe, 0xc5, 0x3b, 0xba,
	0x84, 0xd7, 0xe3, 0x10, 0x53, 0x1c, 0xf0, 0x99, 0x90, 0xc0, 0x5d, 0x04, 0x66, 0x44, 0xe0, 0x91,
	0xee, 0xec, 0xcc, 0x41, 0xe7, 0x70, 0xa8, 0xba, 0x45, 0xfd, 0x8f, 0xd8, 0x7d, 0x98, 0x31, 0x4c,
	0x8b, 0xa9, 0x52, 0xbc, 0xbc, 0xef, 0x14, 0xa4, 0xe3, 0xc6, 0xff, 0x88, 0x1b, 0xdc, 0x8c, 0x7e,
	0x84, 0x24, 0x57, 0x4b, 0x8b, 0xaf, 0xc4, 0x20, 0xce, 0xb6, 0x8c, 0x52, 0xee, 0x84, 0x23, 0xe3,
	0xd1, 0x0f, 0x8b, 0xad, 0x4c, 0x0b, 0xe4, 0xe9, 0x16, 0xa4, 0xb6, 0x9b, 0x6f, 0xc1, 0x78, 0x3e,
	0x03, 0x94, 0x86, 0xfd, 0x8e, 0xdd, 0x6d, 0x1b, 0x31, 0x94, 0x83, 0x4c, 0xaf, 0xd1, 0x72, 0x1b,
	0xdd, 0xf7, 0xcd, 0x2b, 0x23, 0x6e, 0xdd, 0xc3, 0x67, 0x6b, 0x9a, 0xcc, 0xe3, 0x7b, 0xef, 0x7b,
	0x3c, 0x1e, 0x20, 0x55, 0x6f, 0xde, 0xda, 0xf7, 0x6d, 0x23, 0x8e, 0x0a, 0x70, 0x70, 0xd7, 0xab,
	0xdf, 0xd7, 0xed, 0x6e, 0xbd, 0xd1, 0x6d, 0x1b, 0x09, 0xee, 0xec, 0xd4, 0xed, 0x6e, 0xbb, 0x65,
	0xec, 0xa1, 0x2c, 0xa4, 0x5b, 0xed, 0x6e, 0xfb, 0xd6, 0xee, 0xbd, 0x33, 0xf6, 0xad, 0x3a, 0x64,
	0xf5, 0x03, 0x41, 0x17, 0xf0, 0x4a, 0xf6, 0x45, 0x1e, 0x06, 0x3f, 0xb1, 0xf5, 0x62, 0x9c, 0x79,
	0x9c, 0xd5, 0x82, 0xe3, 0x0e, 0xfd, 0x55, 0xeb, 0xfe, 0xf2, 0xd2, 0xbe, 0x03, 0x63, 0x65, 0x66,
	0xcb, 0x7b, 0x2b, 0xe8, 0x76, 0x7e, 0x75, 0x7f, 0xc7, 0xf9, 0x81, 0xe9, 0x34, 0x3b, 0x9d, 0xc5,
	0xb7, 0x50, 0x78, 0x96, 0x49, 0x1d, 0x47, 0x7e, 0x35, 0x11, 0xbf, 0x1f, 0xd6, 0x0f, 0x9f, 0x30,
	0xe3, 0x21, 0x7b, 0xf2, 0x7e, 0xa4, 0xc1, 0x1e, 0x68, 0x93, 0x4c, 0xee, 0x32, 0xc9, 0x0f, 0xfc,
	0x8b, 0xf1, 0xbc, 0x03, 0xa8, 0x09, 0x39, 0x3d, 0xf7, 0xbc, 0xa1, 0x51, 0x4e, 0x1d, 0xe9, 0xac,
	0x62, 0xce, 0xbf, 0x86, 0xdc, 0xca, 0x37, 0x44, 0x9b, 0x78, 0x06, 0x92, 0x4e, 0xbb, 0xde, 0xfa,
	0x60, 0xc4, 0x6b, 0xff, 0x00, 0x24, 0x3a, 0x14, 0x35, 0x21, 0xa5, 0xf6, 0xe2, 0x8b, 0x48, 0x92,
	0x95, 0xef, 0xae, 0x79, 0xbc, 0xc1, 0x6f, 0xc5, 0xd0, 0xcf, 0x90, 0x55, 0x9b, 0x16, 0x62, 0x9e,
	0x70, 0xd3, 0x02, 0x98, 0x47, 0xda, 0x48, 0x9c, 0xb1, 0xe7, 0x60, 0x3a, 0x19, 0x32, 0x9d, 0xe0,
	0x6e, 0x3c, 0xf8, 0x6f, 0x04, 0x2d, 0x3c, 0xc4, 0x2f, 0x21, 0xb8, 0x06, 0xd0, 0x56, 0xba, 0xb4,
	0x01, 0xbe, 0x58, 0x53, 0xf3, 0x64, 0x4b, 0x84, 0x15, 0x43, 0x57, 0x80, 0xf4, 0x11, 0xa9, 0xbe,
	0x6c, 0x9f, 0xe3, 0xc6, 0xda, 0x9e, 0x91, 0xa9, 0x1e, 0xfd, 0x3f, 0x64, 0xaa, 0x5f, 0x2f, 0x24,
	0x73, 0xc1, 0x88, 0xec, 0xf0, 0x37, 0x5b, 0xa9, 0x96, 0x1d, 0x3c, 0xfb, 0x64, 0x9c, 0x15, 0x43,
	0x1d, 0xc8, 0x35, 0x49, 0xf0, 0xe8, 0x3f, 0xbd, 0xc3, 0xac, 0x41, 0xc8, 0x10, 0xe9, 0x95, 0x48,
	0xcf, 0x15, 0x9e, 0x99, 0xa7, 0x11, 0xab, 0x8a, 0x77, 0xf0, 0x78, 0x38, 0xb3, 0x62, 0xc8, 0x06,
	0x43, 0xda, 0x65, 0xf3, 0x04, 0xd5, 0xeb, 0x08, 0x88, 0x9b, 0xcd, 0x37, 0x11, 0xb3, 0xc4, 0x2c,
	0xa9, 0xf2, 0xd2, 0xcc, 0x4b, 0x14, 0x44, 0x66, 0x04, 0xb1, 0x54, 0xf9, 0xf9, 0xda, 0x24, 0x4a,
	0xdd, 0x2f, 0x50, 0x58, 0x54, 0x7b, 0xc3, 0x42, 0x3f, 0x78, 0xda, 0xa0, 0xef, 0xcb, 0x75, 0xfa,
	0x24, 0x62, 0x5e, 0xd6, 0x35, 0x20, 0xbd, 0x5a, 0x45, 0x77, 0x1c, 0x01, 0x4a, 0xc7, 0x27, 0x55,
	0x5e, 0xcf, 0x1b, 0xc6, 0x4b, 0x55, 0x64, 0xdb, 0x74, 0x9e, 0x6c, 0x48, 0xb4, 0x46, 0xe9, 0x9d,
	0x1f, 0xb0, 0xcb, 0xda, 0x2e, 0x4a, 0x25, 0x62, 0x83, 0x52, 0x45, 0x17, 0x55, 0x2a, 0x1d, 0xbb,
	0x29, 0x55, 0x64, 0xbb, 0x29, 0x95, 0x20, 0xa9, 0xb4, 0xf1, 0xfd, 0xef, 0x35, 0x8f, 0x0c, 0x70,
	0x85, 0x32, 0x12, 0xf6, 0x9f, 0x30, 0xa1, 0x95, 0x00, 0xb3, 0xea, 0xe2, 0xad, 0x4a, 0x71, 0xc8,
	0xff, 0x75, 0x57, 0x97, 0xcb, 0x5f, 0x9d, 0x5e, 0x3c, 0xa4, 0xc4, 0xcf, 0xdd, 0xcb, 0x7f, 0x03,
	0x00, 0x00, 0xff, 0xff, 0xfb, 0xe6, 0x5e, 0x0a, 0x1f, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FsClient is the client API for Fs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FsClient interface {
	//*
	// Get program status.
	Status(ctx context.Context, in *FsStatusRequest, opts ...grpc.CallOption) (*FsStatus, error)
	//*
	// Create the specified FsVolume.
	//
	// returns RpcResult
	VolumeCreate(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*v1.RpcResult, error)
	//*
	// Update the specified FsVolume.
	//
	// returns RpcResult
	VolumeUpdate(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*v1.RpcResult, error)
	//*
	// Delete the specified FsVolume.
	//
	// returns RpcResult
	VolumeDelete(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*v1.RpcResult, error)
	//*
	// Return a list of FsVolume messages, optionally filtered using the supplied
	// FsVolumeListQuery message.
	//
	// returns A FsVolumeList message containing FsVolume objects,
	//         if any are found that match the filter.
	VolumeList(ctx context.Context, in *FsVolumeListQuery, opts ...grpc.CallOption) (*FsVolumeList, error)
	//*
	// Add configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationCreate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error)
	//*
	// Update configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationUpdate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error)
	//*
	// Remove configuration for the Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationDelete(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error)
	//*
	// List configured Presentation volumes, optionally filtered using a FsPresentationListQuery
	// message.
	//
	// returns A FsPresentationList message containing FsPresentation mesages,
	//         if any are found matching the filter.
	PresentationList(ctx context.Context, in *FsPresentationListQuery, opts ...grpc.CallOption) (*FsPresentationList, error)
	// Config services, from common.v1.
	ConfigGetBool(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetBoolReply, error)
	ConfigUpdateBool(ctx context.Context, in *v1.ConfigBool, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListBool(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigBoolList, error)
	ConfigGetString(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetStringReply, error)
	ConfigUpdateString(ctx context.Context, in *v1.ConfigString, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListString(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigStringList, error)
	ConfigGetUint32(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint32Reply, error)
	ConfigUpdateUint32(ctx context.Context, in *v1.ConfigUint32, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListUint32(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint32List, error)
}

type fsClient struct {
	cc *grpc.ClientConn
}

func NewFsClient(cc *grpc.ClientConn) FsClient {
	return &fsClient{cc}
}

func (c *fsClient) Status(ctx context.Context, in *FsStatusRequest, opts ...grpc.CallOption) (*FsStatus, error) {
	out := new(FsStatus)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) VolumeCreate(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*v1.RpcResult, error) {
	out := new(v1.RpcResult)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/VolumeCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) VolumeUpdate(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*v1.RpcResult, error) {
	out := new(v1.RpcResult)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/VolumeUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) VolumeDelete(ctx context.Context, in *FsVolume, opts ...grpc.CallOption) (*v1.RpcResult, error) {
	out := new(v1.RpcResult)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/VolumeDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) VolumeList(ctx context.Context, in *FsVolumeListQuery, opts ...grpc.CallOption) (*FsVolumeList, error) {
	out := new(FsVolumeList)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/VolumeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationCreate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error) {
	out := new(v1.RpcResult)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/PresentationCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationUpdate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error) {
	out := new(v1.RpcResult)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/PresentationUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationDelete(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error) {
	out := new(v1.RpcResult)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/PresentationDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationList(ctx context.Context, in *FsPresentationListQuery, opts ...grpc.CallOption) (*FsPresentationList, error) {
	out := new(FsPresentationList)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/PresentationList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigGetBool(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetBoolReply, error) {
	out := new(v1.ConfigGetBoolReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigGetBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigUpdateBool(ctx context.Context, in *v1.ConfigBool, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigUpdateBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigListBool(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigBoolList, error) {
	out := new(v1.ConfigBoolList)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigListBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigGetString(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetStringReply, error) {
	out := new(v1.ConfigGetStringReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigGetString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigUpdateString(ctx context.Context, in *v1.ConfigString, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigUpdateString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigListString(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigStringList, error) {
	out := new(v1.ConfigStringList)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigListString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigGetUint32(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint32Reply, error) {
	out := new(v1.ConfigGetUint32Reply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigGetUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigUpdateUint32(ctx context.Context, in *v1.ConfigUint32, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigUpdateUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigListUint32(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint32List, error) {
	out := new(v1.ConfigUint32List)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigListUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FsServer is the server API for Fs service.
type FsServer interface {
	//*
	// Get program status.
	Status(context.Context, *FsStatusRequest) (*FsStatus, error)
	//*
	// Create the specified FsVolume.
	//
	// returns RpcResult
	VolumeCreate(context.Context, *FsVolume) (*v1.RpcResult, error)
	//*
	// Update the specified FsVolume.
	//
	// returns RpcResult
	VolumeUpdate(context.Context, *FsVolume) (*v1.RpcResult, error)
	//*
	// Delete the specified FsVolume.
	//
	// returns RpcResult
	VolumeDelete(context.Context, *FsVolume) (*v1.RpcResult, error)
	//*
	// Return a list of FsVolume messages, optionally filtered using the supplied
	// FsVolumeListQuery message.
	//
	// returns A FsVolumeList message containing FsVolume objects,
	//         if any are found that match the filter.
	VolumeList(context.Context, *FsVolumeListQuery) (*FsVolumeList, error)
	//*
	// Add configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationCreate(context.Context, *FsPresentation) (*v1.RpcResult, error)
	//*
	// Update configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationUpdate(context.Context, *FsPresentation) (*v1.RpcResult, error)
	//*
	// Remove configuration for the Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationDelete(context.Context, *FsPresentation) (*v1.RpcResult, error)
	//*
	// List configured Presentation volumes, optionally filtered using a FsPresentationListQuery
	// message.
	//
	// returns A FsPresentationList message containing FsPresentation mesages,
	//         if any are found matching the filter.
	PresentationList(context.Context, *FsPresentationListQuery) (*FsPresentationList, error)
	// Config services, from common.v1.
	ConfigGetBool(context.Context, *v1.ConfigKey) (*v1.ConfigGetBoolReply, error)
	ConfigUpdateBool(context.Context, *v1.ConfigBool) (*v1.ConfigUpdateReply, error)
	ConfigListBool(context.Context, *v1.ConfigListQuery) (*v1.ConfigBoolList, error)
	ConfigGetString(context.Context, *v1.ConfigKey) (*v1.ConfigGetStringReply, error)
	ConfigUpdateString(context.Context, *v1.ConfigString) (*v1.ConfigUpdateReply, error)
	ConfigListString(context.Context, *v1.ConfigListQuery) (*v1.ConfigStringList, error)
	ConfigGetUint32(context.Context, *v1.ConfigKey) (*v1.ConfigGetUint32Reply, error)
	ConfigUpdateUint32(context.Context, *v1.ConfigUint32) (*v1.ConfigUpdateReply, error)
	ConfigListUint32(context.Context, *v1.ConfigListQuery) (*v1.ConfigUint32List, error)
}

// UnimplementedFsServer can be embedded to have forward compatible implementations.
type UnimplementedFsServer struct {
}

func (*UnimplementedFsServer) Status(ctx context.Context, req *FsStatusRequest) (*FsStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (*UnimplementedFsServer) VolumeCreate(ctx context.Context, req *FsVolume) (*v1.RpcResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeCreate not implemented")
}
func (*UnimplementedFsServer) VolumeUpdate(ctx context.Context, req *FsVolume) (*v1.RpcResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeUpdate not implemented")
}
func (*UnimplementedFsServer) VolumeDelete(ctx context.Context, req *FsVolume) (*v1.RpcResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeDelete not implemented")
}
func (*UnimplementedFsServer) VolumeList(ctx context.Context, req *FsVolumeListQuery) (*FsVolumeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VolumeList not implemented")
}
func (*UnimplementedFsServer) PresentationCreate(ctx context.Context, req *FsPresentation) (*v1.RpcResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresentationCreate not implemented")
}
func (*UnimplementedFsServer) PresentationUpdate(ctx context.Context, req *FsPresentation) (*v1.RpcResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresentationUpdate not implemented")
}
func (*UnimplementedFsServer) PresentationDelete(ctx context.Context, req *FsPresentation) (*v1.RpcResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresentationDelete not implemented")
}
func (*UnimplementedFsServer) PresentationList(ctx context.Context, req *FsPresentationListQuery) (*FsPresentationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresentationList not implemented")
}
func (*UnimplementedFsServer) ConfigGetBool(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetBoolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetBool not implemented")
}
func (*UnimplementedFsServer) ConfigUpdateBool(ctx context.Context, req *v1.ConfigBool) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateBool not implemented")
}
func (*UnimplementedFsServer) ConfigListBool(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigBoolList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListBool not implemented")
}
func (*UnimplementedFsServer) ConfigGetString(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetStringReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetString not implemented")
}
func (*UnimplementedFsServer) ConfigUpdateString(ctx context.Context, req *v1.ConfigString) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateString not implemented")
}
func (*UnimplementedFsServer) ConfigListString(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigStringList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListString not implemented")
}
func (*UnimplementedFsServer) ConfigGetUint32(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetUint32Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetUint32 not implemented")
}
func (*UnimplementedFsServer) ConfigUpdateUint32(ctx context.Context, req *v1.ConfigUint32) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateUint32 not implemented")
}
func (*UnimplementedFsServer) ConfigListUint32(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigUint32List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListUint32 not implemented")
}

func RegisterFsServer(s *grpc.Server, srv FsServer) {
	s.RegisterService(&_Fs_serviceDesc, srv)
}

func _Fs_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).Status(ctx, req.(*FsStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).VolumeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/VolumeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).VolumeCreate(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_VolumeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).VolumeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/VolumeUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).VolumeUpdate(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_VolumeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).VolumeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/VolumeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).VolumeDelete(ctx, req.(*FsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_VolumeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsVolumeListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).VolumeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/VolumeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).VolumeList(ctx, req.(*FsVolumeListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/PresentationCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationCreate(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/PresentationUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationUpdate(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/PresentationDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationDelete(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentationListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/PresentationList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationList(ctx, req.(*FsPresentationListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigGetBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigGetBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigGetBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigGetBool(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigUpdateBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigBool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigUpdateBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigUpdateBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigUpdateBool(ctx, req.(*v1.ConfigBool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigListBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigListBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigListBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigListBool(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigGetString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigGetString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigGetString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigGetString(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigUpdateString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigUpdateString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigUpdateString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigUpdateString(ctx, req.(*v1.ConfigString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigListString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigListString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigListString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigListString(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigGetUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigGetUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigGetUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigGetUint32(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigUpdateUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigUint32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigUpdateUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigUpdateUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigUpdateUint32(ctx, req.(*v1.ConfigUint32))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigListUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigListUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigListUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigListUint32(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

var _Fs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "filesystem.v1.Fs",
	HandlerType: (*FsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _Fs_Status_Handler,
		},
		{
			MethodName: "VolumeCreate",
			Handler:    _Fs_VolumeCreate_Handler,
		},
		{
			MethodName: "VolumeUpdate",
			Handler:    _Fs_VolumeUpdate_Handler,
		},
		{
			MethodName: "VolumeDelete",
			Handler:    _Fs_VolumeDelete_Handler,
		},
		{
			MethodName: "VolumeList",
			Handler:    _Fs_VolumeList_Handler,
		},
		{
			MethodName: "PresentationCreate",
			Handler:    _Fs_PresentationCreate_Handler,
		},
		{
			MethodName: "PresentationUpdate",
			Handler:    _Fs_PresentationUpdate_Handler,
		},
		{
			MethodName: "PresentationDelete",
			Handler:    _Fs_PresentationDelete_Handler,
		},
		{
			MethodName: "PresentationList",
			Handler:    _Fs_PresentationList_Handler,
		},
		{
			MethodName: "ConfigGetBool",
			Handler:    _Fs_ConfigGetBool_Handler,
		},
		{
			MethodName: "ConfigUpdateBool",
			Handler:    _Fs_ConfigUpdateBool_Handler,
		},
		{
			MethodName: "ConfigListBool",
			Handler:    _Fs_ConfigListBool_Handler,
		},
		{
			MethodName: "ConfigGetString",
			Handler:    _Fs_ConfigGetString_Handler,
		},
		{
			MethodName: "ConfigUpdateString",
			Handler:    _Fs_ConfigUpdateString_Handler,
		},
		{
			MethodName: "ConfigListString",
			Handler:    _Fs_ConfigListString_Handler,
		},
		{
			MethodName: "ConfigGetUint32",
			Handler:    _Fs_ConfigGetUint32_Handler,
		},
		{
			MethodName: "ConfigUpdateUint32",
			Handler:    _Fs_ConfigUpdateUint32_Handler,
		},
		{
			MethodName: "ConfigListUint32",
			Handler:    _Fs_ConfigListUint32_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "filesystem.proto",
}
