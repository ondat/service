// Code generated by protoc-gen-go. DO NOT EDIT.
// source: filesystem.proto

package v1

import (
	v1 "code.storageos.net/storageos/service/common/v1"
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FsStatusRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsStatusRequest) Reset()         { *m = FsStatusRequest{} }
func (m *FsStatusRequest) String() string { return proto.CompactTextString(m) }
func (*FsStatusRequest) ProtoMessage()    {}
func (*FsStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{0}
}

func (m *FsStatusRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsStatusRequest.Unmarshal(m, b)
}
func (m *FsStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsStatusRequest.Marshal(b, m, deterministic)
}
func (m *FsStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsStatusRequest.Merge(m, src)
}
func (m *FsStatusRequest) XXX_Size() int {
	return xxx_messageInfo_FsStatusRequest.Size(m)
}
func (m *FsStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FsStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FsStatusRequest proto.InternalMessageInfo

type FsStatus struct {
	// The version control info string.
	VersionInfo string `protobuf:"bytes,1,opt,name=version_info,json=versionInfo,proto3" json:"version_info,omitempty"`
	// Generic daemon status.
	Status               *v1.DaemonStatus `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *FsStatus) Reset()         { *m = FsStatus{} }
func (m *FsStatus) String() string { return proto.CompactTextString(m) }
func (*FsStatus) ProtoMessage()    {}
func (*FsStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{1}
}

func (m *FsStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsStatus.Unmarshal(m, b)
}
func (m *FsStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsStatus.Marshal(b, m, deterministic)
}
func (m *FsStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsStatus.Merge(m, src)
}
func (m *FsStatus) XXX_Size() int {
	return xxx_messageInfo_FsStatus.Size(m)
}
func (m *FsStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_FsStatus.DiscardUnknown(m)
}

var xxx_messageInfo_FsStatus proto.InternalMessageInfo

func (m *FsStatus) GetVersionInfo() string {
	if m != nil {
		return m.VersionInfo
	}
	return ""
}

func (m *FsStatus) GetStatus() *v1.DaemonStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type FsPresentationListQuery struct {
	// A possibly-empty list of volume IDs to query.
	PresentationIds []uint32 `protobuf:"varint,1,rep,packed,name=presentation_ids,json=presentationIds,proto3" json:"presentation_ids,omitempty"`
	// A possibly-empty list of volume UUIDs to query.
	PresentationUuids    []string `protobuf:"bytes,2,rep,name=presentation_uuids,json=presentationUuids,proto3" json:"presentation_uuids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsPresentationListQuery) Reset()         { *m = FsPresentationListQuery{} }
func (m *FsPresentationListQuery) String() string { return proto.CompactTextString(m) }
func (*FsPresentationListQuery) ProtoMessage()    {}
func (*FsPresentationListQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{2}
}

func (m *FsPresentationListQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsPresentationListQuery.Unmarshal(m, b)
}
func (m *FsPresentationListQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsPresentationListQuery.Marshal(b, m, deterministic)
}
func (m *FsPresentationListQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsPresentationListQuery.Merge(m, src)
}
func (m *FsPresentationListQuery) XXX_Size() int {
	return xxx_messageInfo_FsPresentationListQuery.Size(m)
}
func (m *FsPresentationListQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_FsPresentationListQuery.DiscardUnknown(m)
}

var xxx_messageInfo_FsPresentationListQuery proto.InternalMessageInfo

func (m *FsPresentationListQuery) GetPresentationIds() []uint32 {
	if m != nil {
		return m.PresentationIds
	}
	return nil
}

func (m *FsPresentationListQuery) GetPresentationUuids() []string {
	if m != nil {
		return m.PresentationUuids
	}
	return nil
}

//*
// Presentation volume message for Fs RPCs.
//
// The minimum amount of information required to specify the 'presentation' or source volume,
// the volume that is presented to the user and (usually) mounted. All actual work
// is done on the target volume, which has actual storage associated with it.
//
// In order to discover information about the type of volume to present, the target
// volume has to be fetched regardless. As a result, there's no need to duplicate fields
// here, we just need enough information to get from the presentation node to the target,
// and to know when the presentation is actually available to the user.
type FsPresentation struct {
	Cc *v1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc,proto3" json:"cc,omitempty"`
	// The inode the user mounts or opens.
	PresentationId uint32 `protobuf:"varint,2,opt,name=presentation_id,json=presentationId,proto3" json:"presentation_id,omitempty"`
	// The underlying inode of the StorageOS volume.
	TargetId uint32 `protobuf:"varint,3,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	// The UUID of the volume to which we point. This must be set for NLI mode,
	// and should be ignored in GSI mode.
	TargetUuid string `protobuf:"bytes,7,opt,name=target_uuid,json=targetUuid,proto3" json:"target_uuid,omitempty"`
	// The filesystem name of the presentation.
	PresentationFilename string `protobuf:"bytes,6,opt,name=presentation_filename,json=presentationFilename,proto3" json:"presentation_filename,omitempty"`
	// The crypto config for the volume. This used to be on DirectorVolume
	// but this is the correct place to set it. When calling PresentationCreate
	// for an encrypted volume, volume_crypto must be set with the appropriate
	// fields: i.e. crypto_state == VCS_FULLY_ENCRYPTED, keyset_present == true
	// and keyset set with the encryption keys. Subsequent calls to PresentationUpdate
	// do not need to re-provide the keys, but should ensure that crypto_state remains
	// set to VCS_FULLY_ENCRYPTED and keyset_present should be set to false.
	VolumeCrypto *v1.VolumeCrypto `protobuf:"bytes,8,opt,name=volume_crypto,json=volumeCrypto,proto3" json:"volume_crypto,omitempty"`
	// The volume size in bytes.
	VolumeSizeBytes      uint64   `protobuf:"varint,9,opt,name=volume_size_bytes,json=volumeSizeBytes,proto3" json:"volume_size_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsPresentation) Reset()         { *m = FsPresentation{} }
func (m *FsPresentation) String() string { return proto.CompactTextString(m) }
func (*FsPresentation) ProtoMessage()    {}
func (*FsPresentation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{3}
}

func (m *FsPresentation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsPresentation.Unmarshal(m, b)
}
func (m *FsPresentation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsPresentation.Marshal(b, m, deterministic)
}
func (m *FsPresentation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsPresentation.Merge(m, src)
}
func (m *FsPresentation) XXX_Size() int {
	return xxx_messageInfo_FsPresentation.Size(m)
}
func (m *FsPresentation) XXX_DiscardUnknown() {
	xxx_messageInfo_FsPresentation.DiscardUnknown(m)
}

var xxx_messageInfo_FsPresentation proto.InternalMessageInfo

func (m *FsPresentation) GetCc() *v1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *FsPresentation) GetPresentationId() uint32 {
	if m != nil {
		return m.PresentationId
	}
	return 0
}

func (m *FsPresentation) GetTargetId() uint32 {
	if m != nil {
		return m.TargetId
	}
	return 0
}

func (m *FsPresentation) GetTargetUuid() string {
	if m != nil {
		return m.TargetUuid
	}
	return ""
}

func (m *FsPresentation) GetPresentationFilename() string {
	if m != nil {
		return m.PresentationFilename
	}
	return ""
}

func (m *FsPresentation) GetVolumeCrypto() *v1.VolumeCrypto {
	if m != nil {
		return m.VolumeCrypto
	}
	return nil
}

func (m *FsPresentation) GetVolumeSizeBytes() uint64 {
	if m != nil {
		return m.VolumeSizeBytes
	}
	return 0
}

type FsPresentationScsiDevice struct {
	// The device information in the message should be considered valid. This is
	// so that unit tests that don't actually attach to LIO can signal clearly
	// that they're working, but don't have read devices.
	DevicePresent bool `protobuf:"varint,1,opt,name=device_present,json=devicePresent,proto3" json:"device_present,omitempty"`
	// The host block device major number.
	Major uint32 `protobuf:"varint,2,opt,name=major,proto3" json:"major,omitempty"`
	// The host block device minor number.
	Minor                uint32   `protobuf:"varint,3,opt,name=minor,proto3" json:"minor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsPresentationScsiDevice) Reset()         { *m = FsPresentationScsiDevice{} }
func (m *FsPresentationScsiDevice) String() string { return proto.CompactTextString(m) }
func (*FsPresentationScsiDevice) ProtoMessage()    {}
func (*FsPresentationScsiDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{4}
}

func (m *FsPresentationScsiDevice) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsPresentationScsiDevice.Unmarshal(m, b)
}
func (m *FsPresentationScsiDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsPresentationScsiDevice.Marshal(b, m, deterministic)
}
func (m *FsPresentationScsiDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsPresentationScsiDevice.Merge(m, src)
}
func (m *FsPresentationScsiDevice) XXX_Size() int {
	return xxx_messageInfo_FsPresentationScsiDevice.Size(m)
}
func (m *FsPresentationScsiDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_FsPresentationScsiDevice.DiscardUnknown(m)
}

var xxx_messageInfo_FsPresentationScsiDevice proto.InternalMessageInfo

func (m *FsPresentationScsiDevice) GetDevicePresent() bool {
	if m != nil {
		return m.DevicePresent
	}
	return false
}

func (m *FsPresentationScsiDevice) GetMajor() uint32 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *FsPresentationScsiDevice) GetMinor() uint32 {
	if m != nil {
		return m.Minor
	}
	return 0
}

type FsPresentationCreateResponse struct {
	// The generic Rpc result.
	Result *v1.RpcResult `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	// Information about the created block device.
	Device               *FsPresentationScsiDevice `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *FsPresentationCreateResponse) Reset()         { *m = FsPresentationCreateResponse{} }
func (m *FsPresentationCreateResponse) String() string { return proto.CompactTextString(m) }
func (*FsPresentationCreateResponse) ProtoMessage()    {}
func (*FsPresentationCreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{5}
}

func (m *FsPresentationCreateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsPresentationCreateResponse.Unmarshal(m, b)
}
func (m *FsPresentationCreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsPresentationCreateResponse.Marshal(b, m, deterministic)
}
func (m *FsPresentationCreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsPresentationCreateResponse.Merge(m, src)
}
func (m *FsPresentationCreateResponse) XXX_Size() int {
	return xxx_messageInfo_FsPresentationCreateResponse.Size(m)
}
func (m *FsPresentationCreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FsPresentationCreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FsPresentationCreateResponse proto.InternalMessageInfo

func (m *FsPresentationCreateResponse) GetResult() *v1.RpcResult {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *FsPresentationCreateResponse) GetDevice() *FsPresentationScsiDevice {
	if m != nil {
		return m.Device
	}
	return nil
}

type FsPresentationList struct {
	Presentations        []*FsPresentation `protobuf:"bytes,1,rep,name=presentations,proto3" json:"presentations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FsPresentationList) Reset()         { *m = FsPresentationList{} }
func (m *FsPresentationList) String() string { return proto.CompactTextString(m) }
func (*FsPresentationList) ProtoMessage()    {}
func (*FsPresentationList) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9f8093c6c7067e, []int{6}
}

func (m *FsPresentationList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FsPresentationList.Unmarshal(m, b)
}
func (m *FsPresentationList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FsPresentationList.Marshal(b, m, deterministic)
}
func (m *FsPresentationList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsPresentationList.Merge(m, src)
}
func (m *FsPresentationList) XXX_Size() int {
	return xxx_messageInfo_FsPresentationList.Size(m)
}
func (m *FsPresentationList) XXX_DiscardUnknown() {
	xxx_messageInfo_FsPresentationList.DiscardUnknown(m)
}

var xxx_messageInfo_FsPresentationList proto.InternalMessageInfo

func (m *FsPresentationList) GetPresentations() []*FsPresentation {
	if m != nil {
		return m.Presentations
	}
	return nil
}

func init() {
	proto.RegisterType((*FsStatusRequest)(nil), "filesystem.v1.FsStatusRequest")
	proto.RegisterType((*FsStatus)(nil), "filesystem.v1.FsStatus")
	proto.RegisterType((*FsPresentationListQuery)(nil), "filesystem.v1.FsPresentationListQuery")
	proto.RegisterType((*FsPresentation)(nil), "filesystem.v1.FsPresentation")
	proto.RegisterType((*FsPresentationScsiDevice)(nil), "filesystem.v1.FsPresentationScsiDevice")
	proto.RegisterType((*FsPresentationCreateResponse)(nil), "filesystem.v1.FsPresentationCreateResponse")
	proto.RegisterType((*FsPresentationList)(nil), "filesystem.v1.FsPresentationList")
}

func init() { proto.RegisterFile("filesystem.proto", fileDescriptor_0a9f8093c6c7067e) }

var fileDescriptor_0a9f8093c6c7067e = []byte{
	// 758 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xed, 0x6e, 0xda, 0x48,
	0x14, 0x05, 0x92, 0xb0, 0x70, 0x09, 0x1f, 0x19, 0x25, 0xc2, 0xeb, 0x24, 0x1b, 0x62, 0x69, 0x37,
	0x6c, 0x76, 0x17, 0x14, 0xb2, 0x3f, 0x57, 0x5a, 0x29, 0x44, 0xac, 0x48, 0x36, 0x52, 0x3b, 0x28,
	0x95, 0xda, 0x1f, 0x45, 0x8e, 0xb9, 0x20, 0x57, 0xd8, 0xe3, 0x7a, 0x06, 0x24, 0xf2, 0x0e, 0x7d,
	0xaf, 0x3e, 0x43, 0x9f, 0xa6, 0xf2, 0xcc, 0x24, 0xb1, 0x6b, 0x20, 0x4d, 0xff, 0x31, 0xe7, 0xdc,
	0x8f, 0x73, 0xee, 0x9d, 0xb1, 0x80, 0xda, 0xd8, 0x9d, 0x22, 0x5f, 0x70, 0x81, 0x5e, 0x2b, 0x08,
	0x99, 0x60, 0xa4, 0x1c, 0x43, 0xe6, 0x67, 0xe6, 0xb6, 0xc3, 0x3c, 0x8f, 0xf9, 0x8a, 0xb4, 0x76,
	0xa0, 0xda, 0xe3, 0x03, 0x61, 0x8b, 0x19, 0xa7, 0xf8, 0x71, 0x86, 0x5c, 0x58, 0xef, 0xa1, 0xf0,
	0x00, 0x91, 0x63, 0xd8, 0x9e, 0x63, 0xc8, 0x5d, 0xe6, 0x0f, 0x5d, 0x7f, 0xcc, 0x8c, 0x6c, 0x23,
	0xdb, 0x2c, 0xd2, 0x92, 0xc6, 0xfa, 0xfe, 0x98, 0x91, 0x36, 0xe4, 0xb9, 0x0c, 0x36, 0x72, 0x8d,
	0x6c, 0xb3, 0xd4, 0xa9, 0xb7, 0x74, 0x83, 0xf9, 0x59, 0xeb, 0xd2, 0x46, 0x8f, 0xf9, 0xba, 0xbc,
	0x0e, 0xb3, 0x38, 0xd4, 0x7b, 0xfc, 0x55, 0x88, 0x1c, 0x7d, 0x61, 0x0b, 0x97, 0xf9, 0xff, 0xbb,
	0x5c, 0xbc, 0x9e, 0x61, 0xb8, 0x20, 0xbf, 0x43, 0x2d, 0x88, 0x11, 0x43, 0x77, 0xc4, 0x8d, 0x6c,
	0x63, 0xa3, 0x59, 0xa6, 0xd5, 0x38, 0xde, 0x1f, 0x71, 0xf2, 0x17, 0x90, 0x44, 0xe8, 0x6c, 0x16,
	0x05, 0xe7, 0x1a, 0x1b, 0xcd, 0x22, 0xdd, 0x89, 0x33, 0xb7, 0x11, 0x61, 0x7d, 0xce, 0x41, 0x25,
	0xd9, 0x95, 0x9c, 0x42, 0xce, 0x71, 0xa4, 0xa3, 0x52, 0xc7, 0x4c, 0x88, 0x16, 0x76, 0x30, 0xb5,
	0x7d, 0xec, 0x4a, 0x88, 0xe6, 0x1c, 0x87, 0x9c, 0x40, 0xf5, 0x1b, 0x61, 0xd2, 0x6d, 0x99, 0x56,
	0x92, 0xba, 0xc8, 0x3e, 0x14, 0x85, 0x1d, 0x4e, 0x50, 0x44, 0x21, 0x1b, 0x32, 0xa4, 0xa0, 0x80,
	0xfe, 0x88, 0x1c, 0x41, 0x49, 0x93, 0x91, 0x5a, 0xe3, 0x27, 0x39, 0x4c, 0x50, 0x50, 0x24, 0x93,
	0x9c, 0xc3, 0x5e, 0xa2, 0x4d, 0xb4, 0x39, 0xdf, 0xf6, 0xd0, 0xc8, 0xcb, 0xd0, 0xdd, 0x38, 0xd9,
	0xd3, 0x1c, 0xf9, 0x07, 0xca, 0x73, 0x36, 0x9d, 0x79, 0x38, 0x74, 0xc2, 0x45, 0x20, 0x98, 0x51,
	0x48, 0xed, 0xe1, 0x8d, 0xe4, 0xbb, 0x92, 0xa6, 0xdb, 0xf3, 0xd8, 0x89, 0x9c, 0xc2, 0x8e, 0xce,
	0xe6, 0xee, 0x3d, 0x0e, 0xef, 0x16, 0x02, 0xb9, 0x51, 0x6c, 0x64, 0x9b, 0x9b, 0xb4, 0xaa, 0x88,
	0x81, 0x7b, 0x8f, 0x17, 0x11, 0x7c, 0xb5, 0x59, 0xd8, 0xaa, 0xe5, 0x2d, 0x0f, 0x8c, 0xe4, 0x24,
	0x07, 0x0e, 0x77, 0x2f, 0x71, 0xee, 0x3a, 0x48, 0x7e, 0x85, 0xca, 0x48, 0xfe, 0x1a, 0x6a, 0xa9,
	0x72, 0xbe, 0x05, 0x5a, 0x56, 0xa8, 0xce, 0x22, 0xbb, 0xb0, 0xe5, 0xd9, 0x1f, 0x58, 0xa8, 0x87,
	0xa8, 0x0e, 0x12, 0x75, 0x7d, 0x16, 0xea, 0xb9, 0xa9, 0x83, 0xf5, 0x29, 0x0b, 0x07, 0xc9, 0x7e,
	0xdd, 0x10, 0x6d, 0x81, 0x14, 0x79, 0xc0, 0x7c, 0x8e, 0xe4, 0x4f, 0xc8, 0x87, 0xc8, 0x67, 0x53,
	0xa1, 0x77, 0xb9, 0x1b, 0x33, 0x4e, 0x03, 0x87, 0x4a, 0x8e, 0xea, 0x18, 0xf2, 0x2f, 0xe4, 0x95,
	0x16, 0x7d, 0x5d, 0x4f, 0x5a, 0x89, 0xe7, 0xd1, 0x5a, 0x65, 0x8d, 0xea, 0x34, 0xeb, 0x2d, 0x90,
	0xf4, 0xf5, 0x25, 0x5d, 0x28, 0xc7, 0x97, 0xa3, 0xae, 0x6d, 0xa9, 0x73, 0xb8, 0xb6, 0x3a, 0x4d,
	0xe6, 0x74, 0xbe, 0x14, 0x20, 0xd7, 0xe3, 0xa4, 0x0b, 0x79, 0xfd, 0xfc, 0x7e, 0x49, 0xa5, 0x27,
	0x9e, 0xaa, 0x59, 0x5f, 0xc1, 0x5b, 0x19, 0x72, 0x07, 0x24, 0x3d, 0x33, 0xb2, 0x5e, 0x8f, 0xf9,
	0xc7, 0x5a, 0x3a, 0x39, 0x77, 0x2b, 0x43, 0xae, 0x93, 0x3d, 0x6e, 0x83, 0xd1, 0x77, 0xf4, 0x58,
	0xba, 0x9e, 0x74, 0xb1, 0x4b, 0x9c, 0xe2, 0x8f, 0x17, 0x1b, 0x42, 0x2d, 0xb5, 0xa2, 0xdf, 0xd6,
	0x96, 0x7a, 0xfc, 0x08, 0x99, 0xc7, 0xcf, 0xc6, 0x59, 0x19, 0xd2, 0x83, 0x72, 0x97, 0xf9, 0x63,
	0x77, 0xf2, 0x1f, 0x8a, 0x0b, 0xc6, 0xa6, 0x24, 0xae, 0x44, 0x31, 0xd7, 0xb8, 0x30, 0x0f, 0x53,
	0xa8, 0x8e, 0xa7, 0x18, 0x4c, 0x17, 0x56, 0x86, 0xf4, 0xa1, 0xa6, 0x70, 0x35, 0x3c, 0x59, 0x6a,
	0x2f, 0x95, 0x14, 0xc1, 0xe6, 0x41, 0x0a, 0x56, 0x39, 0x4f, 0xa5, 0x2a, 0x0a, 0x8e, 0x24, 0xca,
	0x42, 0x66, 0x2a, 0xe3, 0xc9, 0xe5, 0xcf, 0x4b, 0x9b, 0x68, 0x77, 0x57, 0x50, 0x7d, 0x54, 0x3b,
	0x10, 0xa1, 0xeb, 0x4f, 0x56, 0xf8, 0x3b, 0x5a, 0xe6, 0x4f, 0x65, 0x3c, 0xc8, 0xba, 0x01, 0x12,
	0x57, 0xab, 0xcb, 0xd5, 0x53, 0x89, 0x8a, 0x78, 0xd6, 0xe5, 0xcd, 0xc3, 0xc0, 0x22, 0xa9, 0xba,
	0xd8, 0x3a, 0x9f, 0xfb, 0x2b, 0x1a, 0x2d, 0x71, 0x7a, 0xeb, 0xfa, 0xe2, 0xbc, 0xf3, 0x12, 0xa7,
	0x2a, 0x63, 0x85, 0x53, 0x5d, 0x2e, 0xed, 0x54, 0x11, 0x2f, 0x73, 0xaa, 0x8b, 0xbd, 0xcc, 0xa9,
	0x4a, 0x52, 0x4e, 0x2f, 0xfe, 0x7e, 0xd7, 0x71, 0xd8, 0x08, 0x5b, 0x5c, 0xb0, 0xd0, 0x9e, 0x20,
	0xe3, 0x2d, 0x1f, 0x45, 0xfb, 0xf1, 0xd4, 0xe6, 0x18, 0x46, 0xdf, 0xb7, 0xf6, 0xd3, 0xe5, 0x6f,
	0xcf, 0xcf, 0xee, 0xf2, 0xf2, 0x6f, 0xc2, 0xf9, 0xd7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x8e,
	0x78, 0xff, 0x57, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FsClient is the client API for Fs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FsClient interface {
	//*
	// Get program status.
	Status(ctx context.Context, in *FsStatusRequest, opts ...grpc.CallOption) (*FsStatus, error)
	//*
	// Add configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationCreate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*FsPresentationCreateResponse, error)
	//*
	// Update configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationUpdate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error)
	//*
	// Remove configuration for the Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationDelete(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error)
	//*
	// List configured Presentation volumes, optionally filtered using a FsPresentationListQuery
	// message.
	//
	// returns A FsPresentationList message containing FsPresentation mesages,
	//         if any are found matching the filter.
	PresentationList(ctx context.Context, in *FsPresentationListQuery, opts ...grpc.CallOption) (*FsPresentationList, error)
	// Config services, from common.v1.
	ConfigGetBool(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetBoolReply, error)
	ConfigUpdateBool(ctx context.Context, in *v1.ConfigBool, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListBool(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigBoolList, error)
	ConfigGetString(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetStringReply, error)
	ConfigUpdateString(ctx context.Context, in *v1.ConfigString, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListString(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigStringList, error)
	ConfigGetUint32(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint32Reply, error)
	ConfigUpdateUint32(ctx context.Context, in *v1.ConfigUint32, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error)
	ConfigListUint32(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint32List, error)
}

type fsClient struct {
	cc *grpc.ClientConn
}

func NewFsClient(cc *grpc.ClientConn) FsClient {
	return &fsClient{cc}
}

func (c *fsClient) Status(ctx context.Context, in *FsStatusRequest, opts ...grpc.CallOption) (*FsStatus, error) {
	out := new(FsStatus)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationCreate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*FsPresentationCreateResponse, error) {
	out := new(FsPresentationCreateResponse)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/PresentationCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationUpdate(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error) {
	out := new(v1.RpcResult)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/PresentationUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationDelete(ctx context.Context, in *FsPresentation, opts ...grpc.CallOption) (*v1.RpcResult, error) {
	out := new(v1.RpcResult)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/PresentationDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) PresentationList(ctx context.Context, in *FsPresentationListQuery, opts ...grpc.CallOption) (*FsPresentationList, error) {
	out := new(FsPresentationList)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/PresentationList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigGetBool(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetBoolReply, error) {
	out := new(v1.ConfigGetBoolReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigGetBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigUpdateBool(ctx context.Context, in *v1.ConfigBool, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigUpdateBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigListBool(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigBoolList, error) {
	out := new(v1.ConfigBoolList)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigListBool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigGetString(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetStringReply, error) {
	out := new(v1.ConfigGetStringReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigGetString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigUpdateString(ctx context.Context, in *v1.ConfigString, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigUpdateString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigListString(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigStringList, error) {
	out := new(v1.ConfigStringList)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigListString", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigGetUint32(ctx context.Context, in *v1.ConfigKey, opts ...grpc.CallOption) (*v1.ConfigGetUint32Reply, error) {
	out := new(v1.ConfigGetUint32Reply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigGetUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigUpdateUint32(ctx context.Context, in *v1.ConfigUint32, opts ...grpc.CallOption) (*v1.ConfigUpdateReply, error) {
	out := new(v1.ConfigUpdateReply)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigUpdateUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fsClient) ConfigListUint32(ctx context.Context, in *v1.ConfigListQuery, opts ...grpc.CallOption) (*v1.ConfigUint32List, error) {
	out := new(v1.ConfigUint32List)
	err := c.cc.Invoke(ctx, "/filesystem.v1.Fs/ConfigListUint32", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FsServer is the server API for Fs service.
type FsServer interface {
	//*
	// Get program status.
	Status(context.Context, *FsStatusRequest) (*FsStatus, error)
	//*
	// Add configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationCreate(context.Context, *FsPresentation) (*FsPresentationCreateResponse, error)
	//*
	// Update configuration for a Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationUpdate(context.Context, *FsPresentation) (*v1.RpcResult, error)
	//*
	// Remove configuration for the Presentation volume specified in the FsPresentation message.
	//
	// returns RpcResult
	PresentationDelete(context.Context, *FsPresentation) (*v1.RpcResult, error)
	//*
	// List configured Presentation volumes, optionally filtered using a FsPresentationListQuery
	// message.
	//
	// returns A FsPresentationList message containing FsPresentation mesages,
	//         if any are found matching the filter.
	PresentationList(context.Context, *FsPresentationListQuery) (*FsPresentationList, error)
	// Config services, from common.v1.
	ConfigGetBool(context.Context, *v1.ConfigKey) (*v1.ConfigGetBoolReply, error)
	ConfigUpdateBool(context.Context, *v1.ConfigBool) (*v1.ConfigUpdateReply, error)
	ConfigListBool(context.Context, *v1.ConfigListQuery) (*v1.ConfigBoolList, error)
	ConfigGetString(context.Context, *v1.ConfigKey) (*v1.ConfigGetStringReply, error)
	ConfigUpdateString(context.Context, *v1.ConfigString) (*v1.ConfigUpdateReply, error)
	ConfigListString(context.Context, *v1.ConfigListQuery) (*v1.ConfigStringList, error)
	ConfigGetUint32(context.Context, *v1.ConfigKey) (*v1.ConfigGetUint32Reply, error)
	ConfigUpdateUint32(context.Context, *v1.ConfigUint32) (*v1.ConfigUpdateReply, error)
	ConfigListUint32(context.Context, *v1.ConfigListQuery) (*v1.ConfigUint32List, error)
}

// UnimplementedFsServer can be embedded to have forward compatible implementations.
type UnimplementedFsServer struct {
}

func (*UnimplementedFsServer) Status(ctx context.Context, req *FsStatusRequest) (*FsStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (*UnimplementedFsServer) PresentationCreate(ctx context.Context, req *FsPresentation) (*FsPresentationCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresentationCreate not implemented")
}
func (*UnimplementedFsServer) PresentationUpdate(ctx context.Context, req *FsPresentation) (*v1.RpcResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresentationUpdate not implemented")
}
func (*UnimplementedFsServer) PresentationDelete(ctx context.Context, req *FsPresentation) (*v1.RpcResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresentationDelete not implemented")
}
func (*UnimplementedFsServer) PresentationList(ctx context.Context, req *FsPresentationListQuery) (*FsPresentationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresentationList not implemented")
}
func (*UnimplementedFsServer) ConfigGetBool(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetBoolReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetBool not implemented")
}
func (*UnimplementedFsServer) ConfigUpdateBool(ctx context.Context, req *v1.ConfigBool) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateBool not implemented")
}
func (*UnimplementedFsServer) ConfigListBool(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigBoolList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListBool not implemented")
}
func (*UnimplementedFsServer) ConfigGetString(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetStringReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetString not implemented")
}
func (*UnimplementedFsServer) ConfigUpdateString(ctx context.Context, req *v1.ConfigString) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateString not implemented")
}
func (*UnimplementedFsServer) ConfigListString(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigStringList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListString not implemented")
}
func (*UnimplementedFsServer) ConfigGetUint32(ctx context.Context, req *v1.ConfigKey) (*v1.ConfigGetUint32Reply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGetUint32 not implemented")
}
func (*UnimplementedFsServer) ConfigUpdateUint32(ctx context.Context, req *v1.ConfigUint32) (*v1.ConfigUpdateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigUpdateUint32 not implemented")
}
func (*UnimplementedFsServer) ConfigListUint32(ctx context.Context, req *v1.ConfigListQuery) (*v1.ConfigUint32List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigListUint32 not implemented")
}

func RegisterFsServer(s *grpc.Server, srv FsServer) {
	s.RegisterService(&_Fs_serviceDesc, srv)
}

func _Fs_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).Status(ctx, req.(*FsStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/PresentationCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationCreate(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/PresentationUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationUpdate(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/PresentationDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationDelete(ctx, req.(*FsPresentation))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_PresentationList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FsPresentationListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).PresentationList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/PresentationList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).PresentationList(ctx, req.(*FsPresentationListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigGetBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigGetBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigGetBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigGetBool(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigUpdateBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigBool)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigUpdateBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigUpdateBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigUpdateBool(ctx, req.(*v1.ConfigBool))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigListBool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigListBool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigListBool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigListBool(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigGetString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigGetString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigGetString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigGetString(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigUpdateString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigString)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigUpdateString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigUpdateString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigUpdateString(ctx, req.(*v1.ConfigString))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigListString_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigListString(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigListString",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigListString(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigGetUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigGetUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigGetUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigGetUint32(ctx, req.(*v1.ConfigKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigUpdateUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigUint32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigUpdateUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigUpdateUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigUpdateUint32(ctx, req.(*v1.ConfigUint32))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fs_ConfigListUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ConfigListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FsServer).ConfigListUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/filesystem.v1.Fs/ConfigListUint32",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FsServer).ConfigListUint32(ctx, req.(*v1.ConfigListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

var _Fs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "filesystem.v1.Fs",
	HandlerType: (*FsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _Fs_Status_Handler,
		},
		{
			MethodName: "PresentationCreate",
			Handler:    _Fs_PresentationCreate_Handler,
		},
		{
			MethodName: "PresentationUpdate",
			Handler:    _Fs_PresentationUpdate_Handler,
		},
		{
			MethodName: "PresentationDelete",
			Handler:    _Fs_PresentationDelete_Handler,
		},
		{
			MethodName: "PresentationList",
			Handler:    _Fs_PresentationList_Handler,
		},
		{
			MethodName: "ConfigGetBool",
			Handler:    _Fs_ConfigGetBool_Handler,
		},
		{
			MethodName: "ConfigUpdateBool",
			Handler:    _Fs_ConfigUpdateBool_Handler,
		},
		{
			MethodName: "ConfigListBool",
			Handler:    _Fs_ConfigListBool_Handler,
		},
		{
			MethodName: "ConfigGetString",
			Handler:    _Fs_ConfigGetString_Handler,
		},
		{
			MethodName: "ConfigUpdateString",
			Handler:    _Fs_ConfigUpdateString_Handler,
		},
		{
			MethodName: "ConfigListString",
			Handler:    _Fs_ConfigListString_Handler,
		},
		{
			MethodName: "ConfigGetUint32",
			Handler:    _Fs_ConfigGetUint32_Handler,
		},
		{
			MethodName: "ConfigUpdateUint32",
			Handler:    _Fs_ConfigUpdateUint32_Handler,
		},
		{
			MethodName: "ConfigListUint32",
			Handler:    _Fs_ConfigListUint32_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "filesystem.proto",
}
