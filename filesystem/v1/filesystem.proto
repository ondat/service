syntax = "proto3";
package filesystem.v1;
option go_package = "code.storageos.net/storageos/service/filesystem/v1";

import "common.proto";

/**
 * Filesystem configuration and status service.
 */
service Fs {
    /**
     * Get program status.
     */
    rpc Status(FsStatusRequest) returns (FsStatus) {}

    /**
     * Add configuration for a Presentation volume specified in the FsPresentation message.
     *
     * returns RpcResult
     */
    rpc PresentationCreate(FsPresentation) returns (FsPresentationCreateResponse) {}

    /**
     * Update configuration for a Presentation volume specified in the FsPresentation message.
     *
     * returns RpcResult
     */
    rpc PresentationUpdate(FsPresentation) returns (common.v1.RpcResult) {}

    /**
     * Remove configuration for the Presentation volume specified in the FsPresentation message.
     *
     * returns RpcResult
     */
    rpc PresentationDelete(FsPresentation) returns (common.v1.RpcResult) {}

    /**
     * List configured Presentation volumes, optionally filtered using a FsPresentationListQuery
     * message.
     *
     * returns A FsPresentationList message containing FsPresentation mesages,
     *         if any are found matching the filter.
     */
    rpc PresentationList(FsPresentationListQuery) returns (FsPresentationList) {}

    // Config services, from common.v1.
    rpc ConfigGetBool(common.v1.ConfigKey) returns (common.v1.ConfigGetBoolReply) {}
    rpc ConfigUpdateBool(common.v1.ConfigBool) returns (common.v1.ConfigUpdateReply) {}
    rpc ConfigListBool(common.v1.ConfigListQuery) returns (common.v1.ConfigBoolList) {}

    rpc ConfigGetString(common.v1.ConfigKey) returns (common.v1.ConfigGetStringReply) {}
    rpc ConfigUpdateString(common.v1.ConfigString) returns (common.v1.ConfigUpdateReply) {}
    rpc ConfigListString(common.v1.ConfigListQuery) returns (common.v1.ConfigStringList) {}

    rpc ConfigGetUint32(common.v1.ConfigKey) returns (common.v1.ConfigGetUint32Reply) {}
    rpc ConfigUpdateUint32(common.v1.ConfigUint32) returns (common.v1.ConfigUpdateReply) {}
    rpc ConfigListUint32(common.v1.ConfigListQuery) returns (common.v1.ConfigUint32List) {}
}

message FsStatusRequest {
    // Empty for now.
}

message FsStatus {
    // The version control info string.
    string version_info = 1;

    // Generic daemon status.
    common.v1.DaemonStatus status = 2;
}

message FsPresentationListQuery {
    // A possibly-empty list of volume IDs to query.
    repeated uint32 presentation_ids = 1;
    // A possibly-empty list of volume UUIDs to query.
    repeated string presentation_uuids = 2;
}

/**
 * Presentation volume message for Fs RPCs.
 *
 * The minimum amount of information required to specify the 'presentation' or source volume,
 * the volume that is presented to the user and (usually) mounted. All actual work
 * is done on the target volume, which has actual storage associated with it.
 *
 * In order to discover information about the type of volume to present, the target
 * volume has to be fetched regardless. As a result, there's no need to duplicate fields
 * here, we just need enough information to get from the presentation node to the target,
 * and to know when the presentation is actually available to the user.
 */
message FsPresentation {
    common.v1.DataplaneCommon cc = 1;

    // The inode the user mounts or opens.
    uint32 presentation_id = 2;

    // The underlying inode of the StorageOS volume.
    uint32 target_id = 3;

    // The UUID of the volume to which we point. This must be set for NLI mode,
    // and should be ignored in GSI mode.
    string target_uuid = 7;

    // Presentation inode status, e.g. readiness.
    // FsVolumeStatus status = 5;
    reserved 5;

    // The filesystem name of the presentation.
    string presentation_filename = 6;

    // The crypto config for the volume. This used to be on DirectorVolume
    // but this is the correct place to set it. When calling PresentationCreate
    // for an encrypted volume, volume_crypto must be set with the appropriate
    // fields: i.e. crypto_state == VCS_FULLY_ENCRYPTED, keyset_present == true
    // and keyset set with the encryption keys. Subsequent calls to PresentationUpdate
    // do not need to re-provide the keys, but should ensure that crypto_state remains
    // set to VCS_FULLY_ENCRYPTED and keyset_present should be set to false.
    common.v1.VolumeCrypto volume_crypto = 8;

    // The volume size in bytes.
    uint64 volume_size_bytes = 9;
}

message FsPresentationScsiDevice {
    // The device information in the message should be considered valid. This is
    // so that unit tests that don't actually attach to LIO can signal clearly
    // that they're working, but don't have read devices.
    bool device_present = 1;
    // The host block device major number.
    uint32 major = 2;
    // The host block device minor number.
    uint32 minor = 3;
    // This object could easily contain a bunch of other details about the
    // created scsi device, e.g. the /sys filesystem LUN path, the HBA path,
    // etc. Just ask.
}

message FsPresentationCreateResponse {
    // The generic Rpc result.
    common.v1.RpcResult result = 1;

    // Information about the created block device.
    FsPresentationScsiDevice device = 2;
}

message FsPresentationList {
    repeated FsPresentation presentations = 1;
}
