// Code generated by protoc-gen-go. DO NOT EDIT.
// source: directfs.proto

/*
Package directfs_v1 is a generated protocol buffer package.

It is generated from these files:
	directfs.proto

It has these top-level messages:
	DfsInitiatorStatusRequest
	DfsInitiatorStatus
	DfsResponderStatusRequest
	DfsResponderStatus
	DfsInitiatorNodeCredentials
	DfsInitiatorNode
	DfsInitiatorNodeList
	DfsInitiatorNodeListQuery
	DfsInitiatorVolumeCredentials
	DfsInitiatorVolumeStatistics
	DfsInitiatorVolumeStatus
	DfsInitiatorVolume
	DfsInitiatorVolumeList
	DfsInitiatorVolumeListQuery
	DfsResponderVolumeCredentials
	DfsResponderVolumeStatistics
	DfsResponderVolumeStatus
	DfsResponderVolume
	DfsResponderVolumeList
	DfsResponderVolumeListQuery
*/
package directfs_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common_v1 "code.storageos.net/scm/storageos/service/common/v1"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DfsInitiatorVolumeStatus_DfsInitiatorConnectionState int32

const (
	DfsInitiatorVolumeStatus_NONE          DfsInitiatorVolumeStatus_DfsInitiatorConnectionState = 0
	DfsInitiatorVolumeStatus_CONNECTING    DfsInitiatorVolumeStatus_DfsInitiatorConnectionState = 1
	DfsInitiatorVolumeStatus_CONNECTED     DfsInitiatorVolumeStatus_DfsInitiatorConnectionState = 2
	DfsInitiatorVolumeStatus_DISCONNECTING DfsInitiatorVolumeStatus_DfsInitiatorConnectionState = 3
	DfsInitiatorVolumeStatus_DISCONNECTED  DfsInitiatorVolumeStatus_DfsInitiatorConnectionState = 4
)

var DfsInitiatorVolumeStatus_DfsInitiatorConnectionState_name = map[int32]string{
	0: "NONE",
	1: "CONNECTING",
	2: "CONNECTED",
	3: "DISCONNECTING",
	4: "DISCONNECTED",
}
var DfsInitiatorVolumeStatus_DfsInitiatorConnectionState_value = map[string]int32{
	"NONE":          0,
	"CONNECTING":    1,
	"CONNECTED":     2,
	"DISCONNECTING": 3,
	"DISCONNECTED":  4,
}

func (x DfsInitiatorVolumeStatus_DfsInitiatorConnectionState) String() string {
	return proto.EnumName(DfsInitiatorVolumeStatus_DfsInitiatorConnectionState_name, int32(x))
}
func (DfsInitiatorVolumeStatus_DfsInitiatorConnectionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0}
}

type DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily int32

const (
	DfsInitiatorVolumeStatus_IPV4 DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily = 0
	DfsInitiatorVolumeStatus_IPV6 DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily = 1
)

var DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}
var DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily) String() string {
	return proto.EnumName(DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily_name, int32(x))
}
func (DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 1}
}

type DfsResponderVolumeStatus_DfsResponderConnectionState int32

const (
	DfsResponderVolumeStatus_NONE          DfsResponderVolumeStatus_DfsResponderConnectionState = 0
	DfsResponderVolumeStatus_CONNECTING    DfsResponderVolumeStatus_DfsResponderConnectionState = 1
	DfsResponderVolumeStatus_CONNECTED     DfsResponderVolumeStatus_DfsResponderConnectionState = 2
	DfsResponderVolumeStatus_DISCONNECTING DfsResponderVolumeStatus_DfsResponderConnectionState = 3
	DfsResponderVolumeStatus_DISCONNECTED  DfsResponderVolumeStatus_DfsResponderConnectionState = 4
)

var DfsResponderVolumeStatus_DfsResponderConnectionState_name = map[int32]string{
	0: "NONE",
	1: "CONNECTING",
	2: "CONNECTED",
	3: "DISCONNECTING",
	4: "DISCONNECTED",
}
var DfsResponderVolumeStatus_DfsResponderConnectionState_value = map[string]int32{
	"NONE":          0,
	"CONNECTING":    1,
	"CONNECTED":     2,
	"DISCONNECTING": 3,
	"DISCONNECTED":  4,
}

func (x DfsResponderVolumeStatus_DfsResponderConnectionState) String() string {
	return proto.EnumName(DfsResponderVolumeStatus_DfsResponderConnectionState_name, int32(x))
}
func (DfsResponderVolumeStatus_DfsResponderConnectionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 0}
}

type DfsResponderVolumeStatus_DfsResponderAddressFamily int32

const (
	DfsResponderVolumeStatus_IPV4 DfsResponderVolumeStatus_DfsResponderAddressFamily = 0
	DfsResponderVolumeStatus_IPV6 DfsResponderVolumeStatus_DfsResponderAddressFamily = 1
)

var DfsResponderVolumeStatus_DfsResponderAddressFamily_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}
var DfsResponderVolumeStatus_DfsResponderAddressFamily_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x DfsResponderVolumeStatus_DfsResponderAddressFamily) String() string {
	return proto.EnumName(DfsResponderVolumeStatus_DfsResponderAddressFamily_name, int32(x))
}
func (DfsResponderVolumeStatus_DfsResponderAddressFamily) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 1}
}

type DfsInitiatorStatusRequest struct {
}

func (m *DfsInitiatorStatusRequest) Reset()                    { *m = DfsInitiatorStatusRequest{} }
func (m *DfsInitiatorStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorStatusRequest) ProtoMessage()               {}
func (*DfsInitiatorStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type DfsInitiatorStatus struct {
	// The version control info string.
	VersionInfo string `protobuf:"bytes,1,opt,name=version_info,json=versionInfo" json:"version_info,omitempty"`
}

func (m *DfsInitiatorStatus) Reset()                    { *m = DfsInitiatorStatus{} }
func (m *DfsInitiatorStatus) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorStatus) ProtoMessage()               {}
func (*DfsInitiatorStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DfsInitiatorStatus) GetVersionInfo() string {
	if m != nil {
		return m.VersionInfo
	}
	return ""
}

type DfsResponderStatusRequest struct {
}

func (m *DfsResponderStatusRequest) Reset()                    { *m = DfsResponderStatusRequest{} }
func (m *DfsResponderStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*DfsResponderStatusRequest) ProtoMessage()               {}
func (*DfsResponderStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type DfsResponderStatus struct {
	// The version control info string.
	VersionInfo string `protobuf:"bytes,1,opt,name=version_info,json=versionInfo" json:"version_info,omitempty"`
}

func (m *DfsResponderStatus) Reset()                    { *m = DfsResponderStatus{} }
func (m *DfsResponderStatus) String() string            { return proto.CompactTextString(m) }
func (*DfsResponderStatus) ProtoMessage()               {}
func (*DfsResponderStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DfsResponderStatus) GetVersionInfo() string {
	if m != nil {
		return m.VersionInfo
	}
	return ""
}

type DfsInitiatorNodeCredentials struct {
}

func (m *DfsInitiatorNodeCredentials) Reset()                    { *m = DfsInitiatorNodeCredentials{} }
func (m *DfsInitiatorNodeCredentials) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorNodeCredentials) ProtoMessage()               {}
func (*DfsInitiatorNodeCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// *
// A host used by DirectFS.
type DfsInitiatorNode struct {
	Cc *common_v1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The unique host identifier.
	NodeId uint32 `protobuf:"varint,2,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// The remote hostname.
	Hostname string `protobuf:"bytes,3,opt,name=hostname" json:"hostname,omitempty"`
	// The remote address.
	Address string `protobuf:"bytes,4,opt,name=address" json:"address,omitempty"`
	// The remote port.
	Port uint32 `protobuf:"varint,5,opt,name=port" json:"port,omitempty"`
	// Host credentials.
	Credentials *DfsInitiatorNodeCredentials `protobuf:"bytes,6,opt,name=credentials" json:"credentials,omitempty"`
}

func (m *DfsInitiatorNode) Reset()                    { *m = DfsInitiatorNode{} }
func (m *DfsInitiatorNode) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorNode) ProtoMessage()               {}
func (*DfsInitiatorNode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DfsInitiatorNode) GetCc() *common_v1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *DfsInitiatorNode) GetNodeId() uint32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *DfsInitiatorNode) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *DfsInitiatorNode) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *DfsInitiatorNode) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *DfsInitiatorNode) GetCredentials() *DfsInitiatorNodeCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type DfsInitiatorNodeList struct {
	Nodes []*DfsInitiatorNode `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *DfsInitiatorNodeList) Reset()                    { *m = DfsInitiatorNodeList{} }
func (m *DfsInitiatorNodeList) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorNodeList) ProtoMessage()               {}
func (*DfsInitiatorNodeList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DfsInitiatorNodeList) GetNodes() []*DfsInitiatorNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type DfsInitiatorNodeListQuery struct {
	// An optional list of hosts to query.
	NodeIds []uint32 `protobuf:"varint,1,rep,packed,name=node_ids,json=nodeIds" json:"node_ids,omitempty"`
}

func (m *DfsInitiatorNodeListQuery) Reset()                    { *m = DfsInitiatorNodeListQuery{} }
func (m *DfsInitiatorNodeListQuery) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorNodeListQuery) ProtoMessage()               {}
func (*DfsInitiatorNodeListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DfsInitiatorNodeListQuery) GetNodeIds() []uint32 {
	if m != nil {
		return m.NodeIds
	}
	return nil
}

type DfsInitiatorVolumeCredentials struct {
}

func (m *DfsInitiatorVolumeCredentials) Reset()                    { *m = DfsInitiatorVolumeCredentials{} }
func (m *DfsInitiatorVolumeCredentials) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorVolumeCredentials) ProtoMessage()               {}
func (*DfsInitiatorVolumeCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type DfsInitiatorVolumeStatistics struct {
}

func (m *DfsInitiatorVolumeStatistics) Reset()                    { *m = DfsInitiatorVolumeStatistics{} }
func (m *DfsInitiatorVolumeStatistics) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorVolumeStatistics) ProtoMessage()               {}
func (*DfsInitiatorVolumeStatistics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type DfsInitiatorVolumeStatus struct {
	ConnState DfsInitiatorVolumeStatus_DfsInitiatorConnectionState `protobuf:"varint,1,opt,name=conn_state,json=connState,enum=directfs.v1.DfsInitiatorVolumeStatus_DfsInitiatorConnectionState" json:"conn_state,omitempty"`
	// The remote peer, in string form for simplicity.
	PeerName string `protobuf:"bytes,2,opt,name=peer_name,json=peerName" json:"peer_name,omitempty"`
	// The address family we're using to connect to the peer.
	PeerAf DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily `protobuf:"varint,3,opt,name=peer_af,json=peerAf,enum=directfs.v1.DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily" json:"peer_af,omitempty"`
}

func (m *DfsInitiatorVolumeStatus) Reset()                    { *m = DfsInitiatorVolumeStatus{} }
func (m *DfsInitiatorVolumeStatus) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorVolumeStatus) ProtoMessage()               {}
func (*DfsInitiatorVolumeStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DfsInitiatorVolumeStatus) GetConnState() DfsInitiatorVolumeStatus_DfsInitiatorConnectionState {
	if m != nil {
		return m.ConnState
	}
	return DfsInitiatorVolumeStatus_NONE
}

func (m *DfsInitiatorVolumeStatus) GetPeerName() string {
	if m != nil {
		return m.PeerName
	}
	return ""
}

func (m *DfsInitiatorVolumeStatus) GetPeerAf() DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily {
	if m != nil {
		return m.PeerAf
	}
	return DfsInitiatorVolumeStatus_IPV4
}

// *
// A volume used by DirectFS.
//
// The remote host (for the client) isn't directly included here. However, the
// client clearly can't connect without a properly configured node_id item.
//
// The split between host and volume objects was decided based on now-irrelevant
// implementation details of ConfigFS v1. However, there's still some logic to
// it if the authentication (especially TLS) is per-host rather than per-volume.
type DfsInitiatorVolume struct {
	Cc *common_v1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The volume ID.
	VolumeId uint32 `protobuf:"varint,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The host for this volume.
	NodeId uint32 `protobuf:"varint,3,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// Volume credentials.
	Credentials *DfsInitiatorVolumeCredentials `protobuf:"bytes,4,opt,name=credentials" json:"credentials,omitempty"`
	// Volume statistics.
	Stats *DfsInitiatorVolumeStatistics `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
	// Server status for the volume.
	Status *DfsInitiatorVolumeStatus `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
}

func (m *DfsInitiatorVolume) Reset()                    { *m = DfsInitiatorVolume{} }
func (m *DfsInitiatorVolume) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorVolume) ProtoMessage()               {}
func (*DfsInitiatorVolume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DfsInitiatorVolume) GetCc() *common_v1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *DfsInitiatorVolume) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *DfsInitiatorVolume) GetNodeId() uint32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *DfsInitiatorVolume) GetCredentials() *DfsInitiatorVolumeCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *DfsInitiatorVolume) GetStats() *DfsInitiatorVolumeStatistics {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *DfsInitiatorVolume) GetStatus() *DfsInitiatorVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type DfsInitiatorVolumeList struct {
	Volumes []*DfsInitiatorVolume `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
}

func (m *DfsInitiatorVolumeList) Reset()                    { *m = DfsInitiatorVolumeList{} }
func (m *DfsInitiatorVolumeList) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorVolumeList) ProtoMessage()               {}
func (*DfsInitiatorVolumeList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DfsInitiatorVolumeList) GetVolumes() []*DfsInitiatorVolume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type DfsInitiatorVolumeListQuery struct {
	// An optional list of volumes to query.
	VolumeIds []uint32 `protobuf:"varint,1,rep,packed,name=volume_ids,json=volumeIds" json:"volume_ids,omitempty"`
}

func (m *DfsInitiatorVolumeListQuery) Reset()                    { *m = DfsInitiatorVolumeListQuery{} }
func (m *DfsInitiatorVolumeListQuery) String() string            { return proto.CompactTextString(m) }
func (*DfsInitiatorVolumeListQuery) ProtoMessage()               {}
func (*DfsInitiatorVolumeListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *DfsInitiatorVolumeListQuery) GetVolumeIds() []uint32 {
	if m != nil {
		return m.VolumeIds
	}
	return nil
}

type DfsResponderVolumeCredentials struct {
}

func (m *DfsResponderVolumeCredentials) Reset()                    { *m = DfsResponderVolumeCredentials{} }
func (m *DfsResponderVolumeCredentials) String() string            { return proto.CompactTextString(m) }
func (*DfsResponderVolumeCredentials) ProtoMessage()               {}
func (*DfsResponderVolumeCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type DfsResponderVolumeStatistics struct {
}

func (m *DfsResponderVolumeStatistics) Reset()                    { *m = DfsResponderVolumeStatistics{} }
func (m *DfsResponderVolumeStatistics) String() string            { return proto.CompactTextString(m) }
func (*DfsResponderVolumeStatistics) ProtoMessage()               {}
func (*DfsResponderVolumeStatistics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type DfsResponderVolumeStatus struct {
	ConnState DfsResponderVolumeStatus_DfsResponderConnectionState `protobuf:"varint,1,opt,name=conn_state,json=connState,enum=directfs.v1.DfsResponderVolumeStatus_DfsResponderConnectionState" json:"conn_state,omitempty"`
	// The remote peer, in string form for simplicity.
	PeerName string `protobuf:"bytes,2,opt,name=peer_name,json=peerName" json:"peer_name,omitempty"`
	// The address family we're using to connect to the peer.
	PeerAf DfsResponderVolumeStatus_DfsResponderAddressFamily `protobuf:"varint,3,opt,name=peer_af,json=peerAf,enum=directfs.v1.DfsResponderVolumeStatus_DfsResponderAddressFamily" json:"peer_af,omitempty"`
}

func (m *DfsResponderVolumeStatus) Reset()                    { *m = DfsResponderVolumeStatus{} }
func (m *DfsResponderVolumeStatus) String() string            { return proto.CompactTextString(m) }
func (*DfsResponderVolumeStatus) ProtoMessage()               {}
func (*DfsResponderVolumeStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *DfsResponderVolumeStatus) GetConnState() DfsResponderVolumeStatus_DfsResponderConnectionState {
	if m != nil {
		return m.ConnState
	}
	return DfsResponderVolumeStatus_NONE
}

func (m *DfsResponderVolumeStatus) GetPeerName() string {
	if m != nil {
		return m.PeerName
	}
	return ""
}

func (m *DfsResponderVolumeStatus) GetPeerAf() DfsResponderVolumeStatus_DfsResponderAddressFamily {
	if m != nil {
		return m.PeerAf
	}
	return DfsResponderVolumeStatus_IPV4
}

// *
// A volume used by DirectFS.
//
// The remote host (for the client) isn't directly included here. However, the
// client clearly can't connect without a properly configured node_id item.
//
// The split between host and volume objects was decided based on now-irrelevant
// implementation details of ConfigFS v1. However, there's still some logic to
// it if the authentication (especially TLS) is per-host rather than per-volume.
type DfsResponderVolume struct {
	Cc *common_v1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The volume ID.
	VolumeId uint32 `protobuf:"varint,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The host for this volume.
	NodeId uint32 `protobuf:"varint,3,opt,name=node_id,json=nodeId" json:"node_id,omitempty"`
	// Volume credentials.
	Credentials *DfsResponderVolumeCredentials `protobuf:"bytes,4,opt,name=credentials" json:"credentials,omitempty"`
	// Volume statistics.
	Stats *DfsResponderVolumeStatistics `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
	// Server status for the volume.
	Status *DfsResponderVolumeStatus `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
}

func (m *DfsResponderVolume) Reset()                    { *m = DfsResponderVolume{} }
func (m *DfsResponderVolume) String() string            { return proto.CompactTextString(m) }
func (*DfsResponderVolume) ProtoMessage()               {}
func (*DfsResponderVolume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *DfsResponderVolume) GetCc() *common_v1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *DfsResponderVolume) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *DfsResponderVolume) GetNodeId() uint32 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *DfsResponderVolume) GetCredentials() *DfsResponderVolumeCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *DfsResponderVolume) GetStats() *DfsResponderVolumeStatistics {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *DfsResponderVolume) GetStatus() *DfsResponderVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type DfsResponderVolumeList struct {
	Volumes []*DfsResponderVolume `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
}

func (m *DfsResponderVolumeList) Reset()                    { *m = DfsResponderVolumeList{} }
func (m *DfsResponderVolumeList) String() string            { return proto.CompactTextString(m) }
func (*DfsResponderVolumeList) ProtoMessage()               {}
func (*DfsResponderVolumeList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *DfsResponderVolumeList) GetVolumes() []*DfsResponderVolume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type DfsResponderVolumeListQuery struct {
	// An optional list of volumes to query.
	VolumeIds []uint32 `protobuf:"varint,1,rep,packed,name=volume_ids,json=volumeIds" json:"volume_ids,omitempty"`
}

func (m *DfsResponderVolumeListQuery) Reset()                    { *m = DfsResponderVolumeListQuery{} }
func (m *DfsResponderVolumeListQuery) String() string            { return proto.CompactTextString(m) }
func (*DfsResponderVolumeListQuery) ProtoMessage()               {}
func (*DfsResponderVolumeListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DfsResponderVolumeListQuery) GetVolumeIds() []uint32 {
	if m != nil {
		return m.VolumeIds
	}
	return nil
}

func init() {
	proto.RegisterType((*DfsInitiatorStatusRequest)(nil), "directfs.v1.DfsInitiatorStatusRequest")
	proto.RegisterType((*DfsInitiatorStatus)(nil), "directfs.v1.DfsInitiatorStatus")
	proto.RegisterType((*DfsResponderStatusRequest)(nil), "directfs.v1.DfsResponderStatusRequest")
	proto.RegisterType((*DfsResponderStatus)(nil), "directfs.v1.DfsResponderStatus")
	proto.RegisterType((*DfsInitiatorNodeCredentials)(nil), "directfs.v1.DfsInitiatorNodeCredentials")
	proto.RegisterType((*DfsInitiatorNode)(nil), "directfs.v1.DfsInitiatorNode")
	proto.RegisterType((*DfsInitiatorNodeList)(nil), "directfs.v1.DfsInitiatorNodeList")
	proto.RegisterType((*DfsInitiatorNodeListQuery)(nil), "directfs.v1.DfsInitiatorNodeListQuery")
	proto.RegisterType((*DfsInitiatorVolumeCredentials)(nil), "directfs.v1.DfsInitiatorVolumeCredentials")
	proto.RegisterType((*DfsInitiatorVolumeStatistics)(nil), "directfs.v1.DfsInitiatorVolumeStatistics")
	proto.RegisterType((*DfsInitiatorVolumeStatus)(nil), "directfs.v1.DfsInitiatorVolumeStatus")
	proto.RegisterType((*DfsInitiatorVolume)(nil), "directfs.v1.DfsInitiatorVolume")
	proto.RegisterType((*DfsInitiatorVolumeList)(nil), "directfs.v1.DfsInitiatorVolumeList")
	proto.RegisterType((*DfsInitiatorVolumeListQuery)(nil), "directfs.v1.DfsInitiatorVolumeListQuery")
	proto.RegisterType((*DfsResponderVolumeCredentials)(nil), "directfs.v1.DfsResponderVolumeCredentials")
	proto.RegisterType((*DfsResponderVolumeStatistics)(nil), "directfs.v1.DfsResponderVolumeStatistics")
	proto.RegisterType((*DfsResponderVolumeStatus)(nil), "directfs.v1.DfsResponderVolumeStatus")
	proto.RegisterType((*DfsResponderVolume)(nil), "directfs.v1.DfsResponderVolume")
	proto.RegisterType((*DfsResponderVolumeList)(nil), "directfs.v1.DfsResponderVolumeList")
	proto.RegisterType((*DfsResponderVolumeListQuery)(nil), "directfs.v1.DfsResponderVolumeListQuery")
	proto.RegisterEnum("directfs.v1.DfsInitiatorVolumeStatus_DfsInitiatorConnectionState", DfsInitiatorVolumeStatus_DfsInitiatorConnectionState_name, DfsInitiatorVolumeStatus_DfsInitiatorConnectionState_value)
	proto.RegisterEnum("directfs.v1.DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily", DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily_name, DfsInitiatorVolumeStatus_DfsInitiatorAddressFamily_value)
	proto.RegisterEnum("directfs.v1.DfsResponderVolumeStatus_DfsResponderConnectionState", DfsResponderVolumeStatus_DfsResponderConnectionState_name, DfsResponderVolumeStatus_DfsResponderConnectionState_value)
	proto.RegisterEnum("directfs.v1.DfsResponderVolumeStatus_DfsResponderAddressFamily", DfsResponderVolumeStatus_DfsResponderAddressFamily_name, DfsResponderVolumeStatus_DfsResponderAddressFamily_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DfsInitiator service

type DfsInitiatorClient interface {
	// *
	// Get program status.
	Status(ctx context.Context, in *DfsInitiatorStatusRequest, opts ...grpc.CallOption) (*DfsInitiatorStatus, error)
	// *
	// Add a remote host entry to be used by volumes.
	//
	// returns RpcResult
	NodeCreate(ctx context.Context, in *DfsInitiatorNode, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Update a remote host entry to be used by volumes.
	//
	// returns RpcResult
	NodeUpdate(ctx context.Context, in *DfsInitiatorNode, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Remove a remote host entry.
	//
	// This will likely result in any volumes using this host to
	// become unconfigured. That has serious consequences.
	//
	// returns RpcResult
	NodeDelete(ctx context.Context, in *DfsInitiatorNode, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// List configured host entries, optionally filtered via a DfsHostListQuery
	// message.
	//
	// returns A DfsHostList message containing DfsHost messages,
	//         if any are available matching the filter.
	NodeList(ctx context.Context, in *DfsInitiatorNodeListQuery, opts ...grpc.CallOption) (*DfsInitiatorNodeList, error)
	// *
	// Create a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeCreate(ctx context.Context, in *DfsInitiatorVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Update a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeUpdate(ctx context.Context, in *DfsInitiatorVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Delete a volume previously configured by VolumeCreate.
	//
	// returns RpcResult
	VolumeDelete(ctx context.Context, in *DfsInitiatorVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns A DfsVolumeList message containing DfsVolume messages,
	//         if any are available matching the filter.
	VolumeList(ctx context.Context, in *DfsInitiatorVolumeListQuery, opts ...grpc.CallOption) (*DfsInitiatorVolumeList, error)
}

type dfsInitiatorClient struct {
	cc *grpc.ClientConn
}

func NewDfsInitiatorClient(cc *grpc.ClientConn) DfsInitiatorClient {
	return &dfsInitiatorClient{cc}
}

func (c *dfsInitiatorClient) Status(ctx context.Context, in *DfsInitiatorStatusRequest, opts ...grpc.CallOption) (*DfsInitiatorStatus, error) {
	out := new(DfsInitiatorStatus)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsInitiatorClient) NodeCreate(ctx context.Context, in *DfsInitiatorNode, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/NodeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsInitiatorClient) NodeUpdate(ctx context.Context, in *DfsInitiatorNode, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/NodeUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsInitiatorClient) NodeDelete(ctx context.Context, in *DfsInitiatorNode, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/NodeDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsInitiatorClient) NodeList(ctx context.Context, in *DfsInitiatorNodeListQuery, opts ...grpc.CallOption) (*DfsInitiatorNodeList, error) {
	out := new(DfsInitiatorNodeList)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/NodeList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsInitiatorClient) VolumeCreate(ctx context.Context, in *DfsInitiatorVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/VolumeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsInitiatorClient) VolumeUpdate(ctx context.Context, in *DfsInitiatorVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/VolumeUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsInitiatorClient) VolumeDelete(ctx context.Context, in *DfsInitiatorVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/VolumeDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsInitiatorClient) VolumeList(ctx context.Context, in *DfsInitiatorVolumeListQuery, opts ...grpc.CallOption) (*DfsInitiatorVolumeList, error) {
	out := new(DfsInitiatorVolumeList)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsInitiator/VolumeList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DfsInitiator service

type DfsInitiatorServer interface {
	// *
	// Get program status.
	Status(context.Context, *DfsInitiatorStatusRequest) (*DfsInitiatorStatus, error)
	// *
	// Add a remote host entry to be used by volumes.
	//
	// returns RpcResult
	NodeCreate(context.Context, *DfsInitiatorNode) (*common_v1.RpcResult, error)
	// *
	// Update a remote host entry to be used by volumes.
	//
	// returns RpcResult
	NodeUpdate(context.Context, *DfsInitiatorNode) (*common_v1.RpcResult, error)
	// *
	// Remove a remote host entry.
	//
	// This will likely result in any volumes using this host to
	// become unconfigured. That has serious consequences.
	//
	// returns RpcResult
	NodeDelete(context.Context, *DfsInitiatorNode) (*common_v1.RpcResult, error)
	// *
	// List configured host entries, optionally filtered via a DfsHostListQuery
	// message.
	//
	// returns A DfsHostList message containing DfsHost messages,
	//         if any are available matching the filter.
	NodeList(context.Context, *DfsInitiatorNodeListQuery) (*DfsInitiatorNodeList, error)
	// *
	// Create a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeCreate(context.Context, *DfsInitiatorVolume) (*common_v1.RpcResult, error)
	// *
	// Update a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeUpdate(context.Context, *DfsInitiatorVolume) (*common_v1.RpcResult, error)
	// *
	// Delete a volume previously configured by VolumeCreate.
	//
	// returns RpcResult
	VolumeDelete(context.Context, *DfsInitiatorVolume) (*common_v1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns A DfsVolumeList message containing DfsVolume messages,
	//         if any are available matching the filter.
	VolumeList(context.Context, *DfsInitiatorVolumeListQuery) (*DfsInitiatorVolumeList, error)
}

func RegisterDfsInitiatorServer(s *grpc.Server, srv DfsInitiatorServer) {
	s.RegisterService(&_DfsInitiator_serviceDesc, srv)
}

func _DfsInitiator_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).Status(ctx, req.(*DfsInitiatorStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsInitiator_NodeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).NodeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/NodeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).NodeCreate(ctx, req.(*DfsInitiatorNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsInitiator_NodeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).NodeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/NodeUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).NodeUpdate(ctx, req.(*DfsInitiatorNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsInitiator_NodeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).NodeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/NodeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).NodeDelete(ctx, req.(*DfsInitiatorNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsInitiator_NodeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorNodeListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).NodeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/NodeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).NodeList(ctx, req.(*DfsInitiatorNodeListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsInitiator_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).VolumeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/VolumeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).VolumeCreate(ctx, req.(*DfsInitiatorVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsInitiator_VolumeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).VolumeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/VolumeUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).VolumeUpdate(ctx, req.(*DfsInitiatorVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsInitiator_VolumeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).VolumeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/VolumeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).VolumeDelete(ctx, req.(*DfsInitiatorVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsInitiator_VolumeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsInitiatorVolumeListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsInitiatorServer).VolumeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsInitiator/VolumeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsInitiatorServer).VolumeList(ctx, req.(*DfsInitiatorVolumeListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

var _DfsInitiator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "directfs.v1.DfsInitiator",
	HandlerType: (*DfsInitiatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _DfsInitiator_Status_Handler,
		},
		{
			MethodName: "NodeCreate",
			Handler:    _DfsInitiator_NodeCreate_Handler,
		},
		{
			MethodName: "NodeUpdate",
			Handler:    _DfsInitiator_NodeUpdate_Handler,
		},
		{
			MethodName: "NodeDelete",
			Handler:    _DfsInitiator_NodeDelete_Handler,
		},
		{
			MethodName: "NodeList",
			Handler:    _DfsInitiator_NodeList_Handler,
		},
		{
			MethodName: "VolumeCreate",
			Handler:    _DfsInitiator_VolumeCreate_Handler,
		},
		{
			MethodName: "VolumeUpdate",
			Handler:    _DfsInitiator_VolumeUpdate_Handler,
		},
		{
			MethodName: "VolumeDelete",
			Handler:    _DfsInitiator_VolumeDelete_Handler,
		},
		{
			MethodName: "VolumeList",
			Handler:    _DfsInitiator_VolumeList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "directfs.proto",
}

// Client API for DfsResponder service

type DfsResponderClient interface {
	// *
	// Get program status.
	Status(ctx context.Context, in *DfsResponderStatusRequest, opts ...grpc.CallOption) (*DfsResponderStatus, error)
	// *
	// Create a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeCreate(ctx context.Context, in *DfsResponderVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Update a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeUpdate(ctx context.Context, in *DfsResponderVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Delete a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeDelete(ctx context.Context, in *DfsResponderVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns a list of DfsReponderVolume messages, if any are available matching the filter.
	VolumeList(ctx context.Context, in *DfsResponderVolumeListQuery, opts ...grpc.CallOption) (*DfsResponderVolumeList, error)
}

type dfsResponderClient struct {
	cc *grpc.ClientConn
}

func NewDfsResponderClient(cc *grpc.ClientConn) DfsResponderClient {
	return &dfsResponderClient{cc}
}

func (c *dfsResponderClient) Status(ctx context.Context, in *DfsResponderStatusRequest, opts ...grpc.CallOption) (*DfsResponderStatus, error) {
	out := new(DfsResponderStatus)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsResponder/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsResponderClient) VolumeCreate(ctx context.Context, in *DfsResponderVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsResponder/VolumeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsResponderClient) VolumeUpdate(ctx context.Context, in *DfsResponderVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsResponder/VolumeUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsResponderClient) VolumeDelete(ctx context.Context, in *DfsResponderVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsResponder/VolumeDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsResponderClient) VolumeList(ctx context.Context, in *DfsResponderVolumeListQuery, opts ...grpc.CallOption) (*DfsResponderVolumeList, error) {
	out := new(DfsResponderVolumeList)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsResponder/VolumeList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DfsResponder service

type DfsResponderServer interface {
	// *
	// Get program status.
	Status(context.Context, *DfsResponderStatusRequest) (*DfsResponderStatus, error)
	// *
	// Create a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeCreate(context.Context, *DfsResponderVolume) (*common_v1.RpcResult, error)
	// *
	// Update a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeUpdate(context.Context, *DfsResponderVolume) (*common_v1.RpcResult, error)
	// *
	// Delete a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeDelete(context.Context, *DfsResponderVolume) (*common_v1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns a list of DfsReponderVolume messages, if any are available matching the filter.
	VolumeList(context.Context, *DfsResponderVolumeListQuery) (*DfsResponderVolumeList, error)
}

func RegisterDfsResponderServer(s *grpc.Server, srv DfsResponderServer) {
	s.RegisterService(&_DfsResponder_serviceDesc, srv)
}

func _DfsResponder_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsResponderStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsResponderServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsResponder/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsResponderServer).Status(ctx, req.(*DfsResponderStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsResponder_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsResponderVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsResponderServer).VolumeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsResponder/VolumeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsResponderServer).VolumeCreate(ctx, req.(*DfsResponderVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsResponder_VolumeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsResponderVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsResponderServer).VolumeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsResponder/VolumeUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsResponderServer).VolumeUpdate(ctx, req.(*DfsResponderVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsResponder_VolumeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsResponderVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsResponderServer).VolumeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsResponder/VolumeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsResponderServer).VolumeDelete(ctx, req.(*DfsResponderVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsResponder_VolumeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsResponderVolumeListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsResponderServer).VolumeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsResponder/VolumeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsResponderServer).VolumeList(ctx, req.(*DfsResponderVolumeListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

var _DfsResponder_serviceDesc = grpc.ServiceDesc{
	ServiceName: "directfs.v1.DfsResponder",
	HandlerType: (*DfsResponderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _DfsResponder_Status_Handler,
		},
		{
			MethodName: "VolumeCreate",
			Handler:    _DfsResponder_VolumeCreate_Handler,
		},
		{
			MethodName: "VolumeUpdate",
			Handler:    _DfsResponder_VolumeUpdate_Handler,
		},
		{
			MethodName: "VolumeDelete",
			Handler:    _DfsResponder_VolumeDelete_Handler,
		},
		{
			MethodName: "VolumeList",
			Handler:    _DfsResponder_VolumeList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "directfs.proto",
}

func init() { proto.RegisterFile("directfs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 876 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x97, 0xdb, 0x8e, 0xe3, 0x44,
	0x10, 0x86, 0x73, 0x3e, 0x54, 0x0e, 0x32, 0xad, 0x15, 0x78, 0x13, 0x42, 0x66, 0x1b, 0xb1, 0x0a,
	0x7b, 0x11, 0xb4, 0x59, 0xb4, 0x08, 0x09, 0x34, 0x1a, 0x25, 0x61, 0x14, 0x18, 0x65, 0xc0, 0x81,
	0x81, 0x1b, 0x14, 0x8c, 0xdd, 0x11, 0x16, 0x89, 0x3b, 0xb8, 0x3b, 0x91, 0xe6, 0x31, 0x78, 0x00,
	0xde, 0x06, 0x1e, 0x87, 0x77, 0x40, 0x6e, 0x1f, 0x62, 0x3b, 0x76, 0xec, 0xcc, 0x68, 0x24, 0xee,
	0xd2, 0x5d, 0xd5, 0xbf, 0xab, 0xeb, 0xaf, 0xcf, 0x72, 0xa0, 0xad, 0x1b, 0x16, 0xd1, 0xf8, 0x8a,
	0x0d, 0xb7, 0x16, 0xe5, 0x14, 0x35, 0xfc, 0xf5, 0xfe, 0x75, 0xa7, 0xa9, 0xd1, 0xcd, 0x86, 0x9a,
	0x4e, 0x08, 0x77, 0xe1, 0xf9, 0x64, 0xc5, 0x66, 0xa6, 0xc1, 0x0d, 0x95, 0x53, 0x6b, 0xc1, 0x55,
	0xbe, 0x63, 0x0a, 0xf9, 0x63, 0x47, 0x18, 0xc7, 0x9f, 0x01, 0x3a, 0x0e, 0xa2, 0x17, 0xd0, 0xdc,
	0x13, 0x8b, 0x19, 0xd4, 0x5c, 0x1a, 0xe6, 0x8a, 0xca, 0xf9, 0x8b, 0xfc, 0xa0, 0xae, 0x34, 0xdc,
	0xbd, 0x99, 0xb9, 0xf2, 0x54, 0x15, 0xc2, 0xb6, 0xd4, 0xd4, 0x49, 0xac, 0x6a, 0x24, 0x98, 0x45,
	0xb5, 0x07, 0xdd, 0x60, 0x39, 0x73, 0xaa, 0x93, 0xb1, 0x45, 0x74, 0x62, 0x72, 0x43, 0x5d, 0x33,
	0xfc, 0x6f, 0x1e, 0xa4, 0x68, 0x1c, 0xbd, 0x82, 0x82, 0xa6, 0x09, 0xb1, 0xc6, 0xa8, 0x33, 0x74,
	0xaf, 0xbe, 0x7f, 0x3d, 0x9c, 0xa8, 0x5c, 0xdd, 0xae, 0x55, 0x93, 0x8c, 0xc5, 0x96, 0x52, 0xd0,
	0x34, 0xf4, 0x1e, 0x54, 0x4d, 0xaa, 0x93, 0xa5, 0xa1, 0xcb, 0x85, 0x8b, 0xfc, 0xa0, 0xa5, 0x54,
	0xec, 0xe5, 0x4c, 0x47, 0x1d, 0xa8, 0xfd, 0x46, 0x19, 0x37, 0xd5, 0x0d, 0x91, 0x8b, 0xa2, 0x2e,
	0x7f, 0x8d, 0x64, 0xa8, 0xaa, 0xba, 0x6e, 0x11, 0xc6, 0xe4, 0x92, 0x08, 0x79, 0x4b, 0x84, 0xa0,
	0xb4, 0xa5, 0x16, 0x97, 0xcb, 0x42, 0x4b, 0xfc, 0x46, 0x5f, 0x43, 0x43, 0x3b, 0x94, 0x2c, 0x57,
	0x44, 0x5d, 0x83, 0x61, 0xc0, 0x9f, 0xe1, 0x89, 0x2b, 0x2a, 0xc1, 0xc3, 0xf8, 0x1b, 0x78, 0x16,
	0xcd, 0xbd, 0x31, 0x18, 0x47, 0x6f, 0xa0, 0x6c, 0xd7, 0xcd, 0xe4, 0xfc, 0x45, 0x71, 0xd0, 0x18,
	0xf5, 0x4e, 0xaa, 0x2b, 0x4e, 0x2e, 0x7e, 0x1b, 0x9e, 0x03, 0x4f, 0xec, 0xbb, 0x1d, 0xb1, 0xee,
	0xd1, 0x73, 0xa8, 0xb9, 0x8d, 0x71, 0x44, 0x5b, 0x4a, 0xd5, 0xe9, 0x0c, 0xc3, 0x7d, 0xe8, 0x05,
	0xcf, 0xdd, 0xd1, 0xf5, 0x6e, 0x13, 0x72, 0xe5, 0x03, 0x78, 0xff, 0x38, 0xc1, 0xf6, 0xdc, 0x60,
	0xdc, 0xd0, 0x18, 0xfe, 0xb3, 0x08, 0x72, 0x7c, 0xc2, 0x8e, 0xa1, 0x5f, 0x00, 0x34, 0x6a, 0x9a,
	0x4b, 0xc6, 0x55, 0x4e, 0x84, 0x8b, 0xed, 0xd1, 0x55, 0xe2, 0x7d, 0x82, 0x47, 0x43, 0x81, 0x31,
	0x35, 0x4d, 0xa2, 0x71, 0x83, 0x9a, 0x76, 0x90, 0x28, 0x75, 0x5b, 0x54, 0xfc, 0x44, 0x5d, 0xa8,
	0x6f, 0x09, 0xb1, 0x96, 0xc2, 0xdb, 0x82, 0xe3, 0xad, 0xbd, 0x31, 0xb7, 0xbd, 0xfd, 0x09, 0xaa,
	0x22, 0xa8, 0xae, 0x84, 0xed, 0xed, 0xd1, 0xe5, 0xf9, 0xcf, 0xbe, 0x72, 0xa6, 0xe1, 0x2b, 0x75,
	0x63, 0xac, 0xef, 0x95, 0x8a, 0xad, 0x77, 0xb5, 0xc2, 0xbf, 0x87, 0x47, 0x39, 0x52, 0x20, 0xaa,
	0x41, 0x69, 0x7e, 0x3b, 0x9f, 0x4a, 0x39, 0xd4, 0x06, 0x18, 0xdf, 0xce, 0xe7, 0xd3, 0xf1, 0xf7,
	0xb3, 0xf9, 0xb5, 0x94, 0x47, 0x2d, 0xa8, 0xbb, 0xeb, 0xe9, 0x44, 0x2a, 0xa0, 0x77, 0xa0, 0x35,
	0x99, 0x2d, 0x02, 0x19, 0x45, 0x24, 0x41, 0xf3, 0xb0, 0x35, 0x9d, 0x48, 0x25, 0xfc, 0x49, 0xd8,
	0xdb, 0x50, 0x45, 0xf6, 0xa3, 0x66, 0xdf, 0xde, 0x7d, 0x2a, 0xe5, 0xdc, 0x5f, 0x6f, 0xa5, 0x3c,
	0xfe, 0xbb, 0x10, 0x06, 0xdf, 0xb9, 0xdc, 0x59, 0x2c, 0x75, 0xa1, 0xbe, 0x17, 0xa7, 0x0e, 0x34,
	0xd5, 0x9c, 0x8d, 0x99, 0x1e, 0x04, 0xad, 0x18, 0x02, 0xed, 0x26, 0x8c, 0x47, 0x49, 0x3c, 0xea,
	0x55, 0x4a, 0xd3, 0x93, 0x00, 0x41, 0x97, 0x50, 0xb6, 0x07, 0x87, 0x09, 0x02, 0x1b, 0xa3, 0x8f,
	0x33, 0x98, 0xe7, 0x0c, 0xa5, 0xe2, 0x9c, 0x43, 0x5f, 0x42, 0x85, 0x09, 0x47, 0x5d, 0x50, 0x3f,
	0xca, 0x64, 0xbf, 0xe2, 0x1e, 0xc2, 0x0b, 0x78, 0xf7, 0x38, 0x47, 0x20, 0xfa, 0x39, 0x54, 0x9d,
	0x66, 0x78, 0x90, 0xf6, 0x53, 0x94, 0x15, 0x2f, 0x1f, 0x7f, 0x11, 0x9e, 0x9c, 0x83, 0xa8, 0x83,
	0x6a, 0x0f, 0xc0, 0xef, 0xbb, 0x07, 0x6b, 0xdd, 0x6b, 0xbc, 0x87, 0xab, 0xff, 0xee, 0x4d, 0xc2,
	0x35, 0x92, 0x70, 0x8c, 0x6b, 0x4c, 0x42, 0x56, 0x5c, 0x63, 0x8f, 0x86, 0x02, 0x4f, 0x87, 0x6b,
	0xfa, 0xb3, 0x4f, 0xe1, 0x9a, 0x54, 0xe0, 0x93, 0xe0, 0x1a, 0x5f, 0xd1, 0x29, 0x5c, 0x23, 0x97,
	0xfb, 0xdf, 0xe0, 0x9a, 0x3c, 0x6d, 0xe7, 0xe1, 0x9a, 0x38, 0x94, 0x99, 0x71, 0x8d, 0xb5, 0x3f,
	0x82, 0x6b, 0x24, 0x27, 0x23, 0xae, 0x91, 0x53, 0x51, 0x5c, 0x63, 0x44, 0xb3, 0xe0, 0x3a, 0xfa,
	0xa7, 0x0c, 0xcd, 0x20, 0xed, 0x68, 0x01, 0x15, 0x97, 0xb5, 0x97, 0x89, 0x6f, 0x8c, 0xd0, 0xd7,
	0x56, 0xa7, 0x9f, 0x92, 0x87, 0x73, 0x68, 0x0c, 0xe0, 0x7e, 0x68, 0xd8, 0xc3, 0x7c, 0xfa, 0x7b,
	0xa1, 0xf3, 0x2c, 0x30, 0x49, 0xca, 0x56, 0x53, 0x08, 0xdb, 0xad, 0xf9, 0x41, 0xe4, 0x87, 0xad,
	0xfe, 0x78, 0x91, 0x09, 0x59, 0x93, 0x87, 0x8b, 0xfc, 0x08, 0x35, 0xff, 0x5b, 0xe8, 0xe5, 0x49,
	0x09, 0xdf, 0x87, 0xce, 0x8b, 0xd4, 0x3c, 0x9c, 0x43, 0xd7, 0xd0, 0xf4, 0x47, 0xd8, 0xbe, 0x64,
	0xda, 0x4b, 0x3b, 0xb1, 0x42, 0x5f, 0xc8, 0xed, 0xd6, 0xe3, 0x85, 0xdc, 0x8e, 0x3d, 0x58, 0xe8,
	0x67, 0x80, 0xc0, 0xbc, 0x0f, 0x52, 0x64, 0x0e, 0x7d, 0xfb, 0x30, 0x43, 0x26, 0xce, 0x8d, 0xfe,
	0x2a, 0x8a, 0x39, 0xf6, 0x31, 0x38, 0x35, 0xc7, 0xf1, 0xff, 0x1a, 0x3a, 0xfd, 0x94, 0xbc, 0x2c,
	0xfe, 0x44, 0x30, 0x7c, 0xb8, 0x3f, 0x67, 0x0b, 0x25, 0xf9, 0x93, 0x55, 0x28, 0xc5, 0x9f, 0xa4,
	0xf7, 0xcb, 0xb1, 0x3f, 0x31, 0x99, 0x38, 0xf7, 0x6b, 0x45, 0xfc, 0x19, 0x7c, 0xf3, 0x5f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xc5, 0xbc, 0x4b, 0x34, 0x39, 0x0e, 0x00, 0x00,
}
