// Code generated by protoc-gen-go. DO NOT EDIT.
// source: directfs.proto

/*
Package directfs_v1 is a generated protocol buffer package.

It is generated from these files:
	directfs.proto

It has these top-level messages:
	DfsClientStatusRequest
	DfsClientStatus
	DfsServerStatusRequest
	DfsServerStatus
	DfsHostCredentials
	DfsHost
	DfsHostList
	DfsHostListQuery
	DfsVolumeCredentials
	DfsVolumeStatistics
	DfsVolumeStatus
	DfsVolume
	DfsVolumeList
	DfsVolumeListQuery
*/
package directfs_v1

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common_v1 "."

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DfsVolumeStatus_DfsConnectionState int32

const (
	DfsVolumeStatus_NONE          DfsVolumeStatus_DfsConnectionState = 0
	DfsVolumeStatus_CONNECTING    DfsVolumeStatus_DfsConnectionState = 1
	DfsVolumeStatus_CONNECTED     DfsVolumeStatus_DfsConnectionState = 2
	DfsVolumeStatus_DISCONNECTING DfsVolumeStatus_DfsConnectionState = 3
	DfsVolumeStatus_DISCONNECTED  DfsVolumeStatus_DfsConnectionState = 4
)

var DfsVolumeStatus_DfsConnectionState_name = map[int32]string{
	0: "NONE",
	1: "CONNECTING",
	2: "CONNECTED",
	3: "DISCONNECTING",
	4: "DISCONNECTED",
}
var DfsVolumeStatus_DfsConnectionState_value = map[string]int32{
	"NONE":          0,
	"CONNECTING":    1,
	"CONNECTED":     2,
	"DISCONNECTING": 3,
	"DISCONNECTED":  4,
}

func (x DfsVolumeStatus_DfsConnectionState) String() string {
	return proto.EnumName(DfsVolumeStatus_DfsConnectionState_name, int32(x))
}
func (DfsVolumeStatus_DfsConnectionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0}
}

type DfsVolumeStatus_DfsAddressFamily int32

const (
	DfsVolumeStatus_IPV4 DfsVolumeStatus_DfsAddressFamily = 0
	DfsVolumeStatus_IPV6 DfsVolumeStatus_DfsAddressFamily = 1
)

var DfsVolumeStatus_DfsAddressFamily_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
}
var DfsVolumeStatus_DfsAddressFamily_value = map[string]int32{
	"IPV4": 0,
	"IPV6": 1,
}

func (x DfsVolumeStatus_DfsAddressFamily) String() string {
	return proto.EnumName(DfsVolumeStatus_DfsAddressFamily_name, int32(x))
}
func (DfsVolumeStatus_DfsAddressFamily) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 1}
}

type DfsClientStatusRequest struct {
}

func (m *DfsClientStatusRequest) Reset()                    { *m = DfsClientStatusRequest{} }
func (m *DfsClientStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*DfsClientStatusRequest) ProtoMessage()               {}
func (*DfsClientStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type DfsClientStatus struct {
	VersionInfo string `protobuf:"bytes,1,opt,name=version_info,json=versionInfo" json:"version_info,omitempty"`
}

func (m *DfsClientStatus) Reset()                    { *m = DfsClientStatus{} }
func (m *DfsClientStatus) String() string            { return proto.CompactTextString(m) }
func (*DfsClientStatus) ProtoMessage()               {}
func (*DfsClientStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DfsClientStatus) GetVersionInfo() string {
	if m != nil {
		return m.VersionInfo
	}
	return ""
}

type DfsServerStatusRequest struct {
}

func (m *DfsServerStatusRequest) Reset()                    { *m = DfsServerStatusRequest{} }
func (m *DfsServerStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*DfsServerStatusRequest) ProtoMessage()               {}
func (*DfsServerStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type DfsServerStatus struct {
	VersionInfo string `protobuf:"bytes,1,opt,name=version_info,json=versionInfo" json:"version_info,omitempty"`
}

func (m *DfsServerStatus) Reset()                    { *m = DfsServerStatus{} }
func (m *DfsServerStatus) String() string            { return proto.CompactTextString(m) }
func (*DfsServerStatus) ProtoMessage()               {}
func (*DfsServerStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DfsServerStatus) GetVersionInfo() string {
	if m != nil {
		return m.VersionInfo
	}
	return ""
}

type DfsHostCredentials struct {
}

func (m *DfsHostCredentials) Reset()                    { *m = DfsHostCredentials{} }
func (m *DfsHostCredentials) String() string            { return proto.CompactTextString(m) }
func (*DfsHostCredentials) ProtoMessage()               {}
func (*DfsHostCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// *
// A host used by DirectFS.
type DfsHost struct {
	Cc *common_v1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The unique host identifier.
	HostId uint32 `protobuf:"varint,2,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	// The remote hostname.
	Hostname string `protobuf:"bytes,3,opt,name=hostname" json:"hostname,omitempty"`
	// The remote port.
	Port uint32 `protobuf:"varint,4,opt,name=port" json:"port,omitempty"`
	// Host credentials.
	Credentials *DfsHostCredentials `protobuf:"bytes,5,opt,name=credentials" json:"credentials,omitempty"`
}

func (m *DfsHost) Reset()                    { *m = DfsHost{} }
func (m *DfsHost) String() string            { return proto.CompactTextString(m) }
func (*DfsHost) ProtoMessage()               {}
func (*DfsHost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DfsHost) GetCc() *common_v1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *DfsHost) GetHostId() uint32 {
	if m != nil {
		return m.HostId
	}
	return 0
}

func (m *DfsHost) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *DfsHost) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *DfsHost) GetCredentials() *DfsHostCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

type DfsHostList struct {
	Hosts []*DfsHost `protobuf:"bytes,1,rep,name=hosts" json:"hosts,omitempty"`
}

func (m *DfsHostList) Reset()                    { *m = DfsHostList{} }
func (m *DfsHostList) String() string            { return proto.CompactTextString(m) }
func (*DfsHostList) ProtoMessage()               {}
func (*DfsHostList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *DfsHostList) GetHosts() []*DfsHost {
	if m != nil {
		return m.Hosts
	}
	return nil
}

type DfsHostListQuery struct {
	// An optional list of hosts to query.
	HostIds []uint32 `protobuf:"varint,1,rep,packed,name=host_ids,json=hostIds" json:"host_ids,omitempty"`
}

func (m *DfsHostListQuery) Reset()                    { *m = DfsHostListQuery{} }
func (m *DfsHostListQuery) String() string            { return proto.CompactTextString(m) }
func (*DfsHostListQuery) ProtoMessage()               {}
func (*DfsHostListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DfsHostListQuery) GetHostIds() []uint32 {
	if m != nil {
		return m.HostIds
	}
	return nil
}

type DfsVolumeCredentials struct {
}

func (m *DfsVolumeCredentials) Reset()                    { *m = DfsVolumeCredentials{} }
func (m *DfsVolumeCredentials) String() string            { return proto.CompactTextString(m) }
func (*DfsVolumeCredentials) ProtoMessage()               {}
func (*DfsVolumeCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type DfsVolumeStatistics struct {
}

func (m *DfsVolumeStatistics) Reset()                    { *m = DfsVolumeStatistics{} }
func (m *DfsVolumeStatistics) String() string            { return proto.CompactTextString(m) }
func (*DfsVolumeStatistics) ProtoMessage()               {}
func (*DfsVolumeStatistics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type DfsVolumeStatus struct {
	ConnState DfsVolumeStatus_DfsConnectionState `protobuf:"varint,1,opt,name=conn_state,json=connState,enum=directfs.v1.DfsVolumeStatus_DfsConnectionState" json:"conn_state,omitempty"`
	// The remote peer, in string form for simplicity.
	PeerName string `protobuf:"bytes,2,opt,name=peer_name,json=peerName" json:"peer_name,omitempty"`
	// The address family we're using to connect to the peer.
	PeerAf DfsVolumeStatus_DfsAddressFamily `protobuf:"varint,3,opt,name=peer_af,json=peerAf,enum=directfs.v1.DfsVolumeStatus_DfsAddressFamily" json:"peer_af,omitempty"`
}

func (m *DfsVolumeStatus) Reset()                    { *m = DfsVolumeStatus{} }
func (m *DfsVolumeStatus) String() string            { return proto.CompactTextString(m) }
func (*DfsVolumeStatus) ProtoMessage()               {}
func (*DfsVolumeStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DfsVolumeStatus) GetConnState() DfsVolumeStatus_DfsConnectionState {
	if m != nil {
		return m.ConnState
	}
	return DfsVolumeStatus_NONE
}

func (m *DfsVolumeStatus) GetPeerName() string {
	if m != nil {
		return m.PeerName
	}
	return ""
}

func (m *DfsVolumeStatus) GetPeerAf() DfsVolumeStatus_DfsAddressFamily {
	if m != nil {
		return m.PeerAf
	}
	return DfsVolumeStatus_IPV4
}

// *
// A volume used by DirectFS.
//
// The remote host (for the client) isn't directly included here. However, the
// client clearly can't connect without a properly configured host_id item.
//
// The split between host and volume objects was decided based on now-irrelevant
// implementation details of ConfigFS v1. However, there's still some logic to
// it if the authentication (especially TLS) is per-host rather than per-volume.
type DfsVolume struct {
	Cc *common_v1.DataplaneCommon `protobuf:"bytes,1,opt,name=cc" json:"cc,omitempty"`
	// The volume ID.
	VolumeId uint32 `protobuf:"varint,2,opt,name=volume_id,json=volumeId" json:"volume_id,omitempty"`
	// The host for this volume.
	HostId uint32 `protobuf:"varint,3,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	// Volume credentials.
	Credentials *DfsVolumeCredentials `protobuf:"bytes,4,opt,name=credentials" json:"credentials,omitempty"`
	// Volume statistics.
	Stats *DfsVolumeStatistics `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
	// Server status for the volume.
	Status *DfsVolumeStatus `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
}

func (m *DfsVolume) Reset()                    { *m = DfsVolume{} }
func (m *DfsVolume) String() string            { return proto.CompactTextString(m) }
func (*DfsVolume) ProtoMessage()               {}
func (*DfsVolume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DfsVolume) GetCc() *common_v1.DataplaneCommon {
	if m != nil {
		return m.Cc
	}
	return nil
}

func (m *DfsVolume) GetVolumeId() uint32 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *DfsVolume) GetHostId() uint32 {
	if m != nil {
		return m.HostId
	}
	return 0
}

func (m *DfsVolume) GetCredentials() *DfsVolumeCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *DfsVolume) GetStats() *DfsVolumeStatistics {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *DfsVolume) GetStatus() *DfsVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type DfsVolumeList struct {
	Volumes []*DfsVolume `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
}

func (m *DfsVolumeList) Reset()                    { *m = DfsVolumeList{} }
func (m *DfsVolumeList) String() string            { return proto.CompactTextString(m) }
func (*DfsVolumeList) ProtoMessage()               {}
func (*DfsVolumeList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *DfsVolumeList) GetVolumes() []*DfsVolume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

type DfsVolumeListQuery struct {
	// An optional list of volumes to query.
	VolumeIds []uint32 `protobuf:"varint,1,rep,packed,name=volume_ids,json=volumeIds" json:"volume_ids,omitempty"`
}

func (m *DfsVolumeListQuery) Reset()                    { *m = DfsVolumeListQuery{} }
func (m *DfsVolumeListQuery) String() string            { return proto.CompactTextString(m) }
func (*DfsVolumeListQuery) ProtoMessage()               {}
func (*DfsVolumeListQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *DfsVolumeListQuery) GetVolumeIds() []uint32 {
	if m != nil {
		return m.VolumeIds
	}
	return nil
}

func init() {
	proto.RegisterType((*DfsClientStatusRequest)(nil), "directfs.v1.DfsClientStatusRequest")
	proto.RegisterType((*DfsClientStatus)(nil), "directfs.v1.DfsClientStatus")
	proto.RegisterType((*DfsServerStatusRequest)(nil), "directfs.v1.DfsServerStatusRequest")
	proto.RegisterType((*DfsServerStatus)(nil), "directfs.v1.DfsServerStatus")
	proto.RegisterType((*DfsHostCredentials)(nil), "directfs.v1.DfsHostCredentials")
	proto.RegisterType((*DfsHost)(nil), "directfs.v1.DfsHost")
	proto.RegisterType((*DfsHostList)(nil), "directfs.v1.DfsHostList")
	proto.RegisterType((*DfsHostListQuery)(nil), "directfs.v1.DfsHostListQuery")
	proto.RegisterType((*DfsVolumeCredentials)(nil), "directfs.v1.DfsVolumeCredentials")
	proto.RegisterType((*DfsVolumeStatistics)(nil), "directfs.v1.DfsVolumeStatistics")
	proto.RegisterType((*DfsVolumeStatus)(nil), "directfs.v1.DfsVolumeStatus")
	proto.RegisterType((*DfsVolume)(nil), "directfs.v1.DfsVolume")
	proto.RegisterType((*DfsVolumeList)(nil), "directfs.v1.DfsVolumeList")
	proto.RegisterType((*DfsVolumeListQuery)(nil), "directfs.v1.DfsVolumeListQuery")
	proto.RegisterEnum("directfs.v1.DfsVolumeStatus_DfsConnectionState", DfsVolumeStatus_DfsConnectionState_name, DfsVolumeStatus_DfsConnectionState_value)
	proto.RegisterEnum("directfs.v1.DfsVolumeStatus_DfsAddressFamily", DfsVolumeStatus_DfsAddressFamily_name, DfsVolumeStatus_DfsAddressFamily_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DfsClient service

type DfsClientClient interface {
	// *
	// Get program status.
	Status(ctx context.Context, in *DfsClientStatusRequest, opts ...grpc.CallOption) (*DfsClientStatus, error)
	// *
	// Add a remote host entry to be used by volumes.
	//
	// returns RpcResult
	ServerCreate(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Update a remote host entry to be used by volumes.
	//
	// returns RpcResult
	ServerUpdate(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Remove a remote host entry.
	//
	// This will likely result in any volumes using this host to
	// become unconfigured. That has serious consequences.
	//
	// returns RpcResult
	ServerDelete(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// List configured host entries, optionally filtered via a DfsHostListQuery
	// message.
	//
	// returns A DfsHostList message containing DfsHost messages,
	//         if any are available matching the filter.
	ServerList(ctx context.Context, in *DfsHostListQuery, opts ...grpc.CallOption) (*DfsHostList, error)
	// *
	// Create a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeCreate(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Update a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeUpdate(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Delete a volume previously configured by VolumeCreate.
	//
	// returns RpcResult
	VolumeDelete(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns A DfsVolumeList message containing DfsVolume messages,
	//         if any are available matching the filter.
	VolumeList(ctx context.Context, in *DfsVolumeListQuery, opts ...grpc.CallOption) (*DfsVolumeList, error)
}

type dfsClientClient struct {
	cc *grpc.ClientConn
}

func NewDfsClientClient(cc *grpc.ClientConn) DfsClientClient {
	return &dfsClientClient{cc}
}

func (c *dfsClientClient) Status(ctx context.Context, in *DfsClientStatusRequest, opts ...grpc.CallOption) (*DfsClientStatus, error) {
	out := new(DfsClientStatus)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsClientClient) ServerCreate(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/ServerCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsClientClient) ServerUpdate(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/ServerUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsClientClient) ServerDelete(ctx context.Context, in *DfsHost, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/ServerDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsClientClient) ServerList(ctx context.Context, in *DfsHostListQuery, opts ...grpc.CallOption) (*DfsHostList, error) {
	out := new(DfsHostList)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/ServerList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsClientClient) VolumeCreate(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/VolumeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsClientClient) VolumeUpdate(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/VolumeUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsClientClient) VolumeDelete(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/VolumeDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsClientClient) VolumeList(ctx context.Context, in *DfsVolumeListQuery, opts ...grpc.CallOption) (*DfsVolumeList, error) {
	out := new(DfsVolumeList)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsClient/VolumeList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DfsClient service

type DfsClientServer interface {
	// *
	// Get program status.
	Status(context.Context, *DfsClientStatusRequest) (*DfsClientStatus, error)
	// *
	// Add a remote host entry to be used by volumes.
	//
	// returns RpcResult
	ServerCreate(context.Context, *DfsHost) (*common_v1.RpcResult, error)
	// *
	// Update a remote host entry to be used by volumes.
	//
	// returns RpcResult
	ServerUpdate(context.Context, *DfsHost) (*common_v1.RpcResult, error)
	// *
	// Remove a remote host entry.
	//
	// This will likely result in any volumes using this host to
	// become unconfigured. That has serious consequences.
	//
	// returns RpcResult
	ServerDelete(context.Context, *DfsHost) (*common_v1.RpcResult, error)
	// *
	// List configured host entries, optionally filtered via a DfsHostListQuery
	// message.
	//
	// returns A DfsHostList message containing DfsHost messages,
	//         if any are available matching the filter.
	ServerList(context.Context, *DfsHostListQuery) (*DfsHostList, error)
	// *
	// Create a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeCreate(context.Context, *DfsVolume) (*common_v1.RpcResult, error)
	// *
	// Update a volume on a remote host. The DfsHost matching the host id
	// in the DfsVolume message must be configured for the volume to actually
	// be configured on the DirectFS client.
	//
	// returns RpcResult
	VolumeUpdate(context.Context, *DfsVolume) (*common_v1.RpcResult, error)
	// *
	// Delete a volume previously configured by VolumeCreate.
	//
	// returns RpcResult
	VolumeDelete(context.Context, *DfsVolume) (*common_v1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns A DfsVolumeList message containing DfsVolume messages,
	//         if any are available matching the filter.
	VolumeList(context.Context, *DfsVolumeListQuery) (*DfsVolumeList, error)
}

func RegisterDfsClientServer(s *grpc.Server, srv DfsClientServer) {
	s.RegisterService(&_DfsClient_serviceDesc, srv)
}

func _DfsClient_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsClientStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).Status(ctx, req.(*DfsClientStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsClient_ServerCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).ServerCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/ServerCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).ServerCreate(ctx, req.(*DfsHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsClient_ServerUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).ServerUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/ServerUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).ServerUpdate(ctx, req.(*DfsHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsClient_ServerDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).ServerDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/ServerDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).ServerDelete(ctx, req.(*DfsHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsClient_ServerList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsHostListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).ServerList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/ServerList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).ServerList(ctx, req.(*DfsHostListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsClient_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).VolumeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/VolumeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).VolumeCreate(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsClient_VolumeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).VolumeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/VolumeUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).VolumeUpdate(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsClient_VolumeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).VolumeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/VolumeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).VolumeDelete(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsClient_VolumeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolumeListQuery)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsClientServer).VolumeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsClient/VolumeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsClientServer).VolumeList(ctx, req.(*DfsVolumeListQuery))
	}
	return interceptor(ctx, in, info, handler)
}

var _DfsClient_serviceDesc = grpc.ServiceDesc{
	ServiceName: "directfs.v1.DfsClient",
	HandlerType: (*DfsClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _DfsClient_Status_Handler,
		},
		{
			MethodName: "ServerCreate",
			Handler:    _DfsClient_ServerCreate_Handler,
		},
		{
			MethodName: "ServerUpdate",
			Handler:    _DfsClient_ServerUpdate_Handler,
		},
		{
			MethodName: "ServerDelete",
			Handler:    _DfsClient_ServerDelete_Handler,
		},
		{
			MethodName: "ServerList",
			Handler:    _DfsClient_ServerList_Handler,
		},
		{
			MethodName: "VolumeCreate",
			Handler:    _DfsClient_VolumeCreate_Handler,
		},
		{
			MethodName: "VolumeUpdate",
			Handler:    _DfsClient_VolumeUpdate_Handler,
		},
		{
			MethodName: "VolumeDelete",
			Handler:    _DfsClient_VolumeDelete_Handler,
		},
		{
			MethodName: "VolumeList",
			Handler:    _DfsClient_VolumeList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "directfs.proto",
}

// Client API for DfsServer service

type DfsServerClient interface {
	// *
	// Get program status.
	Status(ctx context.Context, in *DfsServerStatusRequest, opts ...grpc.CallOption) (*DfsServerStatus, error)
	// *
	// Create a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeCreate(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Update a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeUpdate(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// Delete a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeDelete(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns a stream of DfsVolume messages, if any are available matching the filter.
	VolumeList(ctx context.Context, in *DfsVolumeListQuery, opts ...grpc.CallOption) (DfsServer_VolumeListClient, error)
}

type dfsServerClient struct {
	cc *grpc.ClientConn
}

func NewDfsServerClient(cc *grpc.ClientConn) DfsServerClient {
	return &dfsServerClient{cc}
}

func (c *dfsServerClient) Status(ctx context.Context, in *DfsServerStatusRequest, opts ...grpc.CallOption) (*DfsServerStatus, error) {
	out := new(DfsServerStatus)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsServer/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsServerClient) VolumeCreate(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsServer/VolumeCreate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsServerClient) VolumeUpdate(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsServer/VolumeUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsServerClient) VolumeDelete(ctx context.Context, in *DfsVolume, opts ...grpc.CallOption) (*common_v1.RpcResult, error) {
	out := new(common_v1.RpcResult)
	err := grpc.Invoke(ctx, "/directfs.v1.DfsServer/VolumeDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dfsServerClient) VolumeList(ctx context.Context, in *DfsVolumeListQuery, opts ...grpc.CallOption) (DfsServer_VolumeListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_DfsServer_serviceDesc.Streams[0], c.cc, "/directfs.v1.DfsServer/VolumeList", opts...)
	if err != nil {
		return nil, err
	}
	x := &dfsServerVolumeListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DfsServer_VolumeListClient interface {
	Recv() (*DfsVolume, error)
	grpc.ClientStream
}

type dfsServerVolumeListClient struct {
	grpc.ClientStream
}

func (x *dfsServerVolumeListClient) Recv() (*DfsVolume, error) {
	m := new(DfsVolume)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for DfsServer service

type DfsServerServer interface {
	// *
	// Get program status.
	Status(context.Context, *DfsServerStatusRequest) (*DfsServerStatus, error)
	// *
	// Create a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeCreate(context.Context, *DfsVolume) (*common_v1.RpcResult, error)
	// *
	// Update a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeUpdate(context.Context, *DfsVolume) (*common_v1.RpcResult, error)
	// *
	// Delete a volume to be served via DFS. Currently does nothing, but should still
	// be performed as in the near future it will certainly be required.
	//
	// returns RpcResult
	VolumeDelete(context.Context, *DfsVolume) (*common_v1.RpcResult, error)
	// *
	// List configured volume entries, optionally filtered via a DfsVolumeListQuery
	// message.
	//
	// returns a stream of DfsVolume messages, if any are available matching the filter.
	VolumeList(*DfsVolumeListQuery, DfsServer_VolumeListServer) error
}

func RegisterDfsServerServer(s *grpc.Server, srv DfsServerServer) {
	s.RegisterService(&_DfsServer_serviceDesc, srv)
}

func _DfsServer_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsServerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsServerServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsServer/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsServerServer).Status(ctx, req.(*DfsServerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsServer_VolumeCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsServerServer).VolumeCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsServer/VolumeCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsServerServer).VolumeCreate(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsServer_VolumeUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsServerServer).VolumeUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsServer/VolumeUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsServerServer).VolumeUpdate(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsServer_VolumeDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DfsVolume)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DfsServerServer).VolumeDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/directfs.v1.DfsServer/VolumeDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DfsServerServer).VolumeDelete(ctx, req.(*DfsVolume))
	}
	return interceptor(ctx, in, info, handler)
}

func _DfsServer_VolumeList_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DfsVolumeListQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DfsServerServer).VolumeList(m, &dfsServerVolumeListServer{stream})
}

type DfsServer_VolumeListServer interface {
	Send(*DfsVolume) error
	grpc.ServerStream
}

type dfsServerVolumeListServer struct {
	grpc.ServerStream
}

func (x *dfsServerVolumeListServer) Send(m *DfsVolume) error {
	return x.ServerStream.SendMsg(m)
}

var _DfsServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "directfs.v1.DfsServer",
	HandlerType: (*DfsServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _DfsServer_Status_Handler,
		},
		{
			MethodName: "VolumeCreate",
			Handler:    _DfsServer_VolumeCreate_Handler,
		},
		{
			MethodName: "VolumeUpdate",
			Handler:    _DfsServer_VolumeUpdate_Handler,
		},
		{
			MethodName: "VolumeDelete",
			Handler:    _DfsServer_VolumeDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "VolumeList",
			Handler:       _DfsServer_VolumeList_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "directfs.proto",
}

func init() { proto.RegisterFile("directfs.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 764 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x56, 0xdd, 0x6e, 0xd3, 0x30,
	0x14, 0x6e, 0xda, 0xae, 0x5d, 0x4f, 0x7f, 0x08, 0xa6, 0x8c, 0xd0, 0x6d, 0x5a, 0x67, 0x24, 0x34,
	0x21, 0xad, 0x6c, 0xdd, 0x34, 0x09, 0x09, 0x21, 0x55, 0x49, 0x37, 0x2a, 0xa0, 0x83, 0x0c, 0x76,
	0x5b, 0x65, 0x89, 0x23, 0x22, 0xb5, 0x49, 0x89, 0xdd, 0x4a, 0x7b, 0x1b, 0x5e, 0x85, 0x57, 0xe0,
	0x1d, 0xb8, 0xe1, 0x29, 0x90, 0xed, 0x34, 0xcd, 0xba, 0x74, 0x50, 0xb8, 0xe3, 0x2e, 0x3e, 0x3e,
	0xdf, 0x39, 0xc7, 0xdf, 0xf7, 0xd9, 0x2d, 0xd4, 0x1c, 0x2f, 0x24, 0x36, 0x73, 0x69, 0x6b, 0x1c,
	0x06, 0x2c, 0x40, 0xe5, 0x78, 0x3d, 0x3d, 0x6c, 0x54, 0xec, 0x60, 0x34, 0x0a, 0x7c, 0xb9, 0x85,
	0x35, 0xd8, 0x30, 0x5c, 0xaa, 0x0f, 0x3d, 0xe2, 0xb3, 0x0b, 0x66, 0xb1, 0x09, 0x35, 0xc9, 0x97,
	0x09, 0xa1, 0x0c, 0x1f, 0xc3, 0xbd, 0x85, 0x1d, 0xb4, 0x0b, 0x95, 0x29, 0x09, 0xa9, 0x17, 0xf8,
	0x03, 0xcf, 0x77, 0x03, 0x4d, 0x69, 0x2a, 0x7b, 0x25, 0xb3, 0x1c, 0xc5, 0x7a, 0xbe, 0x3b, 0xab,
	0x77, 0x41, 0xc2, 0x29, 0x09, 0xd3, 0xea, 0x25, 0x77, 0xfe, 0xa4, 0x5e, 0x1d, 0x90, 0xe1, 0xd2,
	0xd7, 0x01, 0x65, 0x7a, 0x48, 0x1c, 0xe2, 0x33, 0xcf, 0x1a, 0x52, 0xfc, 0x4d, 0x81, 0x62, 0x14,
	0x46, 0xcf, 0x20, 0x6b, 0xdb, 0x02, 0x5a, 0x6e, 0x37, 0x5a, 0xd1, 0xe1, 0xa6, 0x87, 0x2d, 0xc3,
	0x62, 0xd6, 0x78, 0x68, 0xf9, 0x44, 0x17, 0x21, 0x33, 0x6b, 0xdb, 0xe8, 0x11, 0x14, 0x3f, 0x07,
	0x94, 0x0d, 0x3c, 0x47, 0xcb, 0x36, 0x95, 0xbd, 0xaa, 0x59, 0xe0, 0xcb, 0x9e, 0x83, 0x1a, 0xb0,
	0xce, 0xbf, 0x7c, 0x6b, 0x44, 0xb4, 0x9c, 0x98, 0x22, 0x5e, 0x23, 0x04, 0xf9, 0x71, 0x10, 0x32,
	0x2d, 0x2f, 0x10, 0xe2, 0x1b, 0x75, 0xa0, 0x6c, 0xcf, 0xe7, 0xd1, 0xd6, 0x44, 0xf7, 0x9d, 0x56,
	0x82, 0xe7, 0xd6, 0xed, 0xb1, 0xcd, 0x24, 0x06, 0xbf, 0x80, 0x72, 0x94, 0xf2, 0xd6, 0x13, 0xc7,
	0x58, 0xe3, 0x1d, 0xa9, 0xa6, 0x34, 0x73, 0x7b, 0xe5, 0x76, 0x3d, 0xad, 0x96, 0x29, 0x53, 0xf0,
	0x3e, 0xa8, 0x09, 0xe8, 0x87, 0x09, 0x09, 0xaf, 0xd1, 0x63, 0x79, 0x82, 0x81, 0xe7, 0xc8, 0x12,
	0x55, 0xb3, 0x28, 0xcf, 0x46, 0xf1, 0x06, 0xd4, 0x0d, 0x97, 0x5e, 0x06, 0xc3, 0xc9, 0x88, 0x24,
	0x59, 0x7c, 0x08, 0x0f, 0xe2, 0x38, 0x57, 0xc4, 0xa3, 0xcc, 0xb3, 0x29, 0xfe, 0x9e, 0x15, 0x4a,
	0xcd, 0xe3, 0x13, 0x8a, 0xfa, 0x00, 0x76, 0xe0, 0xfb, 0x03, 0xca, 0x2c, 0x46, 0x04, 0xd9, 0xb5,
	0xf6, 0xf3, 0xc5, 0x11, 0x93, 0x08, 0xbe, 0xd6, 0x03, 0xdf, 0x27, 0x36, 0xf3, 0x02, 0x9f, 0xc7,
	0x88, 0x59, 0xe2, 0x25, 0xc4, 0x27, 0xda, 0x84, 0xd2, 0x98, 0x90, 0x70, 0x20, 0x08, 0xcf, 0x4a,
	0xc2, 0x79, 0xa0, 0xcf, 0x09, 0x3f, 0x85, 0xa2, 0xd8, 0xb4, 0x5c, 0xa1, 0x45, 0xad, 0xbd, 0xff,
	0xbb, 0x4e, 0x1d, 0xc7, 0x09, 0x09, 0xa5, 0xa7, 0xd6, 0xc8, 0x1b, 0x5e, 0x9b, 0x05, 0x8e, 0xee,
	0xb8, 0xf8, 0x4a, 0x78, 0x67, 0x61, 0x0a, 0xb4, 0x0e, 0xf9, 0xfe, 0x79, 0xbf, 0xab, 0x66, 0x50,
	0x0d, 0x40, 0x3f, 0xef, 0xf7, 0xbb, 0xfa, 0xc7, 0x5e, 0xff, 0x4c, 0x55, 0x50, 0x15, 0x4a, 0xd1,
	0xba, 0x6b, 0xa8, 0x59, 0x74, 0x1f, 0xaa, 0x46, 0xef, 0x22, 0x91, 0x91, 0x43, 0x2a, 0x54, 0xe6,
	0xa1, 0xae, 0xa1, 0xe6, 0xf1, 0x53, 0x21, 0xc5, 0x8d, 0xfe, 0xbc, 0x43, 0xef, 0xfd, 0xe5, 0xb1,
	0x9a, 0x89, 0xbe, 0x4e, 0x54, 0x05, 0x7f, 0xcd, 0x42, 0x29, 0x1e, 0x7c, 0x25, 0xcf, 0x6e, 0x42,
	0x69, 0x2a, 0x50, 0x73, 0xd7, 0xae, 0xcb, 0x40, 0xcf, 0x49, 0x1a, 0x3a, 0x77, 0xc3, 0xd0, 0xfa,
	0x4d, 0x83, 0xe6, 0x45, 0xab, 0xdd, 0x74, 0x1e, 0x97, 0x59, 0x14, 0x9d, 0xc0, 0x1a, 0x17, 0x7c,
	0xe6, 0xef, 0xe6, 0x72, 0x19, 0xa4, 0x75, 0x4c, 0x99, 0x8e, 0x8e, 0xa1, 0x40, 0x85, 0x36, 0x5a,
	0x41, 0x00, 0xb7, 0xee, 0xd2, 0xcf, 0x8c, 0x72, 0x71, 0x07, 0xaa, 0xf1, 0x96, 0xb8, 0x12, 0x07,
	0x50, 0x94, 0x07, 0x9d, 0x5d, 0x8a, 0x8d, 0xf4, 0x3a, 0xe6, 0x2c, 0x0d, 0x1f, 0x09, 0xc5, 0xe7,
	0x25, 0xe4, 0xd5, 0xd8, 0x06, 0x88, 0x19, 0x9c, 0x5d, 0x8e, 0xd2, 0x8c, 0x42, 0xda, 0xfe, 0x99,
	0x17, 0xd2, 0xc8, 0x97, 0x0e, 0xbd, 0x83, 0x42, 0xe4, 0xf9, 0x27, 0x8b, 0xdd, 0x52, 0x5e, 0xc9,
	0xc6, 0xd6, 0x5d, 0x49, 0x38, 0x83, 0x5e, 0x42, 0x45, 0x3e, 0x79, 0x7a, 0x48, 0xb8, 0xfb, 0x52,
	0xef, 0x75, 0xa3, 0x9e, 0xf0, 0x80, 0x39, 0xb6, 0x4d, 0x42, 0x27, 0x43, 0x96, 0x44, 0x7f, 0x1a,
	0x3b, 0xff, 0x80, 0x36, 0xc8, 0x90, 0xac, 0x8c, 0x3e, 0x03, 0x90, 0x68, 0xa1, 0xc5, 0x76, 0x1a,
	0x36, 0xa6, 0xb8, 0xa1, 0x2d, 0xdb, 0xc6, 0x19, 0xf4, 0x0a, 0x2a, 0xb1, 0xcf, 0xf8, 0x21, 0x96,
	0xa8, 0xb8, 0x74, 0x90, 0x18, 0x1f, 0x91, 0xf0, 0xd7, 0xf8, 0x88, 0x86, 0x55, 0xf1, 0x6f, 0x00,
	0x12, 0xa6, 0xdc, 0x49, 0x47, 0xcf, 0xa9, 0x68, 0x2c, 0x4f, 0xc0, 0x99, 0xf6, 0x0f, 0xf9, 0x0e,
	0x48, 0x66, 0xef, 0x32, 0x5b, 0xca, 0x4f, 0xe8, 0x6d, 0xb3, 0x25, 0x93, 0xfe, 0x03, 0xa6, 0x7b,
	0xab, 0x31, 0xbd, 0xa4, 0x3c, 0xce, 0x1c, 0x28, 0x57, 0x05, 0xf1, 0xf7, 0xe6, 0xe8, 0x57, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x0a, 0x1b, 0x00, 0xbe, 0x0b, 0x09, 0x00, 0x00,
}
