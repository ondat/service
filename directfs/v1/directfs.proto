syntax = "proto3";
package directfs.v1;
option go_package = "code.storageos.net/storageos/service/directfs/v1";

import "common.proto";

/**
 * DirectFS client configuration and status service.
 *
 * Use 'Initiator' instead of 'Client' to avoid having a DfsClientClient
 * and DfsClientServer, which would be stupid.
 */
service DfsInitiator {

    /**
     * Get program status.
     */
    rpc Status(DfsInitiatorStatusRequest) returns (DfsInitiatorStatus) {}

    /**
     * Add a remote host entry to be used by volumes.
     *
     * returns RpcResult
     */
    rpc NodeCreate(DfsInitiatorNode) returns (common.v1.RpcResult) {}

    /**
     * Update a remote host entry to be used by volumes.
     *
     * returns RpcResult
     */
    rpc NodeUpdate(DfsInitiatorNode) returns (common.v1.RpcResult) {}

    /**
     * Remove a remote host entry.
     *
     * This will likely result in any volumes using this host to
     * become unconfigured. That has serious consequences.
     *
     * returns RpcResult
     */
    rpc NodeDelete(DfsInitiatorNode) returns (common.v1.RpcResult) {}

    /**
     * List configured host entries, optionally filtered via a DfsHostListQuery
     * message.
     *
     * returns A DfsHostList message containing DfsHost messages,
     *         if any are available matching the filter.
     */
    rpc NodeList(DfsInitiatorNodeListQuery) returns (DfsInitiatorNodeList) {}

    /**
     * Create a volume on a remote host. The DfsHost matching the host id
     * in the DfsVolume message must be configured for the volume to actually
     * be configured on the DirectFS client.
     *
     * returns RpcResult
     */
    rpc VolumeCreate(DfsInitiatorVolume) returns (common.v1.RpcResult) {}

    /**
     * Update a volume on a remote host. The DfsHost matching the host id
     * in the DfsVolume message must be configured for the volume to actually
     * be configured on the DirectFS client.
     *
     * returns RpcResult
     */
    rpc VolumeUpdate(DfsInitiatorVolume) returns (common.v1.RpcResult) {}

    /**
     * Delete a volume previously configured by VolumeCreate.
     *
     * returns RpcResult
     */
    rpc VolumeDelete(DfsInitiatorVolume) returns (common.v1.RpcResult) {}

    /**
     * List configured volume entries, optionally filtered via a DfsVolumeListQuery
     * message.
     *
     * returns A DfsVolumeList message containing DfsVolume messages,
     *         if any are available matching the filter.
     */
    rpc VolumeList(DfsInitiatorVolumeListQuery) returns (DfsInitiatorVolumeList) {}

    /**
     * List data-plane stats, optionally filtered using a StatsListQuery message.
     *
     * returns A StatsListResponse containing Statistic messages, if any are
     * found matching the filter.
     */
     rpc StatsList(common.v1.StatsListQuery) returns (common.v1.StatsListResponse) {}

    // Config services, from common.v1.
    rpc ConfigGetBool(common.v1.ConfigKey) returns (common.v1.ConfigGetBoolReply) {}
    rpc ConfigUpdateBool(common.v1.ConfigBool) returns (common.v1.ConfigUpdateReply) {}
    rpc ConfigListBool(common.v1.ConfigListQuery) returns (common.v1.ConfigBoolList) {}

    rpc ConfigGetString(common.v1.ConfigKey) returns (common.v1.ConfigGetStringReply) {}
    rpc ConfigUpdateString(common.v1.ConfigString) returns (common.v1.ConfigUpdateReply) {}
    rpc ConfigListString(common.v1.ConfigListQuery) returns (common.v1.ConfigStringList) {}
}

/**
 * DirectFS server configuration and status service.
 *
 * Use 'Responder' instead of 'Server' to avoid having DfsServerClient and
 * DfsServerServer, which would be stupid.
 */
service DfsResponder {
    /**
     * Get program status.
     */
    rpc Status(DfsResponderStatusRequest) returns (DfsResponderStatus) {}

    /**
     * Create a volume to be served via DFS. Currently does nothing, but should still
     * be performed as in the near future it will certainly be required.
     *
     * returns RpcResult
     */
    rpc VolumeCreate(DfsResponderVolume) returns (common.v1.RpcResult) {}

    /**
     * Update a volume to be served via DFS. Currently does nothing, but should still
     * be performed as in the near future it will certainly be required.
     *
     * returns RpcResult
     */
    rpc VolumeUpdate(DfsResponderVolume) returns (common.v1.RpcResult) {}

    /**
     * Delete a volume to be served via DFS. Currently does nothing, but should still
     * be performed as in the near future it will certainly be required.
     *
     * returns RpcResult
     */
    rpc VolumeDelete(DfsResponderVolume) returns (common.v1.RpcResult) {}

    /**
     * List configured volume entries, optionally filtered via a DfsVolumeListQuery
     * message.
     *
     * returns a list of DfsReponderVolume messages, if any are available matching the filter.
     */
    rpc VolumeList(DfsResponderVolumeListQuery) returns (DfsResponderVolumeList) {}

    /**
     * List data-plane stats, optionally filtered using a StatsListQuery message.
     *
     * returns A StatsListResponse containing Statistic messages, if any are
     * found matching the filter.
     */
     rpc StatsList(common.v1.StatsListQuery) returns (common.v1.StatsListResponse) {}

    // Config services, from common.v1.
    rpc ConfigGetBool(common.v1.ConfigKey) returns (common.v1.ConfigGetBoolReply) {}
    rpc ConfigUpdateBool(common.v1.ConfigBool) returns (common.v1.ConfigUpdateReply) {}
    rpc ConfigListBool(common.v1.ConfigListQuery) returns (common.v1.ConfigBoolList) {}

    rpc ConfigGetString(common.v1.ConfigKey) returns (common.v1.ConfigGetStringReply) {}
    rpc ConfigUpdateString(common.v1.ConfigString) returns (common.v1.ConfigUpdateReply) {}
    rpc ConfigListString(common.v1.ConfigListQuery) returns (common.v1.ConfigStringList) {}
}


message DfsInitiatorStatusRequest {
    // Empty for now.
}

message DfsInitiatorStatus {
    // The version control info string.
    string version_info = 1;

    // Generic daemon status.
    common.v1.DaemonStatus status = 2;
}

message DfsResponderStatusRequest {
    // Empty for now.
}

message DfsResponderStatus {
    // The version control info string.
    string version_info = 1;

    // Generic daemon status.
    common.v1.DaemonStatus status = 2;
}

//
// Client (Initiator) messages.
//

message DfsInitiatorNodeCredentials {
    // Empty for now.
    // Could be used for:
    // - (server) tls creds (if per-host)
    // - (client) tls creds (if per-host)
}

/**
 * A host used by DirectFS.
 */
message DfsInitiatorNode {
    common.v1.DataplaneCommon cc = 1;

    // The unique host identifier.
    uint32 node_id = 2;

    // The remote hostname.
    string hostname = 3;

    // The remote port.
    uint32 port = 4;

    // Host credentials.
    DfsInitiatorNodeCredentials credentials = 5;
}

message DfsInitiatorNodeList {
    repeated DfsInitiatorNode nodes = 1;
}

message DfsInitiatorNodeListQuery {
    // An optional list of hosts to query.
    repeated uint32 node_ids = 1;
}

message DfsInitiatorVolumeCredentials {
    // Empty for now.
    // Could be used for:
    // - (server) tls creds (if per-volume), valid client IPs
    // - (client) tls creds (if per-volume)
}

message DfsInitiatorVolumeStatistics {
    // Empty for now.
}

message DfsInitiatorVolumeStatus {

    enum DfsInitiatorConnectionState {
        NONE = 0;
        CONNECTING = 1;
        CONNECTED = 2;
        DISCONNECTING = 3;
        DISCONNECTED = 4;
    }

    DfsInitiatorConnectionState conn_state = 1;

    // The remote peer, in string form for simplicity.
    string peer_name = 2;

    enum DfsInitiatorAddressFamily {
        IPV4 = 0;
        IPV6 = 1;
    }

    // The address family we're using to connect to the peer.
    DfsInitiatorAddressFamily peer_af = 3;
}

/**
 * A volume used by DirectFS.
 *
 * The remote host (for the client) isn't directly included here. However, the
 * client clearly can't connect without a properly configured node_id item.
 *
 * The split between host and volume objects was decided based on now-irrelevant
 * implementation details of ConfigFS v1. However, there's still some logic to
 * it if the authentication (especially TLS) is per-host rather than per-volume.
 */
message DfsInitiatorVolume {
    common.v1.DataplaneCommon cc = 1;

    // The volume ID.
    uint32 volume_id = 2;

    // The host for this volume.
    uint32 node_id = 3;

    // Volume credentials.
    DfsInitiatorVolumeCredentials credentials = 4;

    // Volume statistics.
    DfsInitiatorVolumeStatistics stats = 5;

    // Server status for the volume.
    DfsInitiatorVolumeStatus status = 6;
}

message DfsInitiatorVolumeList {
    repeated DfsInitiatorVolume volumes = 1;
}

message DfsInitiatorVolumeListQuery {
    // An optional list of volumes to query.
    repeated uint32 volume_ids = 1;
}

message DfsResponderVolumeCredentials {
    // Empty for now.
    // Could be used for:
    // - (server) tls creds (if per-volume), valid client IPs
    // - (client) tls creds (if per-volume)
}

message DfsResponderVolumeStatistics {
    // Empty for now.
}

message DfsResponderVolumeStatus {

    enum DfsResponderConnectionState {
        NONE = 0;
        CONNECTING = 1;
        CONNECTED = 2;
        DISCONNECTING = 3;
        DISCONNECTED = 4;
    }

    DfsResponderConnectionState conn_state = 1;

    // The remote peer, in string form for simplicity.
    string peer_name = 2;

    enum DfsResponderAddressFamily {
        IPV4 = 0;
        IPV6 = 1;
    }

    // The address family we're using to connect to the peer.
    DfsResponderAddressFamily peer_af = 3;
}

/**
 * A volume used by DirectFS.
 *
 * The remote host (for the client) isn't directly included here. However, the
 * client clearly can't connect without a properly configured node_id item.
 *
 * The split between host and volume objects was decided based on now-irrelevant
 * implementation details of ConfigFS v1. However, there's still some logic to
 * it if the authentication (especially TLS) is per-host rather than per-volume.
 */
message DfsResponderVolume {
    common.v1.DataplaneCommon cc = 1;

    // The volume ID.
    uint32 volume_id = 2;

    // The host for this volume.
    uint32 node_id = 3;

    // Volume credentials.
    DfsResponderVolumeCredentials credentials = 4;

    // Volume statistics.
    DfsResponderVolumeStatistics stats = 5;

    // Server status for the volume.
    DfsResponderVolumeStatus status = 6;
}

message DfsResponderVolumeList {
    repeated DfsResponderVolume volumes = 1;
}

message DfsResponderVolumeListQuery {
    // An optional list of volumes to query.
    repeated uint32 volume_ids = 1;
}